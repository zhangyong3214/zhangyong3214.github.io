<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>军事级别安全强度，免费密码管理工具KeePass，永远滴神</title>
      <link href="/2022/04/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/%E5%85%8D%E8%B4%B9%E5%AF%86%E7%A0%81%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7KeePass%E6%B0%B8%E8%BF%9C%E7%9A%84%E7%A5%9E/"/>
      <url>/2022/04/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/%E5%85%8D%E8%B4%B9%E5%AF%86%E7%A0%81%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7KeePass%E6%B0%B8%E8%BF%9C%E7%9A%84%E7%A5%9E/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>​    <strong>欢迎大家收看本篇文章对应B站视频解说</strong>：👉 <a href="https://www.bilibili.com/video/BV1oU4y1j7vE/">点此跳转B站视频解说教程</a>  👈</p><p>​    大家好，我是喜欢科技，喜欢分享，喜欢软件，喜欢折腾，有洁癖又有强迫症的科技农名工—李苟蛋，今天我来给大家分享一款密码管理软件：KeePass。你是否有过这种经历：平均每半个月或者一个月，我们再登录某些网站或者登录某些账号的时候，发现我们的密码记不住了，用常用的密码试过几次之后，发现还是不对，干脆直接点击忘记密码，用手机验证码或者邮箱验证码找回密码更改成为我们常用的密码，如果这个网站或者这个账号我们好久没登录过，绑定的手机号还是我之前用过的手机号，可能就得通过申诉提供各种资料找回密码，那等待你的将是噩梦级别的操作，如果这个账号不太重要，我不要了也就算了，如果这个账号很重要，那此时此刻你的内心应该已经万马(羊驼)崩腾了。有些人可能喜欢把密码记录在一个特定的笔记本上面，但是如果这个笔记本丢了….丢在家里找不到还好说，万一丢在外面，那你担心的应该不是你有很多网站登录不上了，而是你的密码很可能被别人知道了；还有人喜欢把密码记录在电脑的本地记事本，或者手机的记事本里面，但是这只存在于你电脑本地或者手机本地，万一电脑重装系统，或者换手机……又是个难题，此时此刻聪明的你可能会想，那我把密码放在云笔记里面，我把这个笔记在加个打开密码，那不就好了吗？没错，我在认识KeePass之前，我就是这么做的，但是你放在云笔记里面，在加个笔记的开启密码，这种情况，你的密码就依赖了云笔记服务商的服务器，而且你把密码都放到人家的服务器上，你觉得这是安全的吗？难道你真的认为你加了一个开启密码，就没有人能看到了吗？你的开启密码的加密算法可都是人家云笔记运营商给你提供的…..</p><p>​    现在我就来给大家隆重介绍一下今天的主角，KeePass，并详细说明它是如何解决我们上述的这些问题的。目前主流的密码管理工具主要有：<strong>KeePass</strong>（免费 开源 兼容性强），<strong>LastPass</strong>（最大的优势是跨浏览器平台，收费），<strong>1Password</strong>（跨平台管理 用户认可度高），<strong>Enpass</strong>（支持平台多 20条密码免费）。可以看出，除了KeePass，其他都是收费的，所以我们毫无悬念的选择了它，KeePass从2003年至今具有近20年的时间，而且开源免费，开源的好处就是民间大神都可以看他的源代码，只要发现安全漏洞就可以去提交评论做修复，所以安全级别是可以放心的，如果你担心有安全问题想阅读源码也可以去<a href="https://sourceforge.net/p/keepass/code/HEAD/tree/">官方查看</a>。 接下来就让我介绍一下如何用KeePass搭建一个可以实现云同步的密码管理工具吧。</p><h3 id="KeePass下载及使用"><a href="#KeePass下载及使用" class="headerlink" title="KeePass下载及使用"></a>KeePass下载及使用</h3><h4 id="Keepa介绍"><a href="#Keepa介绍" class="headerlink" title="Keepa介绍"></a>Keepa介绍</h4><p>​    KeePass不会上传你的账号密码，你的账号密码保存在你本地(数据库)，你只需要创建一个开启这个数据库的钥匙，这个钥匙非常重要，它是你能否打开软件的关键，这个钥匙可以是一串密码，也可以是一个文件，文件可以是任何文件，一部电影，一个word文档，一个txt文本，一首歌等，都可以当做开启数据库的密钥文件，或者是密码加文件的组合的方式来设置你的开启钥匙，还可以是一个实体密钥(类似于U盾)，本人推荐使用密码加文件的方式作为数据库的开启钥匙，这样，开启密码我们就不用设置的太复杂，也不用担心开启密码泄露导致我们的数据库文件被别人拿到之后被别人打开，别人能同时拿到密码和文件简直太难了。</p><h4 id="PC端客户端KeePassXC"><a href="#PC端客户端KeePassXC" class="headerlink" title="PC端客户端KeePassXC"></a>PC端客户端KeePassXC</h4><p>​    <a href="https://keepass.info/">KeePass官网</a>，提供了KeePass软件的下载，官方只提供了PC端下载，不过还好，很多民间大神也做了很多支持KeePass的客户端供我们使用，官方也有推荐列表。电脑端（windows和Mac平台），我推荐使用<a href="https://keepassxc.org/">KeePassXC</a>，这也是支持KeePass的由非官方开发的一款软件，KeePass官方推荐列表里面有，之所以推荐它，是因为他界面美观，还有对应的浏览器插件，可以实现密码自动填充。安卓端我推荐使用<a href="https://play.google.com/store/apps/details?id=keepass2android.keepass2android">KeePass2Android</a>，这款软件下载需要上谷歌商店，可能得需要科学上网，这里我给大家提供了蓝奏云下载，方便大家下载安装，由于本人没有苹果手机，所以IPhone用户就需要小伙伴自己去官方推荐的软件里面寻找适合苹果手机的客户端了(#^.^#)~</p><p><img src="/images/keepass/20210828231940.png" style="zoom: 80%;" /> <img src="/images/keepass/20210828232127.png" style="zoom: 80%;" /> </p><img src="/images/keepass/20210828232715.png" style="zoom:80%;" /> <h4 id="KeePassXC使用介绍"><a href="#KeePassXC使用介绍" class="headerlink" title="KeePassXC使用介绍"></a>KeePassXC使用介绍</h4><p>下图为我的KeePass的客户端安装配置之后的效果，怎么样，还不错吧~</p><img src="/images/keepass/20210828233458.png" style="zoom: 67%;" /><p><a href="https://keepassxc.org/">下载</a>安装KeePass之后，我们需要设置一下我们数据库存放的本地位置，然后设置数据库开启密码，开启密钥文件，这里我推荐手动创建一个文件，后缀名随意，然后用记事本打开，在里面输入一些文章，例如你喜欢的诗词之类的，字书不要太多，尽量控制在1千字以内就行，避免文件过大，然后吧这个密钥文件好好保存起来，我建议用你常用的邮箱给自己发个邮件然后以附件的方式保存在你的邮件里面，这样他就永远不会丢了，或者放到你的云盘，NAS上面，不要把它和数据库放在一起！！！如果是Mac本支持指纹识别，输入一次密码和密钥文件之后，下次就可以通过指纹打开你的数据库了，但是这不代表你的密码和密钥文件就没用了，指纹打开数据库的原理其实就是通过指纹映射到你的密码和密钥文件，所以说，数据库开启密码和密钥文件很重要，这个一定不能丢~</p><p><img src="/images/keepass/20210828235058.png"></p><p>进入之后，我们就可以添加分类，然后添加账号密码等等，具体的使用方法我会出视频讲解，欢迎朋友来B站关注我。</p><h4 id="浏览器插件使用-谷歌为例"><a href="#浏览器插件使用-谷歌为例" class="headerlink" title="浏览器插件使用(谷歌为例)"></a>浏览器插件使用(谷歌为例)</h4><h5 id="本地软件开启相应功能"><a href="#本地软件开启相应功能" class="headerlink" title="本地软件开启相应功能"></a>本地软件开启相应功能</h5><p>​    在KeePassXC打开设置-浏览器集成-启用浏览器集成-然后为你用的浏览器开启集成（见下图），这里墙裂建议使用谷歌浏览器，这是浏览器中的神。当然，想成为神，需要科学上网安装必要的插件才能够给谷歌浏览器注入神之灵魂，不要下载下来之后连个插件都没装就说浏览器不行，行不行得看用的人会不会用。总之，科技农民工里面应该没有几个人不用谷歌吧~</p><p><img src="/images/keepass/20210829000333.png"></p><h5 id="浏览器插件下载使用"><a href="#浏览器插件下载使用" class="headerlink" title="浏览器插件下载使用"></a>浏览器插件下载使用</h5><p>​    打开<a href="https://chrome.google.com/webstore/search/KeePassXC?utm_source=chrome-ntp-icon">谷歌应用商店</a>（注：这里可能需要科学上网），找到KeePassXC这个插件，安装之…. </p><p><img src="/images/keepass/20210829000839.png"></p><p>安装之后用浏览器插件链接本地KeePassXC软件，链接之后，就可以实现网站账号密码自动填充了，需要注意的是，自动填充的时候，一定要是你本地数据库打开的情况下，这样你就可以吧浏览器的记住密码功能关闭了，不过这个自动填充功能并不一定所有网站都可以，大概百分之80的网站都没问题，还有就是想要能关联到填充项目，需要你在你添加密码的时候，把对应的URL填写成为网站的登录地址或者网站的官网。</p><p><img src="/images/keepass/20210829001359.png"></p><h3 id="实现数据库云同步"><a href="#实现数据库云同步" class="headerlink" title="实现数据库云同步"></a>实现数据库云同步</h3><p>我们的数据库只存在于我们本地肯定是不行的，这跟我直接在本地搞一个记事本保存密码也差不了多少，重装系统之后，数据库丢了，就直接回到解放前了，这里我建议使用两种工具实现数据库云同步功能，第一款是微软出品的OneDrive，这款云盘可以实现云盘映射到本地指定路径，路径中的文件发生改变，会自动同步到云端，这样我们添加或者修改了账号密码之后，数据库都会自动同步到微软的OneDrive云盘，这样我们就实现了电脑端的数据库云同步，手机端Keepass2Android，也是支持读取OneDrive云盘文件的功能的；第二款同步工具是坚果云，原理和OneDrive一样，不过坚果云要实现手机同步，需要通过WebDav功能实现，坚果云是支持云文件设置成为WebDav服务的，而且坚果云号称是国内最安全的云盘，军工级的加密方案，你的数据库放在坚果云是安全的，就算有人能拿到你的数据库，没有密码和密钥文件，也是打不开的…</p><p><img src="/images/keepass/20210829002414.png"></p><h3 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h3><p>​    无论使用哪种同步方案，这种同步的思路明白了，也可以试试其他的KeePass 的客户端软件，文章中介绍的都是本人认为最好的方案，也是爱折腾的我在工作之余肝了好几个晚上定下的最终方案，也请大家多多关注我的个人博客和B站，有什么问题可以加我QQ或者B站留言私信给我…谢谢大家！</p>]]></content>
      
      
      <categories>
          
          <category> 软件分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>吐血整理IDEA必备插件(๑•̀ㅂ•́)و✧，让撸码效率提升1000%</title>
      <link href="/2022/04/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/%E5%90%90%E8%A1%80%E6%95%B4%E7%90%86IDEA%E5%BF%85%E5%A4%87%E6%8F%92%E4%BB%B6/"/>
      <url>/2022/04/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/%E5%90%90%E8%A1%80%E6%95%B4%E7%90%86IDEA%E5%BF%85%E5%A4%87%E6%8F%92%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>俗话说：“工欲善其事，必先利其器”，好的开发工具能让我们的工作效率翻倍，而好的开发工具加上优秀的插件，能让我们的工作效率提升十倍（<del>(@^_^@)</del>我要打十个），这也是我们区别于其他程序猿的必备工具，下面就是我从十余年工作中总结出来的好用的idea插件（好像工作的前五年我用的都是eclipse，哈哈(╯&gt;д&lt;)╯⁽˙³˙⁾，这不重要！）。插件主要分为：代码生成类，日常开发类，主题美化类，以下插件大都可以通过 IDEA 自带的插件管理中心安装，如果搜不到可以去 <a href="https://plugins.jetbrains.com/">IDEA 插件官网</a>下载本地导入。星号代表我个人的推荐指数 。 </p><h2 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h2><h3 id="Lombok"><a href="#Lombok" class="headerlink" title="Lombok"></a>Lombok</h3><ul><li><p>推荐指数：★★★★★</p></li><li><p>自动生成get、set方法</p></li></ul><h3 id="EasyCode"><a href="#EasyCode" class="headerlink" title="EasyCode"></a>EasyCode</h3><ul><li><p>推荐指数：★★</p></li><li><p>数据库逆向工程</p></li></ul><h3 id="GsonFormat"><a href="#GsonFormat" class="headerlink" title="GsonFormat"></a>GsonFormat</h3><ul><li><p>推荐指数：★★★★</p></li><li><p>通过json生成实体类</p></li></ul><h3 id="Codota"><a href="#Codota" class="headerlink" title="Codota"></a>Codota</h3><ul><li><p>推荐指数：★★★★★</p></li><li><p>代码提示</p></li></ul><p>该插件的强大之处在于：</p><ol><li>支持智能代码自动提示，该功能可以增强 IDEA 的代码提示功能；</li><li>支持 JDK 和知名第三方库的函数的使用方法搜索，可以看到其他知名开源项目对该函数的用法。</li></ol><p>当我们第一次使用某个类，对某个函数不够熟悉时，可以通过该插件搜索相关用法，快速模仿学习，使用方法：右键要搜索的类，选择 <em>Get relevant exanples</em> </p><h3 id="GenerateAllSetter"><a href="#GenerateAllSetter" class="headerlink" title="GenerateAllSetter"></a>GenerateAllSetter</h3><ul><li><p>推荐指数：★★★★★</p></li><li><p>变量自动生成set方法</p></li></ul><p><a href="https://github.com/gejun123456/intellij-generateAllSetMethod">插件官网地址</a> 。我们定义好从 A 类转换到 B 类的函数转换函数后，使用这两个插件可以自动调用 Getter 和 Setter 函数实行自动转换。实际开发中还有一个非常常见的场景：我们创建一个对象后，想依次调用 Setter 函数对属性赋值，如果属性较多很容易遗漏或者重复。可以使用GenerateAllSetter 提供的功能，自动调用所有 Setter 函数（可填充默认值），然后自己再跟进实际需求设置属性值。</p><h3 id="ignore"><a href="#ignore" class="headerlink" title=".ignore"></a>.ignore</h3><ul><li><p>推荐指数：★★★★</p></li><li><p>git提交时过滤掉不需要提交的文件，很方便，有些本地文件是不需要提交到Git上的，插件：ProjectView涵盖了此功能</p></li></ul><h3 id="CamelCase"><a href="#CamelCase" class="headerlink" title="CamelCase"></a>CamelCase</h3><ul><li><p>推荐指数：★★★★</p></li><li><p>将不是驼峰格式的名称，快速转成驼峰格式，安装好后，选中要修改的名称，按快捷键shift+alt+u。</p></li></ul><h2 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h2><h3 id="Alibaba-Java-Coding-Guidelines"><a href="#Alibaba-Java-Coding-Guidelines" class="headerlink" title="Alibaba Java Coding Guidelines"></a>Alibaba Java Coding Guidelines</h3><ul><li><p>推荐指数：★★★</p></li><li><p>插件功能：代码规范插件</p></li></ul><h3 id="jclasslib-bytecode-viewer"><a href="#jclasslib-bytecode-viewer" class="headerlink" title="jclasslib bytecode viewer"></a>jclasslib bytecode viewer</h3><ul><li><p>推荐指数：★★★</p></li><li><p>插件功能：可视化的字节码查看插件</p></li></ul><p><strong>使用方法</strong>：</p><ol><li>在 IDEA 打开想研究的类；</li><li>编译该类或者直接编译整个项目（ 如果想研究的类在 jar 包中，此步可略过）；</li><li>打开“view” 菜单，选择“Show Bytecode With jclasslib” 选项；</li><li>选择上述菜单项后 IDEA 中会弹出 jclasslib 工具窗口。</li></ol><p>那么有自带的强大的反汇编工具 javap 还有必要用这个插件吗？</p><p>这个插件的<strong>强大之处</strong>在于：</p><ol><li>不需要敲命令，简单直接，在右侧方便和源代码进行对比学习；</li><li>字节码命令支持超链接，<strong>点击其中的虚拟机指令即可跳转到 jvms 相关章节</strong>，超级方便。</li></ol><p>该插件对我们学习虚拟机指令有极大的帮助。</p><h3 id="FindBugs"><a href="#FindBugs" class="headerlink" title="FindBugs"></a>FindBugs</h3><ul><li>推荐指数：★★</li><li>插件功能：查找代码bug</li></ul><p>程序员总是想尽可能地避免写 BUG， FindBugs 作为静态代码检查插件，可以检查你代码中的隐患，并给出原因。</p><h3 id="SonarLine"><a href="#SonarLine" class="headerlink" title="SonarLine"></a>SonarLine</h3><ul><li><p>推荐指数：★★</p></li><li><p>插件功能：代码质量管理工具</p></li></ul><h2 id="日常开发"><a href="#日常开发" class="headerlink" title="日常开发"></a>日常开发</h2><h3 id="Translation"><a href="#Translation" class="headerlink" title="Translation"></a>Translation</h3><ul><li><p>推荐指数：★★★★</p></li><li><p>插件功能：翻译</p></li></ul><h3 id="Jrebel"><a href="#Jrebel" class="headerlink" title="Jrebel"></a>Jrebel</h3><ul><li><p>推荐指数：★★★</p></li><li><p>插件功能：热部署</p></li></ul><h3 id="Key-Promoter-X"><a href="#Key-Promoter-X" class="headerlink" title="Key Promoter X"></a>Key Promoter X</h3><ul><li><p>推荐指数：★★</p></li><li><p>插件功能：快捷键提示</p></li></ul><h3 id="MyBatis-Log-Plugin"><a href="#MyBatis-Log-Plugin" class="headerlink" title="MyBatis Log Plugin"></a>MyBatis Log Plugin</h3><ul><li><p>推荐指数：★★★★★</p></li><li><p>插件功能：打印sql</p></li></ul><h3 id="MyBatisX"><a href="#MyBatisX" class="headerlink" title="MyBatisX"></a>MyBatisX</h3><ul><li><p>推荐指数：★★★★★</p></li><li><p>插件功能：Mapper跳转Dao</p></li></ul><h3 id="Maven-Search"><a href="#Maven-Search" class="headerlink" title="Maven Search"></a>Maven Search</h3><ul><li><p>推荐指数：★★★★</p></li><li><p>插件功能：查询maven</p></li></ul><h3 id="Maven-Helper"><a href="#Maven-Helper" class="headerlink" title="Maven Helper"></a>Maven Helper</h3><ul><li><p>推荐指数：★★★★★</p></li><li><p>插件功能：依赖关系图</p></li></ul><p>安装后 IDEA 中打开 pom.xml 文件时，就会多出一个 “Dependency Analyzer” 选项卡。</p><h3 id="SequenceDiagram"><a href="#SequenceDiagram" class="headerlink" title="SequenceDiagram"></a>SequenceDiagram</h3><ul><li><p>推荐指数：★★★★</p></li><li><p>插件功能：时序图</p></li></ul><p>SequenceDiagram 可以根据代码调用链路自动生成时序图，超级赞，超级推荐！这对研究源码，梳理工作中的业务代码有极大的帮助，堪称神器。安装完成后，在某个类的某个函数中，右键 –&gt; Sequence Diagaram 即可调出。</p><h2 id="主题美化"><a href="#主题美化" class="headerlink" title="主题美化"></a>主题美化</h2><h3 id="Active-power-mode"><a href="#Active-power-mode" class="headerlink" title="Active power mode"></a>Active power mode</h3><ul><li><p>推荐指数：★★</p></li><li><p>插件功能：打字特效</p></li></ul><h3 id="Rainbow-Branckets"><a href="#Rainbow-Branckets" class="headerlink" title="Rainbow Branckets"></a>Rainbow Branckets</h3><ul><li><p>推荐指数：★★★</p></li><li><p>插件功能：彩虹扩号</p></li></ul><p><a href="https://github.com/izhangzhihao/intellij-rainbow-brackets">插件github地址</a> 。由于很多人没有养成好的编码风格，没有随手 format 代码的习惯，甚至有些同事会写代码超过几百行，阅读起来将非常痛苦。痛苦的原因之一就是找到上下文，由于括号太多，不确定当前代码行是否属于某个代码块，此时这个插件就会帮上大忙。双击顶部的类名可以跳转到对应类的源码中，双击调用的函数名可以直接调入某个函数的源码，总之非常强大。</p><h3 id="CodeGlance"><a href="#CodeGlance" class="headerlink" title="CodeGlance"></a>CodeGlance</h3><ul><li><p>推荐指数：★★★</p></li><li><p>插件功能：代码迷你小地图</p></li></ul><p>类似于sublime的右侧代码小地图，CodeGlance2为原版加强</p><h3 id="Xcode-Drak-theme"><a href="#Xcode-Drak-theme" class="headerlink" title="Xcode Drak theme"></a>Xcode Drak theme</h3><ul><li><p>推荐指数：★</p></li><li><p>插件功能：主题</p></li></ul><h3 id="Material-Theme-UI"><a href="#Material-Theme-UI" class="headerlink" title="Material Theme UI"></a>Material Theme UI</h3><ul><li><p>推荐指数：★</p></li><li><p>插件功能：多种主题</p></li></ul><p>对于很多人而言，写代码时略显枯燥的，如果能够安装自己喜欢的主题将为开发工作带来些许乐趣。IDEA 支持各种主题插件，其中最出名的当属 Material Theme UI。安装后，可以从该插件内置的各种风格个选择自己最喜欢的一种。</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA常用快捷键(Mac版)</title>
      <link href="/2022/04/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/IDEA%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/2022/04/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/IDEA%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="Mac键盘符号和修饰键说明"><a href="#Mac键盘符号和修饰键说明" class="headerlink" title="Mac键盘符号和修饰键说明"></a>Mac键盘符号和修饰键说明</h3><ul><li><p>⌘ Command</p></li><li><p>⇧ Shift</p></li><li><p>⌥ Option</p></li><li><p>⌃ Control</p></li><li><p>↩︎ Return/Enter </p></li><li><p>⌫ Delete</p></li><li><p>⌦ 向前删除键（Fn+Delete）</p></li><li><p>↑ 上箭头</p></li><li><p>↓ 下箭头</p></li><li><p>← 左箭头</p></li><li><p>→ 右箭头</p></li><li><p>⇞ Page Up（Fn+↑）</p></li><li><p>⇟ Page Down（Fn+↓）</p></li><li><p>Home Fn + ←</p></li><li><p>End Fn + →</p></li><li><p>⇥ 右制表符（Tab键）</p></li><li><p>⇤ 左制表符（Shift+Tab）</p></li><li><p>⎋ Escape (Esc)</p></li></ul><h3 id="Editing（编辑）"><a href="#Editing（编辑）" class="headerlink" title="Editing（编辑）"></a>Editing（编辑）</h3><ul><li>⌃Space 基本的代码补全（补全任何类、方法、变量）</li><li>⌃⇧Space 智能代码补全（过滤器方法列表和变量的预期类型）</li><li>⌘⇧↩ 自动结束代码，行末自动添加分号</li><li>⌘P 显示方法的参数信息</li><li>⌃J, Mid. button click 快速查看文档</li><li>⇧F1 查看外部文档（在某些代码上会触发打开浏览器显示相关文档）</li><li>⌘+鼠标放在代码上 显示代码简要信息</li><li>⌘F1 在错误或警告处显示具体描述信息</li><li>⌘N, ⌃↩, ⌃N 生成代码（getter、setter、构造函数、hashCode/equals,toString）</li><li>⌃O 覆盖方法（重写父类方法）</li><li>⌃I 实现方法（实现接口中的方法）</li><li>⌘⌥T 包围代码（使用if..else, try..catch, for, synchronized等包围 选中的代码）</li><li>⌘/ 注释/取消注释与行注释</li><li>⌘⌥/ 注释/取消注释与块注释</li><li>⌥↑ 连续选中代码块fa</li><li>⌥↓ 减少当前选中的代码块</li><li>⌃⇧Q 显示上下文信息</li><li>⌥↩ 显示意向动作和快速修复代码</li><li>⌘⌥L 格式化代码</li><li>⌃⌥O 优化import</li><li>⌃⌥I 自动缩进线</li><li>⇥ / ⇧⇥ 缩进代码 / 反缩进代码</li><li>⌘X 剪切当前行或选定的块到剪贴板</li><li>⌘C 复制当前行或选定的块到剪贴板</li><li>⌘V 从剪贴板粘贴</li><li>⌘⇧V 从最近的缓冲区粘贴</li><li>⌘D 复制当前行或选定的块</li><li>⌘⌫ 删除当前行或选定的块的行</li><li>⌃⇧J 智能的将代码拼接成一行</li><li>⌘↩ 智能的拆分拼接的行</li><li>⇧↩ 开始新的一行</li><li>⌘⇧U 大小写切换</li><li>⌘⇧] / ⌘⇧[ 选择直到代码块结束/开始</li><li>⌥⌦ 删除到单词的末尾（⌦键为Fn+Delete）</li><li>⌥⌫ 删除到单词的开头</li><li>⌘+ / ⌘- 展开 / 折叠代码块</li><li>⌘⇧+ 展开所以代码块</li><li>⌘⇧- 折叠所有代码块</li><li>⌘W 关闭活动的编辑器选项卡</li></ul><h3 id="Search-Replace（查询-替换）"><a href="#Search-Replace（查询-替换）" class="headerlink" title="Search/Replace（查询/替换）"></a>Search/Replace（查询/替换）</h3><ul><li>Double ⇧ 查询任何东西</li><li>⌘F 文件内查找</li><li>⌘G 查找模式下，向下查找</li><li>⌘⇧G 查找模式下，向上查找</li><li>⌘R 文件内替换</li><li>⌘⇧F 全局查找（根据路径）</li><li>⌘⇧R 全局替换（根据路径）</li><li>⌘⇧S 查询结构（Ultimate Edition 版专用，需要在Keymap中设置）</li><li>⌘⇧M 替换结构（Ultimate Edition 版专用，需要在Keymap中设置）</li></ul><h3 id="Usage-Search（使用查询）"><a href="#Usage-Search（使用查询）" class="headerlink" title="Usage Search（使用查询）"></a>Usage Search（使用查询）</h3><ul><li>⌥F7 / ⌘F7 在文件中查找用法 / 在类中查找用法</li><li>⌘⇧F7 在文件中突出显示的用法</li><li>⌘⌥F7 显示用法</li></ul><h3 id="Compile-and-Run（编译和运行）"><a href="#Compile-and-Run（编译和运行）" class="headerlink" title="Compile and Run（编译和运行）"></a>Compile and Run（编译和运行）</h3><ul><li>⌘F9 编译Project</li><li>⌘⇧F9 编译选择的文件、包或模块</li><li>⌃⌥R 弹出 Run 的可选择菜单</li><li>⌃⌥D 弹出 Debug 的可选择菜单</li><li>⌃R 运行</li><li>⌃D 调试</li><li>⌃⇧R, ⌃⇧D 从编辑器运行上下文环境配置</li></ul><h3 id="Debugging（调试）"><a href="#Debugging（调试）" class="headerlink" title="Debugging（调试）"></a>Debugging（调试）</h3><ul><li>F8 进入下一步，如果当前行断点是一个方法，则不进入当前方法体内</li><li>F7 进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该</li><li>方法体还有方法，则不会进入该内嵌的方法中</li><li>⇧F7 智能步入，断点所在行上有多个方法调用，会弹出进入哪个方法</li><li>⇧F8 跳出</li><li>⌥F9 运行到光标处，如果光标前有其他断点会进入到该断点</li><li>⌥F8 计算表达式（可以更改变量值使其生效）</li><li>⌘⌥R 恢复程序运行，如果该断点下面代码还有断点则停在下一个断点上</li><li>⌘F8 切换断点（若光标当前行有断点则取消断点，没有则加上断点）</li><li>⌘⇧F8 查看断点信息</li></ul><h3 id="Navigation（导航）"><a href="#Navigation（导航）" class="headerlink" title="Navigation（导航）"></a>Navigation（导航）</h3><ul><li>⌘O 查找类文件</li><li>⌘⇧O 查找所有类型文件、打开文件、打开目录，打开目录需要在输入的内容前面或后面加一个反斜杠/</li><li>⌘⌥O 前往指定的变量 / 方法</li><li>⌃← / ⌃→ 左右切换打开的编辑tab页</li><li>F12 返回到前一个工具窗口</li><li>⎋ 从工具窗口进入代码文件窗口</li><li>⇧⎋ 隐藏当前或最后一个活动的窗口，且光标进入代码文件窗口</li><li>⌘⇧F4 关闭活动run/messages/find/… tab</li><li>⌘L 在当前文件跳转到某一行的指定处</li><li>⌘E 显示最近打开的文件记录列表</li><li>⌘⌥← / ⌘⌥→ 退回 / 前进到上一个操作的地方</li><li>⌘⇧⌫ 跳转到最后一个编辑的地方</li><li>⌥F1 显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择(如在 代码编辑窗口可以选择显示该文件的Finder)</li><li>⌘B / ⌘ 鼠标点击 进入光标所在的方法/变量的接口或是定义处</li><li>⌘⌥B 跳转到实现处，在某个调用的方法名上使用会跳到具体的实现处，可以跳过接口</li><li>⌥ Space, ⌘Y 快速打开光标所在方法、类的定义</li><li>⌃⇧B 跳转到类型声明处</li><li>⌘U 前往当前光标所在方法的父类的方法 / 接口定义</li><li>⌃↓ / ⌃↑ 当前光标跳转到当前文件的前一个/后一个方法名位置</li><li>⌘] / ⌘[ 移动光标到当前所在代码的花括号开始/结束位置</li><li>⌘F12 弹出当前文件结构层，可以在弹出的层上直接输入进行筛选（可用于搜索类中的方法）</li><li>⌃H 显示当前类的层次结构</li><li>⌘⇧H 显示方法层次结构</li><li>⌃⌥H 显示调用层次结构</li><li>F2 / ⇧F2 跳转到下一个/上一个突出错误或警告的位置</li><li>F4 / ⌘↓ 编辑/查看代码源</li><li>⌥ Home 显示到当前文件的导航条</li><li>F3选中文件/文件夹/代码行，添加/取消书签</li><li>⌥F3 选中文件/文件夹/代码行，使用助记符添加/取消书签</li><li>⌃0…⌃9 定位到对应数值的书签位置</li><li>⌘F3 显示所有书签</li></ul><h3 id="Refactoring（重构）"><a href="#Refactoring（重构）" class="headerlink" title="Refactoring（重构）"></a>Refactoring（重构）</h3><ul><li>F5 复制文件到指定目录</li><li>F6 移动文件到指定目录</li><li>⌘⌫ 在文件上为安全删除文件，弹出确认框</li><li>⇧F6 重命名文件</li><li>⌘F6 更改签名</li><li>⌘⌥N 一致性</li><li>⌘⌥M 将选中的代码提取为方法</li><li>⌘⌥V 提取变量</li><li>⌘⌥F 提取字段</li><li>⌘⌥C 提取常量</li><li>⌘⌥P 提取参数</li></ul><h3 id="VCS-Local-History（版本控制-本地历史记录）"><a href="#VCS-Local-History（版本控制-本地历史记录）" class="headerlink" title="VCS/Local History（版本控制/本地历史记录）"></a>VCS/Local History（版本控制/本地历史记录）</h3><ul><li><p>⌘K 提交代码到版本控制器</p></li><li><p>⌘T 从版本控制器更新代码</p></li><li><p>⌥⇧C 查看最近的变更记录</p></li><li><p>⌃C 快速弹出版本控制器操作面板</p></li><li><p><strong>Live Templates（动态代码模板）</strong></p></li><li><p>⌘⌥J 弹出模板选择窗口，将选定的代码使用动态模板包住</p></li><li><p>⌘J 插入自定义动态代码模板</p></li></ul><h3 id="General（通用）"><a href="#General（通用）" class="headerlink" title="General（通用）"></a>General（通用）</h3><ul><li>⌘1…⌘9 打开相应编号的工具窗口</li><li>⌘S 保存所有</li><li>⌘⌥Y 同步、刷新</li><li>⌃⌘F 切换全屏模式</li><li>⌘⇧F12 切换最大化编辑器</li><li>⌥⇧F 添加到收藏夹</li><li>⌥⇧I 检查当前文件与当前的配置文件</li><li>`§⌃, ⌃``快速切换当前的scheme（切换主题、代码样式等）</li><li>⌘, 打开IDEA系统设置</li><li>⌘; 打开项目结构对话框</li><li>⇧⌘A 查找动作（可设置相关选项）</li><li>⌃⇥ 编辑窗口标签和工具窗口之间切换（如果在切换的过程加按上delete，则是关闭对应选中的窗口）</li></ul><h3 id="Other（一些官方文档上没有体现的快捷键）"><a href="#Other（一些官方文档上没有体现的快捷键）" class="headerlink" title="Other（一些官方文档上没有体现的快捷键）"></a>Other（一些官方文档上没有体现的快捷键）</h3><ul><li>⌘⇧8 竖编辑模式</li></ul><h4 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h4><ul><li>⌘O 查找类文件 Ctrl + N</li><li>⌘⌥O 前往指定的变量 / 方法 Ctrl + Shift + Alt + N</li><li>⌃← / ⌃→ 左右切换打开的编辑tab页 Alt← / Alt→</li><li>⎋ 从工具窗口进入代码文件窗口 ESC</li><li>⌘L 在当前文件跳转到某一行的指定处 Ctrl + G</li><li>⌘E 显示最近打开的文件记录列表 Ctrl + E</li><li>⌘⌥← / ⌘⌥→ 退回 / 前进到上一个操作的地方 Ctrl + Alt + ← Ctrl + Alt + →</li><li>⌘⇧⌫ 跳转到最后一个编辑的地方</li><li>⌃H 显示当前类的层次结构 Ctrl + H</li><li>⌘⇧H 显示方法层次结构</li><li>⌃⌥H 显示调用层次结构</li><li>F4 / ⌘↓ 编辑/查看代码源</li><li>⌘⌥U 显示类UML图</li><li>⌃J 查看注释</li></ul><h4 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h4><ul><li>⌥⌦ 删除到单词的末尾（⌦键为Fn+Delete）</li><li>⌥⌫ 删除到单词的开头</li><li>⌘+ / ⌘- 展开 / 折叠代码块</li><li>⌘F1 在错误或警告处显示具体描述信息</li><li>⌘⌥L 格式化代码</li><li>⌃⌥O 优化import</li><li>⇧↩ 开始新的一行</li><li>⌘⇧↩ 自动结束代码，行末自动添加分号</li><li>⌃I 实现方法（实现接口中的方法）</li><li>⇧F6 重命名文件或者变量</li><li>⌘N, ⌃↩, ⌃N 生成代码（getter、setter、构造函数、hashCode/equals,toString）</li><li>⌘P 显示方法的参数信息</li></ul><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><ul><li>Double⇧ 查找任何东西</li><li>⌘⇧F 全局查找（根据路径）</li><li>⌘F 文件内查找</li><li>⌘G 查找模式下，向下查找</li><li>⌘⇧G 查找模式下，向上查找</li><li>⌘⌥B 跳转到接口的实现</li><li>⌘U 查看接口定义</li><li>⌘⌥← / ⌘⌥→ 退回 / 前进到上一个操作的地方</li><li>⌘B / ⌘ 鼠标点击 进入光标所在的方法/变量的接口或是定义处</li><li>⌃⇧B 跳转到类型声明处</li><li>⌥ Space, ⌘Y 快速打开光标所在方法、类的定义</li><li>⌘O 查找类文件</li><li>⌘⇧O 查找所有类型文件、打开文件、打开目录，打开目录需要在输入的内容前面或后面加一个反斜杠/</li><li>F12 返回到前一个工具窗口</li><li>⎋ 从工具窗口进入代码文件窗口</li><li>⇧⎋ 隐藏当前或最后一个活动的窗口，且光标进入代码文件窗口</li><li>F3选中文件/文件夹/代码行，添加/取消书签</li><li>⌥F3 选中文件/文件夹/代码行，使用助记符添加/取消书签</li><li>⌃0…⌃9 定位到对应数值的书签位置</li><li>⌘F3 显示所有书签</li><li>⌥F1 显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择(如在代码编辑窗口可以选择显示该文件的Finder)</li><li>⌘F12 弹出当前文件结构层，可以在弹出的层上直接输入进行筛选（可用于搜索类中的方法）</li></ul><h4 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h4><ul><li>⌃⌘F 切换全屏模式</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git笔记-常用命令以及日常操作技巧汇总</title>
      <link href="/2022/04/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/git%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/04/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/git%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="1、为Git配置代理（解决国内连接git慢问题）"><a href="#1、为Git配置代理（解决国内连接git慢问题）" class="headerlink" title="1、为Git配置代理（解决国内连接git慢问题）"></a>1、为Git配置代理（解决国内连接git慢问题）</h3><p>相关文章：<a href="https://blog.csdn.net/a1527238987/article/details/80237076">解决git无法clone提示443以及配置git代理方法</a> </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 添加当前仓库配置：</span></span><br><span class="line">git config --local http.proxy &quot;127.0.0.1:1087&quot; </span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除当前仓库配置：</span></span><br><span class="line">git config --unset --local http.proxy</span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加全局配置：</span></span><br><span class="line">git config --global http.proxy &quot;127.0.0.1:1087&quot; </span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除全局配置：</span></span><br><span class="line">git config --unset --global http.proxy</span><br></pre></td></tr></table></figure><span id="more"></span><p>注：添加相关配置也可以到本地仓库对应的目录，修改.git文件夹里面的config文件，如下图，我的本地的1087端口是我的科学上网地址<img src="https://gitee.com/lizejiao/img-go/raw/master/images/git-img1.jpg" style="zoom:33%;" /> </p><p>config 配置有system级别 global（用户级别） 和local（当前仓库）三个 设置先从system-》global-》local  底层配置会覆盖顶层配置 分别使用–system/global/local 可以定位到配置文件</p><ul><li><strong>查看系统config</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --system --list</span><br></pre></td></tr></table></figure><ul><li><strong>查看当前用户（global）配置</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global --list</span><br></pre></td></tr></table></figure><ul><li><strong>查看当前仓库配置信息</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --local --list</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为MacOS打造自己炫酷终端-Iterm2+oh-my-zsh</title>
      <link href="/2022/04/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/%E4%B8%BAMacOS%E6%89%93%E9%80%A0%E8%87%AA%E5%B7%B1%E7%82%AB%E9%85%B7%E7%BB%88%E7%AB%AF-/"/>
      <url>/2022/04/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/%E4%B8%BAMacOS%E6%89%93%E9%80%A0%E8%87%AA%E5%B7%B1%E7%82%AB%E9%85%B7%E7%BB%88%E7%AB%AF-/</url>
      
        <content type="html"><![CDATA[<h3 id="1、iTerm2"><a href="#1、iTerm2" class="headerlink" title="1、iTerm2"></a>1、iTerm2</h3><ul><li><a href="https://iterm2.com/"><strong>iTerm2</strong></a> 是一款完全免费，专为 Mac OS 用户打造多命令行应用。</li><li>安装完成后，在/bin目录下会多出一个zsh的文件。</li><li>Mac系统默认使用dash作为终端，可以使用命令修改默认使用zsh：chsh -s /bin/zsh</li><li>如果想修改回默认dash，同样使用chsh命令即可：chsh -s /bin/bash</li><li>Zsh 是一款强大的虚拟终端，既是一个系统的虚拟终端，也可以作为一个脚本语言的交互解析器。<span id="more"></span></li></ul><h4 id="1-1、iterm2-安装"><a href="#1-1、iterm2-安装" class="headerlink" title="1.1、iterm2 安装"></a>1.1、iterm2 安装</h4><p><a href="https://iterm2.com/downloads.html">下载地址</a></p><h4 id="1-2、iTerm操作快捷键"><a href="#1-2、iTerm操作快捷键" class="headerlink" title="1.2、iTerm操作快捷键"></a>1.2、iTerm操作快捷键</h4><ul><li><p>command + t：新建窗口 </p></li><li><p>command + d：垂直分屏，</p></li><li><p>command + shift + d：水平分屏。</p></li><li><p>command + ] 和command + [ 在最近使用的分屏直接切换.</p></li><li><p>command + alt + 方向键：切换到指定位置的分屏。</p></li><li><p>command + 数字：切换标签页。</p></li><li><p>command + 方向键：按方向切换标签页。</p></li><li><p>shift + command + s：保存当前窗口快照。</p></li><li><p>command + alt + b：快照回放。很有意思的功能，你可以对你的操作根据时间轴进行回放。可以拖动下方的时间轴，也可以按左右方向键</p></li></ul><h4 id="1-3、创建一键登录服务器"><a href="#1-3、创建一键登录服务器" class="headerlink" title="1.3、创建一键登录服务器"></a>1.3、创建一键登录服务器</h4><h5 id="1-3-1、第一步：新建配置文件，内容："><a href="#1-3-1、第一步：新建配置文件，内容：" class="headerlink" title="1.3.1、第一步：新建配置文件，内容："></a>1.3.1、第一步：新建配置文件，内容：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">set user 用户名</span><br><span class="line">set host IP地址</span><br><span class="line">set password 密码</span><br><span class="line">spawn ssh $user@$host</span><br><span class="line">expect &quot;*assword:*&quot;</span><br><span class="line">send &quot;$password\r&quot;</span><br><span class="line">interact</span><br><span class="line">expect eof</span><br></pre></td></tr></table></figure><h5 id="1-3-2、第二步：iTerm2配置添加"><a href="#1-3-2、第二步：iTerm2配置添加" class="headerlink" title="1.3.2、第二步：iTerm2配置添加"></a>1.3.2、第二步：iTerm2配置添加</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect ~/.ssh/SIT02-10.231.143.184</span><br></pre></td></tr></table></figure><h3 id="2、Oh-My-Zsh"><a href="#2、Oh-My-Zsh" class="headerlink" title="2、Oh My Zsh"></a>2、Oh My Zsh</h3><p><a href="https://ohmyz.sh/">Oh My Zsh 官网</a></p><p>Oh My Zsh 是一款社区驱动的命令行工具，它基于 zsh 命令行，提供了主题配置，插件机制，已经内置的便捷操作。给我们一种全新的方式使用命令行。</p><h4 id="2-1、oh-my-zsh-安装"><a href="#2-1、oh-my-zsh-安装" class="headerlink" title="2.1、oh my zsh 安装"></a>2.1、oh my zsh 安装</h4><h5 id="2-1-1、方式1"><a href="#2-1-1、方式1" class="headerlink" title="2.1.1、方式1"></a>2.1.1、方式1</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</span><br></pre></td></tr></table></figure><h5 id="2-1-2、方式2"><a href="#2-1-2、方式2" class="headerlink" title="2.1.2、方式2"></a>2.1.2、方式2</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`sh -c &quot;$(wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot;`</span><br></pre></td></tr></table></figure><h5 id="2-1-3、方式3（国内推荐使用）"><a href="#2-1-3、方式3（国内推荐使用）" class="headerlink" title="2.1.3、方式3（国内推荐使用）"></a>2.1.3、方式3（国内推荐使用）</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c &quot;$(curl -fsSL https://gitee.com/pocmon/ohmyzsh/raw/master/tools/install.sh)&quot;</span><br></pre></td></tr></table></figure><h4 id="2-2、卸载oh-my-zsh"><a href="#2-2、卸载oh-my-zsh" class="headerlink" title="2.2、卸载oh my zsh"></a>2.2、卸载oh my zsh</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uninstall_on_my_zsh</span><br></pre></td></tr></table></figure><h4 id="2-3、更换主题"><a href="#2-3、更换主题" class="headerlink" title="2.3、更换主题"></a>2.3、更换主题</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vi ~/.zshrc</span><br><span class="line">ZSH_THEME=&quot;macovsky-ruby&quot;    &quot;steeef&quot;</span><br></pre></td></tr></table></figure><h4 id="2-4、安装语法高亮插件"><a href="#2-4、安装语法高亮插件" class="headerlink" title="2.4、安装语法高亮插件"></a>2.4、安装语法高亮插件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进入文件夹</span></span><br><span class="line">cd ~/.oh-my-zsh/custom/plugins</span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载插件</span></span><br><span class="line">git clone https://github.com/zsh-users/zsh-syntax-highlighting.git</span><br></pre></td></tr></table></figure><h4 id="2-5、自动补全插件"><a href="#2-5、自动补全插件" class="headerlink" title="2.5、自动补全插件"></a>2.5、自动补全插件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/zsh-users/zsh-autosuggestions.git</span><br></pre></td></tr></table></figure><h5 id="2-5-1、启用插件"><a href="#2-5-1、启用插件" class="headerlink" title="2.5.1、启用插件"></a>2.5.1、启用插件</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vi ~/.zshrc</span><br><span class="line">plugins=( git</span><br><span class="line">  zsh-autosuggestions</span><br><span class="line">  zsh-syntax-highlighting )</span><br><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker操作笔记-从小白到入门</title>
      <link href="/2022/04/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/Docker%E6%93%8D%E4%BD%9C%E7%AC%94%E8%AE%B0-%E4%BB%8E%E5%B0%8F%E7%99%BD%E5%88%B0%E5%85%A5%E9%97%A8/"/>
      <url>/2022/04/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/Docker%E6%93%8D%E4%BD%9C%E7%AC%94%E8%AE%B0-%E4%BB%8E%E5%B0%8F%E7%99%BD%E5%88%B0%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="1、Docker安装"><a href="#1、Docker安装" class="headerlink" title="1、Docker安装"></a>1、Docker安装</h3><p>centos  为例：查看版本：<code>cat /etc/redhat-release</code> <a href="https://docs.docker.com/install/linux/docker-ce/centos/">参考网址</a> </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.先安装gcc：yum -y install gcc  </span><br><span class="line">2.查看版本：gcc -v</span><br></pre></td></tr></table></figure><p><strong>安装需要的软件包</strong> <span id="more"></span></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure><h4 id="1-1、阿里加速："><a href="#1-1、阿里加速：" class="headerlink" title="1.1、阿里加速："></a>1.1、阿里加速：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><ul><li><strong>查看配置：</strong> <code>vi /etc/yum.repos.d/docker-ce.repo</code></li><li><strong>更新软件包：</strong> <code>yum makecache fast</code></li><li><strong>安装docker：</strong>  <code>yum install docker-ce docker-ce-cli containerd.io</code></li><li><strong>配置文件位置：</strong> <code>/etc/sysconfig/docker</code></li><li><strong>启动docker：</strong> <code>systemctl start docker</code></li><li><strong>设置开机启动：</strong> <code>systemctl enable docker</code></li><li><strong>查看docker启动进程：</strong> <code>ps -ef|grep docker</code></li><li><strong>查看docker版本：</strong> <code>docker version  docker info</code>   </li></ul><h4 id="1-2、下载镜像"><a href="#1-2、下载镜像" class="headerlink" title="1.2、下载镜像"></a>1.2、下载镜像</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysql:5.7  </span><br><span class="line">docker pull rabbitmq:management （带管理台的MQ）</span><br><span class="line">docker pull zookeeper:latest  </span><br><span class="line">docker pull redis:rc-buster</span><br></pre></td></tr></table></figure><ol><li><a href="https://hub.docker.com/search?q=&type=image">镜像搜索地址</a></li><li><a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors">镜像加速地址</a></li></ol><hr><h4 id="1-3、权限问题解决"><a href="#1-3、权限问题解决" class="headerlink" title="1.3、权限问题解决"></a>1.3、权限问题解决</h4><p>docker守护进程启动的时候，会默认赋予名字为docker的用户组读写Unix socket的权限，因此只要创建docker用户组，并将当前用户加入到docker用户组中，那么当前用户就有权限访问Unix socket了，进而也就可以执行docker相关命令</p><ol><li>添加docker用户组 <code>sudo groupadd docker</code> </li><li>将登陆用户加入到docker用户组中  <code>sudo gpasswd -a  $USER  docker</code></li><li>更新用户组 <code>newgrp docker</code></li><li>测试docker命令是否可以使用sudo正常使用 <code>docker ps</code> </li></ol><hr><h3 id="2、镜像操作"><a href="#2、镜像操作" class="headerlink" title="2、镜像操作"></a>2、镜像操作</h3><ul><li>查看镜像：<code>docker images</code>    </li><li>展示所有所有镜像（包含中间镜像层）：<code>docker images -a</code></li><li>查询镜像：<code>docker search 镜像名字</code></li><li>删除镜像：<code>docker rmi 镜像id</code></li></ul><h3 id="3、容器操作"><a href="#3、容器操作" class="headerlink" title="3、容器操作"></a>3、容器操作</h3><ul><li><strong>启动mysql：</strong> <code>docker run -p 3306:3306 --name mysql01 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7</code></li><li><strong>启动rabitmq：</strong> <code>docker run -d -p 5672:5672 -p 15672:15672 --name myrabitmq 镜像id</code> </li><li><strong>启动redis：</strong> <code>docker run -d -p 6379:6379 --name myredis 镜像id</code>   </li><li><strong>启动zookeeper：</strong> <code>docker run --name zk01 -p 2181:2181 --restart always -d 镜像id</code> </li><li><strong>启动nacos：</strong> <code>docker run --name nacos-2.0.1 -e MODE=standalone -p 8849:8848 -d nacos/nacos-server:2.0.1</code></li><li><strong>启动kibana：</strong> <code>docker run -d --name kibana7.7.1 --net mynet   -p 5601:5601 kibana:7.7.1</code></li></ul><p><strong>Kibana 在Doker中启动相关配置</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it kibana7.7.1 bash</span><br><span class="line">cd config </span><br><span class="line">vi kibana.yml</span><br></pre></td></tr></table></figure><ul><li><strong>查看日志：</strong> docker logs -f -t –tail 100 kibana7.7.1</li><li><strong>更新启动参数：</strong> docker update –restart=always xxx  </li><li><strong>查看所有容器：</strong> <code>docker ps -a</code></li><li><strong>查看启动容器：</strong> <code>docker ps</code>    </li><li><strong>启动已停止的容器：</strong> <code>docker start 容器id或名字</code></li><li><strong>关闭容器 ：</strong> <code>docker stop 容器id</code>    </li><li><strong>取消容器开机启动：</strong> <code>docker update --restart=no 容器ID</code></li><li><strong>强制关闭：</strong>  <code>docker kill 容器id</code>   </li><li><strong>删除已停止容器 ：</strong> <code>docker rm 容器id</code>    </li><li><strong>删除没有停止容器：</strong>  <code>docker rm -f 容器id</code>  </li><li><strong>进入容器内部：</strong> <code>docker exec -it 程序id /bin/bash</code>    </li><li><strong>exit 关闭容器退出(自测不会退出)：</strong>    <code>ctrl+p+q</code></li><li><strong>查看日志：</strong> <code>docker logs -f (追加) -t (加入时间戳) --tail 3 (显示最后3行) 容器id</code>  </li><li><strong>查看容器结构细节：</strong> <code>docker inspect 容器id</code>  </li><li><strong>拷贝容器中的文件：</strong> <code>docker cp 容器id:文件路径 要拷贝到的路径</code></li><li><strong>提交自己的docker镜像：</strong> <code>docker commit -a=&quot;lgd&quot; -m=&quot;mysql-lgd&quot; 243baa0ea2a7 ligoudan/lgd-mysql:1.0</code>  </li></ul>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/04/05/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/netty%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2022/04/05/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/netty%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="netty"><a href="#netty" class="headerlink" title="netty"></a>netty</h2><h3 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h3><blockquote><p>IO模型就是说用什么样的通道进行数据的发放和接收 t</p></blockquote><ol><li><p>BIO</p><blockquote><p>同步阻塞模型，一个客户端连接一个线程，如果有多个客户端，需要有多个线程来处理，可能超过服务端的资源限制。</p></blockquote></li></ol><p>在使用NIO过程中使用了socket.accept()。服务端的outputStream.write()。客户端的inputStream.read();都是阻塞方法。为了提升服务端的吞吐量，一般都会才会多线程的方式。</p><p>这个模型有以下几个致命问题</p><ul><li>线程的创建和销毁，在Linux这样的操作系统中，线程本质是一个进程。创建和销毁都是重量级的系统函数。</li><li>线程本身占用较大的内存，内存一般都会有内存的分配，如果系统的线程过多，那么整个JVM内存可能会吃完。</li><li>线程的切换成本也很很高，操作系统在发生线程切换时候需要保存线程的上线文，然后执行系统调用。</li></ul><blockquote><p>结论：NIO模型在线程过多时候(客户端并发度很高时候)，那么这种模型很占用大量的服务资源。</p></blockquote><ol start="2"><li>NIO</li></ol><blockquote><p>同步非阻塞IO模型。</p></blockquote><p>Channel、Buffer、选择器</p><p>ServerSocketChannel </p><p>Selector注册。多路复用选择器</p><p>和BIO相比，NIO把原来的阻塞读写(占用线程)编程了单线程轮训，找到可以进行读写的网络文件描述符进行读写。除了时间轮训是阻塞的，剩余IO操作都是存CPU操作，没必要开启多线程。</p><blockquote><p>由于线程的节约，连接数大的时候因为携程切换带来的问题也随之解决，进而为处理海量了解提供了可能。</p></blockquote><p>在NIO的模型下，我们需要三类线程</p><ul><li>事件分发器，单线程选择就绪事件。</li><li>I/O处理器，包括connnect、read、write等，这种存CPU操作，一般开启CPU核心线程数就可以</li><li>业务线程，在处理完I/O后，业务一般还会有自己的业务逻辑，有时候还会有阻塞I/O，如DB操作、PRC等操作</li></ul><ol start="3"><li>AIO</li></ol><blockquote><p>异步非阻塞。AIO底层是NIO的封装，同步转异步的方式。</p></blockquote><p>tcp的连接，数据读取和写入都不进行等待，通过回调的方式进行连接和读写。</p><h3 id="netty核心功能"><a href="#netty核心功能" class="headerlink" title="netty核心功能"></a>netty核心功能</h3><h3 id="netty的源码解析"><a href="#netty的源码解析" class="headerlink" title="netty的源码解析"></a>netty的源码解析</h3><h3 id="netty的高性能场景"><a href="#netty的高性能场景" class="headerlink" title="netty的高性能场景"></a>netty的高性能场景</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>面试知识点整理</title>
      <link href="/2022/04/05/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-2022/"/>
      <url>/2022/04/05/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-2022/</url>
      
        <content type="html"><![CDATA[<h1 id="2022-知识点梳理"><a href="#2022-知识点梳理" class="headerlink" title="2022-知识点梳理"></a>2022-知识点梳理</h1><h2 id="1、redis-keys执行了会怎么样"><a href="#1、redis-keys执行了会怎么样" class="headerlink" title="1、redis keys执行了会怎么样"></a>1、redis keys执行了会怎么样</h2><blockquote><p>1、当redis集群中的key数量不多时候没有什么大问题，但是随着key数量的增长，这样可能引起redis的客户端访问redis阻塞。</p><p>2、因为Redis是单线程的，执行任何命令时候其他命令会阻塞，而且由于key命令的时间复杂度是O(n)，redis服务端会匹配查找完所有的key才结束，比较耗时，如果在线上执行非常危险。</p><p>3、如果命令执行时间过长可能会触发服务器的安全策略，导致主从切换或者重新选主</p></blockquote><p><strong>可用scan命令替换keys命令，达到同样效果</strong></p><p>Scan命令在Redis的2.8版本爱是支持，相当于db中的分页查询,虽然也是O(n)的时间复杂度，但是数量进行制定，查询时间稳定</p><blockquote><p>Scan  0 match  test* count 100</p></blockquote><h2 id="2、redis缓存击穿-穿透"><a href="#2、redis缓存击穿-穿透" class="headerlink" title="2、redis缓存击穿 穿透"></a>2、redis缓存击穿 穿透</h2><p>前提条件：我们把db的热点数据放在了redis，并设置了超时时间，目前是较少DB的访问次数或者DB支持不了这么大压力。但是在查询时候有又进行了DB兜底的情况。</p><p><strong>缓存击穿</strong>：当缓存过期的一瞬间，大量请求达到redis，因为redis没有，所以一瞬间的所有流量都打到了DB</p><p><strong>缓存穿透</strong>:在缓存中查询不到数据，去数据库中查询数据也没查到，相当于无效请求到了BD，有大量这样请求都打到了DB。</p><p>缓存击穿的解决方案()：</p><ul><li>访问DB的位置加互斥锁</li><li>热点数据续时</li><li>异步同步，不用db兜底</li></ul><p>缓存击穿(前置拦截)：</p><ul><li>接口验证。非法请求降级等等。</li><li>缓存空值并进行超时时间控制</li><li>布隆过滤器–不存在请求先过滤</li></ul><h2 id="3、-zookeeper-eureka区别"><a href="#3、-zookeeper-eureka区别" class="headerlink" title="3、 zookeeper eureka区别"></a>3、 zookeeper eureka区别</h2><h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h3><ol><li>都可以作为注册中心</li></ol><h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><ol><li>Eureka 是AP模型(关注可用性)，ZK是CP模型(关注数据一致性)</li><li>Eureka支持负载均衡策略，ZK不支持</li><li>Eureka访问支持http协议，ZK不支持</li></ol><h2 id="4、dubbo-robin负载均衡"><a href="#4、dubbo-robin负载均衡" class="headerlink" title="4、dubbo robin负载均衡"></a>4、dubbo robin负载均衡</h2><h3 id="Dubbo负载均衡算法："><a href="#Dubbo负载均衡算法：" class="headerlink" title="Dubbo负载均衡算法："></a>Dubbo负载均衡算法：</h3><ol><li><p>RandomLoadBalance:权重随机算法，根据权重值进行随机负载</p><blockquote><p>假设有一组服务器A，B，C,对应的权重为[1,2,7]权重总和为10，[0,0]区间属于服务A,[1,2]属于B，[3,9]属于服务C。每次负载时候，通过随机生成一个范围在[0,9]之间的随机数，计算这个随机数在哪个区间，找到属于这个区间的服务就可以。</p></blockquote></li><li><p>LeastActiveLoadBalance：最少活跃数调用法</p><blockquote><p>活跃度调用越小，表明该服务提供者的效率越高，单位时间内可以处理更多的请求。</p><p>每个服务提供者对应一个活跃数的active，初始为0，每收到一个请求，活跃度+1，处理完成一个请求活跃度-1。活跃度可以代表该服务还未处理完成的请求。路由按照活跃度越小，优先级越高。</p></blockquote></li><li><p>ConsistentHashLoadBalance：hash一致性算法</p><blockquote><p> hash一致性算法，相同参数的请求总时发送到同一提供者。当某一台挂掉时，请求分摊到其他提供者。</p></blockquote></li><li><p>RoundRobiLoadBalance:加权轮训算法</p><blockquote><p>轮训是将每个请求轮流分配到每台服务器。假如说有三台服务器A,B,C。轮训 是一种状态负载均衡算法，实现简单，适用于每台服务器性能接近的场景。但是实际情况，每台服务器性能可能不一致，如果我们把流量均分，那么性能较差的机器会最先成为瓶颈。一次可以对轮训进行加权，实现调控每台机器的负载。经过加权后，每台服务器会进行请求的比例分配。比如A、B、C的权重为1:2:7,那么10次请求中1笔到A,2笔到B,7笔到C。</p></blockquote></li></ol><h2 id="5、-spring中的设计模式和用法示例"><a href="#5、-spring中的设计模式和用法示例" class="headerlink" title="5、 spring中的设计模式和用法示例"></a>5、 spring中的设计模式和用法示例</h2><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>BeanFactory是Spring中的容器工厂，我们可以通过这个方法获取不同的对象。<br>通过抽象类元素，形成beanDefinition—&gt;通过BeanDefinition</p><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>获取bean时候通过三级缓存实现。</p><h3 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h3><p>各种Wrapper</p><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>AOP底层就是动态代理</p><blockquote><p>具体可以讲讲Spring的bean实例化后的动态代理过程。PostProcessor</p></blockquote><h3 id="模板设计模式"><a href="#模板设计模式" class="headerlink" title="模板设计模式"></a>模板设计模式</h3><blockquote><p>具体可以参照不同的容器启动过程</p></blockquote><h3 id="策略设计模式"><a href="#策略设计模式" class="headerlink" title="策略设计模式"></a>策略设计模式</h3><h2 id="6、-数据库查询最近100万的数据"><a href="#6、-数据库查询最近100万的数据" class="headerlink" title="6、 数据库查询最近100万的数据"></a>6、 数据库查询最近100万的数据</h2><h2 id="7、mysql-acid怎么保证"><a href="#7、mysql-acid怎么保证" class="headerlink" title="7、mysql acid怎么保证"></a>7、mysql acid怎么保证</h2><ul><li>a(Atomicity):原子性,每一个事务是一个最小单位，事务内部的操作要么都成功，要么都失败。</li><li>c(Consistency):一致性，一致性是指事务执行前后，数据数据存于一中合法状态，这种状态是指语义上而不是语法上。合法状态是指满足预定的约束就叫做合法的状态。</li><li>i(Isolation):隔离性，隔离性是指多个事务并发执行，内部的操作和其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</li><li>d(Durability):持久性，持久性是指事务一旦提交，他怼数据库的改变是永久性的。接下来的其他操作或者故障都不应该对这个结果有任何影响。</li></ul><blockquote><ol><li><p>原子性通过InnoDB的undo log实现。unlog也叫做回归日志，是实现原子性的关键，当事务回滚时能够撤销已经成功执行的sql语句，undo log的实现原理是记录一条相反操作的操作。insert–&gt; delete。update(后) –&gt; update(前) ，delete –&gt; insert</p></li><li><p>一致性是数据库需要达到的目的。从数据库层面，通过原子性、隔离性、持久性来保证。从应用层面，通过代码判断数据库是否有效，然后决定回滚还是提交数据，也是一致性的</p></li><li><p>持久性是通过InnoDB 的redo log实现的。redo log也倨傲重做日志。当做数据修改时候，不仅需要在内存中操作，还会在redo log中记录这次操作。当事务提交时候，会将redo log 进行刷盘.当数据库宕机重启时候，会将redo log中内存恢复到数据库中，再根据undo log和binlog内容决定回归数据还是提交数据。</p></li><li><p>隔离性通过InnoDB的隔离界别和MVCC来实现。</p></li></ol></blockquote><h2 id="8、mysql-b-树和b树-avl树区别"><a href="#8、mysql-b-树和b树-avl树区别" class="headerlink" title="8、mysql b+树和b树 avl树区别"></a>8、mysql b+树和b树 avl树区别</h2><p>avl:平衡二叉树</p><h2 id="9、分布式锁redis宕机怎么办"><a href="#9、分布式锁redis宕机怎么办" class="headerlink" title="9、分布式锁redis宕机怎么办"></a>9、分布式锁redis宕机怎么办</h2><blockquote><p>首先确定业务场景是否强依赖这个分布式锁，如果是那么你的业务就进行不下去。</p><p>如果不是就要分具体情况。</p></blockquote><h2 id="10、dubbo-zookeeper集群宕机还能发现吗"><a href="#10、dubbo-zookeeper集群宕机还能发现吗" class="headerlink" title="10、dubbo zookeeper集群宕机还能发现吗"></a>10、dubbo zookeeper集群宕机还能发现吗</h2><p>问题不清晰。可以分为两个问题来回答</p><h3 id="dubbo集群通过zk作为注册中心，ZK集群宕机，dubbo客户端还能被发现么"><a href="#dubbo集群通过zk作为注册中心，ZK集群宕机，dubbo客户端还能被发现么" class="headerlink" title="dubbo集群通过zk作为注册中心，ZK集群宕机，dubbo客户端还能被发现么"></a>dubbo集群通过zk作为注册中心，ZK集群宕机，dubbo客户端还能被发现么</h3><blockquote><p>这个问题是是问，dubbo客户端缓存服务端节点的问题</p></blockquote><h3 id="dubbo-的注册中心zk集群宕机后还能重新启动么"><a href="#dubbo-的注册中心zk集群宕机后还能重新启动么" class="headerlink" title="dubbo 的注册中心zk集群宕机后还能重新启动么"></a>dubbo 的注册中心zk集群宕机后还能重新启动么</h3><blockquote><p>问的是zk的故障恢复，可以聊聊zk的zab协议。</p></blockquote><h2 id="11、springboot-properties-yaml读取顺序"><a href="#11、springboot-properties-yaml读取顺序" class="headerlink" title="11、springboot properties yaml读取顺序"></a>11、springboot properties yaml读取顺序</h2><h2 id="12、dubbo-properties-xml读取顺序"><a href="#12、dubbo-properties-xml读取顺序" class="headerlink" title="12、dubbo properties xml读取顺序"></a>12、dubbo properties xml读取顺序</h2><h2 id="13、Java类加载的过程"><a href="#13、Java类加载的过程" class="headerlink" title="13、Java类加载的过程"></a>13、Java类加载的过程</h2><ol><li>加载：把.class类加载到JVM虚拟中，并生成访问入口<ul><li>通过类的全限定名获取该类的二进制流</li><li>将改二进制流中的静态存储结构转换为方法区运行时数据结构</li><li>在内存中生成该类的Class对象，作为该类的数据访问入口</li></ul></li><li>验证：目的是确保加载进.class类是合法的，并且是不危害到JVM虚拟机的。验证有四种分别如下<ul><li>文件格式验证。是否符合Class文件的规范。CAFEBABE</li><li>元数据验证：对字节码描述信息进行语义分析，这个类是否有父类，是否继承了不能被继承的类等等</li><li>字节码验证：通过数据流和控制流分析，确定程序语义是否正确，主要针对方法体验证。如：方法中的类型转换是否正确，跳转执行是否正确。</li><li>符号引用验证：这个动作在后面的解析过程中发生，主要是为了确保解析动作能正确执行。</li></ul></li><li>准备：准备阶段是为类的静态变量分配内存并将其初始化为默认值，这些内存都将在方法区中进行分配。准备阶段不分配实例变量的内存，实例变量将会在对象实例化是随着对象一起分配在Java堆中。</li><li>解析：该阶段主要完成符号引用到直接引用的转换动作。解析动作不一定在初始化之前完成，也有可能在初始化之后完成。</li><li>初始化：初始化是类加载的最后一步，前面的类加载过程，除了在加载阶段用户应用程序能够通过自定义类加载器以外，其他动作完全由虚拟机主导和控制。到了初始化阶段，才开始真正执行类中定义的java程序代码。</li><li>使用</li><li>卸载</li></ol><h3 id="14、类加载器"><a href="#14、类加载器" class="headerlink" title="14、类加载器"></a>14、类加载器</h3><ol><li>启动类加载器：BootstrapClassLoader。加载jre/lib/下的类。</li><li>扩展类加载器：ExtensionsClassLoader：用来加载Java的扩展库。加载jre/ext/lib/下的类</li><li>系统类加载器：SystemClassLoader：加载用户的类路径classPath下的class</li><li>用户自定义类加载器：通过加成java.lang.ClassLoader类方式加载</li></ol><h3 id="15、-双亲委派"><a href="#15、-双亲委派" class="headerlink" title="15、 双亲委派"></a>15、 双亲委派</h3><p>当一个类加载器收到类加载请求时候，不会自己先去加载这个类，而是委派父类加载，一只到顶层的BootstrapClassLoader,如果还没有加载到，那么才由子类加载。</p><h3 id="16、数据一致性协议"><a href="#16、数据一致性协议" class="headerlink" title="16、数据一致性协议"></a>16、数据一致性协议</h3><p>分布式系统需要维护多个副本来进行容错，提供系统的可用性。要实现次目标，就必须要解决分布式系统的最核心问题：维护多个副本的一致性。</p><h4 id="zab协议"><a href="#zab协议" class="headerlink" title="zab协议"></a>zab协议</h4><h4 id="Raft协议"><a href="#Raft协议" class="headerlink" title="Raft协议"></a>Raft协议</h4><p>核心流程分为一下几步</p><ol><li><p>选主(Leader Election)</p><blockquote><p>每一个副本都可以分为三种角色。Loader、Follower、Candidate</p></blockquote><p>Candidate代表主节点故障，正在选举过程。</p></li><li><p>日志复制(Log Replication)</p></li><li><p>日志压缩(Log compaction)</p></li></ol><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>整理：HashMap是一个用于存储key-value键值对的集合，每个键值对我们通常称为为一个entry。这些键值对分散存储在一个数组中，这个数组就是HashMap的主干。</p><p>JDK1.8下的数据结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 省略其他代码</span></span><br><span class="line">      <span class="comment">/* ---------------- Fields -------------- */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line">  <span class="keyword">int</span> threshold;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">  <span class="comment">// 其他代码....</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>HashMap提供了两个核心的方法，put(key,value); get(key);</p></blockquote><h3 id="put-key-value"><a href="#put-key-value" class="headerlink" title="put(key,value)"></a>put(key,value)</h3><ol><li>通过hash(key)获取数组的位置。</li><li>如果位置为空，把key,value包装成Entry放入相应的位置</li><li>如果位置不为空，首先判断数据结构是树，那么把节点放入树种</li><li>看下目前的链表数目是否已经再放一个节点会进行树化，如果是就树化</li><li>否则直接放在这个链表上</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p>1、对key进行hash.</p><p>2、</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">      Node&lt;K,V&gt; e;</span><br><span class="line">      <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">      Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">      <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">          (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">              ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">              <span class="keyword">return</span> first;</span><br><span class="line">          <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                  <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">              <span class="keyword">do</span> &#123;</span><br><span class="line">                  <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                      ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                      <span class="keyword">return</span> e;</span><br><span class="line">              &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="17、线程的几种状态及其转换"><a href="#17、线程的几种状态及其转换" class="headerlink" title="17、线程的几种状态及其转换"></a>17、线程的几种状态及其转换</h2><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><ol><li>新建(new)</li><li>就绪(Runnable)</li><li>运行(Running)</li><li>阻塞(Blocked)</li><li>运行结束(Dead)<h3 id="JAVA-线程状态"><a href="#JAVA-线程状态" class="headerlink" title="JAVA 线程状态"></a>JAVA 线程状态</h3></li><li>NEW</li><li>RUNNABLE</li><li>BLOCKED</li><li>WAITING</li><li>TIME_WAITING</li><li>TERMINAL</li></ol><p>为什么Java的线程状态有六中状态</p><h3 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h3><blockquote><p>JSON WEB TOKEN</p><ul><li>header</li><li>reload</li><li>signature</li></ul></blockquote><h2 id="18、ConcurrentHash"><a href="#18、ConcurrentHash" class="headerlink" title="18、ConcurrentHash"></a>18、ConcurrentHash</h2><blockquote><p>线程安全的key-value集合类，相对于Hashtable</p></blockquote><p>使用了分段锁的设计原则。</p><h4 id="1、JDK1-7"><a href="#1、JDK1-7" class="headerlink" title="1、JDK1.7"></a>1、JDK1.7</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">ConcurrentMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="comment">// 通过分段式锁进行</span></span><br><span class="line"><span class="keyword">final</span> Segment&lt;K,V&gt;[] segments;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Segement实现可重入锁的实现</span></span><br><span class="line">      <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">      <span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">      <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        <span class="keyword">volatile</span> V value;</span><br><span class="line">        <span class="keyword">volatile</span> HashEntry&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">       Segment&lt;K,V&gt; s;</span><br><span class="line">  <span class="comment">// ConcurrentHashMap不支持key和value为null</span></span><br><span class="line">       <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">       <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">       <span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">       <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          <span class="comment">// nonvolatile; recheck</span></span><br><span class="line">            (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="keyword">null</span>) <span class="comment">//  in ensureSegment</span></span><br><span class="line">           s = ensureSegment(j);</span><br><span class="line">  <span class="comment">// 最终使用的是Segement的put方法</span></span><br><span class="line">       <span class="keyword">return</span> s.put(key, hash, value, <span class="keyword">false</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>Segement ReetrantLock 线程安全</p><h4 id="2、JDK1-8"><a href="#2、JDK1-8" class="headerlink" title="2、JDK1.8"></a>2、JDK1.8</h4><p>1.8 Synchonized+CAS乐观锁</p><p>CAS在查找替换，1.8锁头节点</p><h2 id="19、Mysql的MVCC"><a href="#19、Mysql的MVCC" class="headerlink" title="19、Mysql的MVCC"></a>19、Mysql的MVCC</h2><blockquote><p>MVCC(Multi-version concurrency control)又叫做多版本并发控制。代替锁来实现数据库的隔离性。</p></blockquote><p>在InnoDB的聚簇索引中，局促索引中有两个必要的隐藏列</p><ul><li>Trx_id：这个ID用来储存每次对该条举措索引记录进行修改的事务ID。递增。</li><li>roll_point：存储一个指针，这个指针这条聚簇索引的上一个版本的位置，通过他获取上一个版本的记录信息。</li></ul><p>MVCC只在数据库隔离界别为读已提交(RC)，可重复度读(RR)两种模式下生效。其他模式不兼容。</p><p>Mysql通过undo log实现了数据的多版本</p><h2 id="20、volatile作用"><a href="#20、volatile作用" class="headerlink" title="20、volatile作用"></a>20、volatile作用</h2><blockquote><p>valatile修饰的变量能够保证可见性，并防止指令重排序</p></blockquote><blockquote><p>synchonized修饰的代码块能够保证代码的原子性和可见性。</p></blockquote><p>valitile能解决</p><ul><li>保证了不同线程对该变量操作的内存可见性</li><li>禁止指令重排序</li><li>但是不能保证操作的原子性</li></ul><blockquote><p>Java虚拟机规范试图定义一种Java内存模型（JMM）,来屏蔽掉各种硬件和操作系统的内存访问差异，让Java程序在各种平台上都能达到一致的内存访问效果。简单来说，由于CPU执行指令的速度是很快的，但是内存访问的速度就慢了很多，相差的不是一个数量级，所以搞处理器的那群大佬们又在CPU里加了好几层高速缓存。</p></blockquote><p><img src="/Users/admin/Documents/%E4%B8%AA%E4%BA%BA%E6%95%B4%E7%90%86/%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/resource/image-20220316145443987.png" alt="image-20220316145443987"></p><p>vaitile能解决并发问题中的有序性和可见性，按时</p><h2 id="21、Redis的rehash内部实现"><a href="#21、Redis的rehash内部实现" class="headerlink" title="21、Redis的rehash内部实现"></a>21、Redis的rehash内部实现</h2><p>在redis中，键值对(key-value pair)，字典底层是通过哈希列来实现的，通过哈希表中的节点保存字段中的键值对。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* hash表结构定义 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span> </span><br><span class="line">    dictEntry **table;   <span class="comment">// 哈希表数组</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;  <span class="comment">// 哈希表的大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask; <span class="comment">// 哈希表大小掩码</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;  <span class="comment">// 哈希表现有节点的数量</span></span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 哈希桶 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span> </span><br><span class="line">    <span class="keyword">void</span> *key;     <span class="comment">// 键定义</span></span><br><span class="line">    <span class="comment">// 值定义</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span> </span><br><span class="line">        <span class="keyword">void</span> *val;    <span class="comment">// 自定义类型</span></span><br><span class="line">        <span class="keyword">uint64_t</span> u64; <span class="comment">// 无符号整形</span></span><br><span class="line">        <span class="keyword">int64_t</span> s64;  <span class="comment">// 有符号整形</span></span><br><span class="line">        <span class="keyword">double</span> d;     <span class="comment">// 浮点型</span></span><br><span class="line">    &#125; v;     </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span>  <span class="comment">//指向下一个哈希表节点</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure><p>Redis 哈希表中的table数组存放着哈希桶结构（dictEntry），里面就是Redis的键值对；类似Java实现的HashMap，Redis的dictEntry也是通过链表（next指针）方式来解决hash冲突：</p><blockquote><p>Redis Dict 中定义了两张哈希表，是为了后续字典的扩展作Rehash之用：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 字典结构定义 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span> </span><br><span class="line">    dictType *type;  <span class="comment">// 字典类型</span></span><br><span class="line">    <span class="keyword">void</span> *privdata;  <span class="comment">// 私有数据</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];    <span class="comment">// 哈希表[两个]</span></span><br><span class="line">    <span class="keyword">long</span> rehashidx;   <span class="comment">// 记录rehash 进度的标志，值为-1表示rehash未进行</span></span><br><span class="line">    <span class="keyword">int</span> iterators;   <span class="comment">//  当前正在迭代的迭代器数</span></span><br><span class="line">&#125; dict;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>![image-20220316144721437](/Users/admin/Library/Application Support/typora-user-images/image-20220316144721437.png)</p><p><strong>总结一下：</strong></p><ul><li>在Cluster模式下，一个Redis实例对应一个RedisDB(db0);</li><li>一个RedisDB对应一个Dict;</li><li>一个Dict对应2个Dictht，正常情况只用到ht[0]；ht[1] 在Rehash时使用。</li></ul><h2 id="22、AQS"><a href="#22、AQS" class="headerlink" title="22、AQS"></a>22、AQS</h2><blockquote><p>AbstractQueueSynconizer,中文名为抽象的队列同步器，在AQS内部有一个资源访问的状态status和一个FIFO的双向队列，用来保存等待共享资源的变量的等待线程。基本上juc包下的并发类都是基于AQS来实现的，比如ReentratLock,Semaphore,CountDownLatch,CyclicBarrier等</p></blockquote><h3 id="1、semaphore"><a href="#1、semaphore" class="headerlink" title="1、semaphore"></a>1、semaphore</h3><blockquote><p>信号量，juc包下的工具类，用来公职同事访问特定资源的线程数。，内部内置了Syn锁，基于AQS实现。</p><p>核心方法有acquire和release();</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        Semaphore semaphore;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(Semaphore semaphore, String tname)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(tname);</span><br><span class="line">            <span class="keyword">this</span>.semaphore = semaphore;</span><br><span class="line">            <span class="comment">//this.setName(tname);</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//semaphore.acquireUninterruptibly();</span></span><br><span class="line">                semaphore.acquire();<span class="comment">//获取公共资源</span></span><br><span class="line"></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:aquire() at time:&quot;</span> + System.currentTimeMillis());</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">                semaphore.release();</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*if(semaphore.tryAcquire(500,TimeUnit.MILLISECONDS))&#123;</span></span><br><span class="line"><span class="comment">                    System.out.println(Thread.currentThread().getName()+&quot;:aquire() at time:&quot;+System.currentTimeMillis());</span></span><br><span class="line"><span class="comment">                    Thread.sleep(5000);</span></span><br><span class="line"><span class="comment">                    semaphore.release();//释放公共资源</span></span><br><span class="line"><span class="comment">                &#125;else&#123;</span></span><br><span class="line"><span class="comment">                    fallback();</span></span><br><span class="line"><span class="comment">                &#125;*/</span></span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>Acquire()可以相应中断，抛出异常。</p><h3 id="2、CountDownLatch"><a href="#2、CountDownLatch" class="headerlink" title="2、CountDownLatch"></a>2、CountDownLatch</h3><blockquote><p>ConntDownLatch是JDK提供的同步工具，可以让一个或者多个线程等待，一致等待其他线程完成一组操作。</p></blockquote><p>countDown()。计数器减1.当调用await()方法时，计数器加1.当计数器大于0时候线程会被阻塞，一致到计数器</p><p>核心方法，countDown(),await();</p><h3 id="3、CyclicBarrier"><a href="#3、CyclicBarrier" class="headerlink" title="3、CyclicBarrier"></a>3、CyclicBarrier</h3><blockquote><p>一个同步辅助，他允许一组线程的所有等待同时达到共同屏障点</p></blockquote><p>核心方法awate()</p>]]></content>
      
      
      <categories>
          
          <category> 面试知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/04/05/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/Spring%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"/>
      <url>/2022/04/05/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/Spring%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring知识点"><a href="#Spring知识点" class="headerlink" title="Spring知识点"></a>Spring知识点</h1><h2 id="Spring-底层核心原理解析"><a href="#Spring-底层核心原理解析" class="headerlink" title="Spring 底层核心原理解析"></a>Spring 底层核心原理解析</h2><h3 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationContext</span> <span class="keyword">extends</span> <span class="title">EnvironmentCapable</span>, <span class="title">ListableBeanFactory</span>, <span class="title">HierarchicalBeanFactory</span>,</span></span><br><span class="line"><span class="class"><span class="title">MessageSource</span>, <span class="title">ApplicationEventPublisher</span>, <span class="title">ResourcePatternResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the unique id of this application context.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the unique id of the context, or &#123;<span class="doctag">@code</span> null&#125; if none</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">String <span class="title">getId</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return a name for the deployed application that this context belongs to.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a name for the deployed application, or the empty String by default</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">String <span class="title">getApplicationName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return a friendly name for this context.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a display name for this context (never &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">String <span class="title">getDisplayName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the timestamp when this context was first loaded.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the timestamp (ms) when this context was first loaded</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getStartupDate</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the parent context, or &#123;<span class="doctag">@code</span> null&#125; if there is no parent</span></span><br><span class="line"><span class="comment"> * and this is the root of the context hierarchy.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the parent context, or &#123;<span class="doctag">@code</span> null&#125; if there is no parent</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">ApplicationContext <span class="title">getParent</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Expose AutowireCapableBeanFactory functionality for this context.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This is not typically used by application code, except for the purpose of</span></span><br><span class="line"><span class="comment"> * initializing bean instances that live outside of the application context,</span></span><br><span class="line"><span class="comment"> * applying the Spring bean lifecycle (fully or partly) to them.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Alternatively, the internal BeanFactory exposed by the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> ConfigurableApplicationContext&#125; interface offers access to the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> AutowireCapableBeanFactory&#125; interface too. The present method mainly</span></span><br><span class="line"><span class="comment"> * serves as a convenient, specific facility on the ApplicationContext interface.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;<span class="doctag">NOTE:</span> As of 4.2, this method will consistently throw IllegalStateException</span></span><br><span class="line"><span class="comment"> * after the application context has been closed.&lt;/b&gt; In current Spring Framework</span></span><br><span class="line"><span class="comment"> * versions, only refreshable application contexts behave that way; as of 4.2,</span></span><br><span class="line"><span class="comment"> * all application context implementations will be required to comply.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the AutowireCapableBeanFactory for this context</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalStateException if the context does not support the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> AutowireCapableBeanFactory&#125; interface, or does not hold an</span></span><br><span class="line"><span class="comment"> * autowire-capable bean factory yet (e.g. if &#123;<span class="doctag">@code</span> refresh()&#125; has</span></span><br><span class="line"><span class="comment"> * never been called), or if the context has been closed already</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ConfigurableApplicationContext#refresh()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ConfigurableApplicationContext#getBeanFactory()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">AutowireCapableBeanFactory <span class="title">getAutowireCapableBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> IllegalStateException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>ApplicationContext我们通常称之为Spring的上下文，基本上Spring的核心操作都能通过这个上线文获取。</p></blockquote><h2 id="Spring的bean"><a href="#Spring的bean" class="headerlink" title="Spring的bean"></a>Spring的bean</h2><p>前提条件</p><p>Bean的创建的生命周期</p><p>xxxService –&gt;容器初始化(产生一个对象)–&gt;依赖注入(属性赋值)-&gt;初始化前-&gt;初始化–&gt;初始化后-&gt;Spring的bean</p><p>Spring上线文的初始化</p><ul><li>扫描bean</li><li>创建非懒加载的单例bean</li></ul><h3 id="BeanDefinition"><a href="#BeanDefinition" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h3><ol><li>AbstractBeanDefinition</li><li>AnnotatedBeanDefinition</li><li>GenericBeanDefinition</li><li>AnnotatedGenericBeanDefinition</li><li>ScannerGenericBeanDefinition</li></ol><h3 id="BeanDefinitionReader"><a href="#BeanDefinitionReader" class="headerlink" title="BeanDefinitionReader"></a>BeanDefinitionReader</h3><ol><li>AnnotatedBeanDefinitionReader：读取注解的reader,把一个普通类转换为一个Spring容器的Bean定义(BeanDefinition)</li><li>XmlBeanFefinitionReader：xml定义的读取器，获取</li><li>ClassPathBeanDefinitionScanner：扫描器，通过输入的路径进行扫描</li></ol><h3 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h3><p>DefautListableBeanFactory</p><h3 id="ApplicationContext-1"><a href="#ApplicationContext-1" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h3><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>Property</p><p>ConditionConverter</p><p>SimpleTypeConverter</p><h3 id="比较器"><a href="#比较器" class="headerlink" title="比较器"></a>比较器</h3><p>OrderComparator</p><h3 id="MetadataReader"><a href="#MetadataReader" class="headerlink" title="MetadataReader"></a>MetadataReader</h3><p>读取一个类的元数据，解析类。</p><h3 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h3><h4 id="ConfigirableListableBeanFactory"><a href="#ConfigirableListableBeanFactory" class="headerlink" title="ConfigirableListableBeanFactory"></a>ConfigirableListableBeanFactory</h4><p>Configurable  可配置</p><p>Listable 可列举</p><blockquote><p>类型转换器</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beanFactory.addPropertyEditorRegistrar(<span class="keyword">new</span> ResourceEditorRegistrar(<span class="keyword">this</span>, getEnvironment()));</span><br></pre></td></tr></table></figure><blockquote><p>默认beanPostProcesssor</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationContextAwareProcessor(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(<span class="keyword">this</span>));</span><br><span class="line">## 通过环境变量</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>忽略接口</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">beanFactory.ignoreDependencyInterface(EnvironmentAware.class);</span><br><span class="line">beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);</span><br><span class="line">beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);</span><br><span class="line">beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);</span><br><span class="line">beanFactory.ignoreDependencyInterface(MessageSourceAware.class);</span><br><span class="line">beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);</span><br><span class="line">beanFactory.ignoreDependencyInterface(ApplicationStartupAware.class);</span><br></pre></td></tr></table></figure><blockquote><p>解析实现</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class="line">beanFactory.registerResolvableDependency(ResourceLoader.class, <span class="keyword">this</span>);</span><br><span class="line">beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, <span class="keyword">this</span>);</span><br><span class="line">beanFactory.registerResolvableDependency(ApplicationContext.class, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><h4 id="HierarchicalMessageSource"><a href="#HierarchicalMessageSource" class="headerlink" title="HierarchicalMessageSource"></a>HierarchicalMessageSource</h4><h3 id="Spring-bean的扫描过程"><a href="#Spring-bean的扫描过程" class="headerlink" title="Spring bean的扫描过程"></a>Spring bean的扫描过程</h3><h3 id="Spring-bean初始化"><a href="#Spring-bean初始化" class="headerlink" title="Spring bean初始化"></a>Spring bean初始化</h3><ol><li>实例化前: InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation() 。有就直接返回，给用户提供了自己实例化bean的机会(如果有的话)</li><li></li></ol><p>@Resource通过CommonAnnotationBeanPostProcessor</p><h3 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h3><ol><li>实例化AService</li><li>填充BService属性 –&gt;去单例池找BService–&gt;没有则创建BService<ul><li>实例化BService–&gt;得到了对象</li><li>填充AService属性–&gt;去单例池找AService-&gt;没有则创建AService。。。(也找不到)</li></ul></li><li>填充其他属性 –&gt;</li><li>初始化前、初始化</li><li>初始化后</li><li>放入单例池</li></ol><p><strong>三级缓存</strong></p><p>singletonObjects：单例池。完成了完整生命周期的单例bean.</p><p>earlySingletonObjects：只进行了实例化，还没有进行数据赋值的对象。解决循环依赖，解决单例的情况</p><p>singletonFacories：出现循环信赖时候，创建bean的lambda表达式。</p><p>earlyProxyObjects：因为循环信赖提前进行了AOP的对象池</p><p>Spring循环依赖只能解决单例的情况，如果是原型的情况下是支持不了的</p><p>构造方法的循环依赖，情况直接用也是不行的，需要用@Lazy</p><p>BeanProcesson和advise</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java中的各种O</title>
      <link href="/2022/04/05/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/0%E3%80%81Java%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8DO/"/>
      <url>/2022/04/05/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/0%E3%80%81Java%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8DO/</url>
      
        <content type="html"><![CDATA[<h1 id="0、Java中的各种O"><a href="#0、Java中的各种O" class="headerlink" title="0、Java中的各种O"></a>0、Java中的各种O</h1><h2 id="1、POJO"><a href="#1、POJO" class="headerlink" title="1、POJO"></a>1、POJO</h2><blockquote><p>Plain Ordinary Java Object 简单Java对象。</p></blockquote><p>简单的Java对象，实际上就是一个普通的JavaBeans。使用POJO是为了避免和EJB混淆起来，而且简称比较直接。其中有一些属性及其getter/setter方法的类，没有业务逻辑。有时候可以作为VO或者DTO来使用。</p><h2 id="2、PO"><a href="#2、PO" class="headerlink" title="2、PO"></a>2、PO</h2><blockquote><p>Presistant Object 持久化对象</p></blockquote><p>它们是一组属性和属性的setter/getter方法组成。基于O/R映射出现的概念。属性通常对应数据库/数据模型，并且本身也就可以有一些业务逻辑的处理，可以看做是<strong>数据库表映射的对象</strong>。</p><h2 id="3、BO"><a href="#3、BO" class="headerlink" title="3、BO"></a>3、BO</h2><blockquote><p>Business Object 业务对象</p></blockquote><p>业务对象就是将业务抽象逻辑封装成的对象。这个对象可以包含很多种其他对象，比如DAO作为数据库访问，或者DTO作为业务数据的传递，也可以持有很多的POJO对象。</p><h2 id="4、DO"><a href="#4、DO" class="headerlink" title="4、DO"></a>4、DO</h2><blockquote><p>Domain Object 领域对象</p></blockquote><p>就是从显示世界中抽象出来的有形或者无形的业务实体</p><h2 id="5、DAO"><a href="#5、DAO" class="headerlink" title="5、DAO"></a>5、DAO</h2><blockquote><p>Data Access Obejct 数据访问对象</p></blockquote><p>一般指数据库的访问对象。相当于一个数据的访问接口。加在业务层和数据层中间。通过调用DAO的方法，业务层可以获取一个或者多个PO数据。</p><h2 id="6、-DTO"><a href="#6、-DTO" class="headerlink" title="6、 DTO"></a>6、 DTO</h2><blockquote><p>Data Transfer Object 数据传输对象</p></blockquote><p>一般只用于客户端和服务端，展示层和服务层，应用间为传递数据而封装的对象。内部可以包含很多VO和POJO</p><h2 id="7、-VO"><a href="#7、-VO" class="headerlink" title="7、 VO"></a>7、 VO</h2><blockquote><p>Value Object 值对象</p></blockquote><p>通常用于业务层之间的数据传递和PO一样也仅仅包含数据而已。但应对抽象的业务对象，可以和表对应，也可以不，这个需要根据业务需求，用new 关键字创建，由GC回收。</p>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>企业开发规范和技巧</title>
      <link href="/2022/04/05/%E5%BC%80%E5%8F%91%E5%B7%A5%E4%BD%9C/%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83%E5%92%8C%E6%8A%80%E5%B7%A7/"/>
      <url>/2022/04/05/%E5%BC%80%E5%8F%91%E5%B7%A5%E4%BD%9C/%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83%E5%92%8C%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="开发规范"><a href="#开发规范" class="headerlink" title="开发规范"></a>开发规范</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>​        没有看过<a href="https://developer.aliyun.com/topic/java20?utm_content=g_1000163107">阿里开发规范</a>的同学可以先阅读一遍规范里面的内容，《Java 开发手册》是阿里巴巴集团技术团队的集体智慧结晶和经验总结，经历了多次大规模一 线实战的检验及不断完善，公开到业界后，众多社区开发者踊跃参与，共同打磨完善，系统化地整理 成册。为提高软件的最终交付质量，五花八门的错误码人为地 增加排查问题的难度;数据库的表结构和索引设计缺陷带来的系统架构缺陷或性能风险;工程结构混 乱导致后续项目维护艰难;没有鉴权的漏洞代码易被黑客攻击等等，制定一套开发规范出来还是很有必要的，对于增强代码的可读性，提高项目的维护成本，提高问题的排查速度，都会有重要的作用。</p><h3 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h3>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring技术笔记</title>
      <link href="/2022/04/05/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Spring/"/>
      <url>/2022/04/05/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Spring/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring底层核心原理解析"><a href="#Spring底层核心原理解析" class="headerlink" title="Spring底层核心原理解析"></a>Spring底层核心原理解析</h2><h3 id="下载Spring源码"><a href="#下载Spring源码" class="headerlink" title="下载Spring源码"></a>下载Spring源码</h3><p>git clone的地址为：<a href="https://gitee.com/archguide/spring-framework-5.3.10.git">https://gitee.com/archguide/spring-framework-5.3.10.git</a></p><h3 id="Bean的创建过程"><a href="#Bean的创建过程" class="headerlink" title="Bean的创建过程"></a>Bean的创建过程</h3><p><strong>那么Spring到底是如何来创建一个Bean的呢，这个就是Bean创建的生命周期，大致过程如下：</strong></p><ol><li>利用该类的构造方法来实例化得到一个对象（但是如何一个类中有多个构造方法，Spring则会进行选择，这个叫做推断构造方法）</li><li>得到一个对象后，Spring会判断该对象中是否存在被@Autowired注解了的属性，把这些属性找出来并由Spring进行赋值（依赖注入）</li><li>依赖注入后，Spring会判断该对象是否实现了BeanNameAware接口、BeanClassLoaderAware接口、BeanFactoryAware接口，如果实现了，就表示当前对象必须实现该接口中所定义的setBeanName()、setBeanClassLoader()、setBeanFactory()方法，那Spring就会调用这些方法并传入相应的参数（Aware回调）</li><li>Aware回调后，Spring会判断该对象中是否存在某个方法被@PostConstruct注解了，如果存在，Spring会调用当前对象的此方法（初始化前）</li><li>紧接着，Spring会判断该对象是否实现了InitializingBean接口，如果实现了，就表示当前对象必须实现该接口中的afterPropertiesSet()方法，那Spring就会调用当前对象中的afterPropertiesSet()方法（初始化）</li><li>最后，Spring会判断当前对象需不需要进行AOP，如果不需要那么Bean就创建完了，如果需要进行AOP，则会进行动态代理并生成一个代理对象做为Bean（初始化后）</li></ol><p><strong>通过最后一步，我们可以发现，当Spring根据UserService类来创建一个Bean时：</strong></p><ol><li>如果不用进行AOP，那么Bean就是UserService类的构造方法所得到的对象。</li><li>如果需要进行AOP，那么Bean就是UserService的代理类所实例化得到的对象，而不是UserService本身所得到的对象。</li></ol><p><strong>Bean对象创建出来后：</strong></p><ol><li>如果当前Bean是单例Bean，那么会把该Bean对象存入一个Map&lt;String,Object&gt;，Map的key为beanName，value为Bean对象。这样下次getBean时就可以直接从Map中拿到对应的Bean对象了。（实际上，在Spring源码中，这个Map就是单例池）</li><li>如果当前Bean是原型Bean，那么后续没有其他动作，不会存入一个Map，下次getBean时会再次执行上述创建过程，得到一个新的Bean对象。</li></ol><h3 id="推断构造方法"><a href="#推断构造方法" class="headerlink" title="推断构造方法"></a>推断构造方法</h3><p>Spring在基于某个类生成Bean的过程中，需要利用该类的构造方法来实例化得到一个对象，但是如果一个类存在多个构造方法，Spring会使用哪个呢？ Spring的判断逻辑如下：</p><ol><li>如果一个类只存在一个构造方法，不管该构造方法是无参构造方法，还是有参构造方法，Spring都会用这个构造方法</li><li>如果一个类存在多个构造方法<br>a. 这些构造方法中，存在一个无参的构造方法，那么Spring就会用这个无参的构造方法<br>b. 这些构造方法中，不存在一个无参的构造方法，那么Spring就会报错</li></ol><p><strong>Spring的设计思想是这样的：</strong></p><ol><li><p>如果一个类只有一个构造方法，那么没得选择，只能用这个构造方法</p></li><li><p>如果一个类存在多个构造方法，Spring不知道如何选择，就会看是否有无参的构造方法，因为无参构造方法本身表示了一种默认的意义</p></li><li><p>不过如果某个构造方法上加了@Autowired注解，那就表示程序员告诉Spring就用这个加了注解的方法，那Spring就会用这个加了@Autowired注解构造方法了</p></li></ol><p>需要重视的是，如果Spring选择了一个有参的构造方法，Spring在调用这个有参构造方法时，需要传入参数，那这个参数是怎么来的呢？ Spring会根据入参的类型和入参的名字去Spring中找Bean对象（以单例Bean为例，Spring会从单例池那个Map中去找）：</p><ol><li>先根据入参类型找，如果只找到一个，那就直接用来作为入参</li><li>如果根据类型找到多个，则再根据入参名字来确定唯一一个</li><li>最终如果没有找到，则会报错，无法创建当前Bean对象</li></ol><p>确定用哪个构造方法，确定入参的Bean对象，这个过程就叫做推断构造方法。 </p><h3 id="AOP大致流程"><a href="#AOP大致流程" class="headerlink" title="AOP大致流程"></a>AOP大致流程</h3><p>AOP就是进行动态代理，在创建一个Bean的过程中，Spring在最后一步会去判断当前正在创建的这个Bean是不是需要进行AOP，如果需要则会进行动态代理。 如何判断当前Bean对象需不需要进行AOP:</p><ol><li>找出所有的切面Bean</li><li>遍历切面中的每个方法，看是否写了@Before、@After等注解</li><li>如果写了，则判断所对应的Pointcut是否和当前Bean对象的类是否匹配</li><li>如果匹配则表示当前Bean对象有匹配的的Pointcut，表示需要进行AOP</li></ol><p><strong>利用cglib进行AOP的大致流程：</strong></p><ol><li>生成代理类UserServiceProxy，代理类继承UserService</li><li>代理类中重写了父类的方法，比如UserService中的test()方法</li><li>代理类中还会有一个target属性，该属性的值为被代理对象（也就是通过UserService类推断构造方法实例化出来的对象，进行了依赖注入、初始化等步骤的对象）</li><li>代理类中的test()方法被执行时的逻辑如下：<br>a. 执行切面逻辑（@Before）<br>b. 调用target.test()</li></ol><p>当我们从Spring容器得到UserService的Bean对象时，拿到的就是UserServiceProxy所生成的对象，也就是代理对象。<br>UserService代理对象.test()—&gt;执行切面逻辑—&gt;target.test()，注意target对象不是代理对象，而是被代理对象。 </p><h3 id="Spring事务"><a href="#Spring事务" class="headerlink" title="Spring事务"></a>Spring事务</h3><p>当我们在某个方法上加了@Transactional注解后，就表示该方法在调用时会开启Spring事务，而这个方法所在的类所对应的Bean对象会是该类的代理对象。 Spring事务的代理对象执行某个方法时的步骤：</p><ol><li>判断当前执行的方法是否存在@Transactional注解</li><li>如果存在，则利用事务管理器（TransactionMananger）新建一个数据库连接</li><li>修改数据库连接的autocommit为false</li><li>执行target.test()，执行程序员所写的业务逻辑代码，也就是执行sql</li><li>执行完了之后如果没有出现异常，则提交，否则回滚</li></ol><p>Spring事务是否会失效的判断标准：某个加了@Transactional注解的方法被调用时，要判断到底是不是直接被代理对象调用的，如果是则事务会生效，如果不是则失效。</p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ消息中间件技术笔记</title>
      <link href="/2022/04/05/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/RabbitMQ/"/>
      <url>/2022/04/05/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/RabbitMQ/</url>
      
        <content type="html"><![CDATA[<h2 id="MQ相关概念"><a href="#MQ相关概念" class="headerlink" title="MQ相关概念"></a>MQ相关概念</h2><h3 id="什么是MQ"><a href="#什么是MQ" class="headerlink" title="什么是MQ"></a>什么是MQ</h3><p>MQ(message queue)，从字面意思上看，本质是个队列，FIFO 先入先出，只不过队列中存放的内容是message 而已，还是一种跨进程的通信机制，用于上下游传递消息。在互联网架构中，MQ 是一种非常常见的上下游“逻辑解耦+物理解耦”的消息通信服务。使用了 MQ之后，消息发送上游只需要依赖 MQ，不用依赖其他服务。</p><h3 id="为什么要用MQ"><a href="#为什么要用MQ" class="headerlink" title="为什么要用MQ"></a>为什么要用MQ</h3><ol><li><p>流量消峰</p><p>举个例子，如果订单系统最多能处理一万次订单，这个处理能力应付正常时段的下单时绰绰有余，正常时段我们下单一秒后就能返回结果。但是在高峰期，如果有两万次下单操作系统是处理不了的，只能限制订单超过一万后不允许用户下单。使用消息队列做缓冲，我们可以取消这个限制，把一秒内下的订单分散成一段时间来处理，这时有些用户可能在下单十几秒后才能收到下单成功的操作，但是比不能下单的体验要好。</p><p><img src="/images/studyNote/rabbitMQ/20210903_142709.png"></p></li><li><p>应用解耦</p><p>以电商应用为例，应用中有订单系统、库存系统、物流系统、支付系统。用户创建订单后，如果耦合调用库存系统、物流系统、支付系统，任何一个子系统出了故障，都会造成下单操作异常。当转变成基于消息队列的方式后，系统间调用的问题会减少很多，比如物流系统因为发生故障，需要几分钟来修复。在这几分钟的时间里，物流系统要处理的内存被缓存在消息队列中，用户的下单操作可以正常完成。当物流系统恢复后，继续处理订单信息即可，中单用户感受不到物流系统的故障，提升系统的可用性。</p><p><img src="/images/studyNote/rabbitMQ/20210903_142118.png"></p><p><img src="/images/studyNote/rabbitMQ/20210903_142315.png"></p></li><li><p>异步提速</p><p>有些服务间调用是异步的，例如 A 调用 B，B 需要花费很长时间执行，但是 A 需要知道 B 什么时候可以执行完，以前一般有两种方式，A 过一段时间去调用 B 的查询 api 查询。或者 A 提供一个 callback api，B 执行完之后调用 api 通知 A 服务。这两种方式都不是很优雅，使用消息总线，可以很方便解决这个问题，A 调用 B 服务后，只需要监听 B 处理完成的消息，当 B 处理完成后，会发送一条消息给 MQ，MQ 会将此消息转发给 A 服务。这样 A 服务既不用循环调用 B 的查询 api，也不用提供 callback api。同样 B 服务也不用做这些操作。A 服务还能及时的得到异步处理成功的消息。</p><p><img src="/images/studyNote/rabbitMQ/20210903_142435.png"></p><p><img src="/images/studyNote/rabbitMQ/20210903_142525.png"></p></li></ol><h3 id="MQ的分类"><a href="#MQ的分类" class="headerlink" title="MQ的分类"></a>MQ的分类</h3><p><img src="/images/studyNote/rabbitMQ/20210903_142909.png"></p><h4 id="ActiveMQ"><a href="#ActiveMQ" class="headerlink" title="ActiveMQ"></a>ActiveMQ</h4><p><strong>优点：</strong>单机吞吐量万级，时效性 ms 级，可用性高，基于主从架构实现高可用性，消息可靠性较低的概率丢失数据。</p><p><strong>缺点：</strong>官方社区现在对 ActiveMQ 5.x 维护越来越少，高吞吐量场景较少使用。</p><h4 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h4><p>大数据的杀手锏，谈到大数据领域内的消息传输，则绕不开 Kafka，这款为大数据而生的消息中间件，以其<strong>百万级 TPS 的吞吐量</strong>名声大噪，迅速成为大数据领域的宠儿，在数据采集、传输、存储的过程中发挥着举足轻重的作用。目前已经被 LinkedIn，Uber, Twitter, Netflix 等大公司所采纳。</p><p><strong>优点：</strong>性能卓越，单机写入 TPS 约在<strong>百万条/秒</strong>，最大的优点，就是吞吐量高。时效性 ms 级可用性非常高，kafka 是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用,消费者采用 Pull 方式获取消息, 消息有序, 通过控制能够保证所有消息被消费且仅被消费一次;有优秀的第三方Kafka Web 管理界面 Kafka-Manager；在日志领域比较成熟，被多家公司和多个开源项目使用；功能支持：功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用。</p><p><strong>缺点：</strong>Kafka 单机超过 64 个队列/分区，Load 会发生明显的飙高现象，队列越多，load 越高，发送消息响应时间变长，使用短轮询方式，实时性取决于轮询间隔时间，消费失败不支持重试；支持消息顺序，但是一台代理宕机后，就会产生消息乱序，社区更新较慢。</p><h4 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h4><p>RocketMQ 出自阿里巴巴的开源产品，用 Java 语言实现，在设计时参考了 Kafka，并做出了自己的一些改进。被阿里巴巴广泛应用在订单，交易，充值，流计算，消息推送，日志流式处理，binglog 分发等场景。</p><p><strong>优点：</strong>单机吞吐量十万级,可用性非常高，分布式架构,消息可以做到 0 丢失,MQ 功能较为完善，还是分布式的，扩展性好,支持 10 亿级别的消息堆积，不会因为堆积导致性能下降,源码是 java 我们可以自己阅读源码，定制自己公司的 MQ。</p><p><strong>缺点：</strong>支持的客户端语言不多，目前是 java 及 c++，其中 c++不成熟；社区活跃度一般,没有在 MQ核心中去实现 JMS 等接口,有些系统要迁移需要修改大量代码。</p><h4 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h4><p>2007 年发布，是一个在 AMQP(高级消息队列协议)基础上完成的，可复用的企业消息系统，是当前最主流的消息中间件之一。</p><p><strong>优点：</strong>由于 erlang 语言的高并发特性，性能较好；吞吐量到万级，MQ 功能比较完备,健壮、稳定、易用、跨平台、支持多种语言 如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持 AJAX 文档齐全；开源提供的管理界面非常棒，用起来很好用,社区活跃度高；更新频率相当高。</p><p><strong>缺点：</strong>商业版需要收费,学习成本较高。</p><h3 id="MQ的选择"><a href="#MQ的选择" class="headerlink" title="MQ的选择"></a>MQ的选择</h3><h4 id="Kafka-1"><a href="#Kafka-1" class="headerlink" title="Kafka"></a>Kafka</h4><p>Kafka 主要特点是基于 Pull 的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于日志收集和传输，适合产生大量数据的互联网服务的数据收集业务。大型公司建议可以选用，如果有日志采集功能，肯定是首选 kafka 了。</p><h4 id="RocketMQ-1"><a href="#RocketMQ-1" class="headerlink" title="RocketMQ"></a>RocketMQ</h4><p>天生为金融互联网领域而生，对于可靠性要求很高的场景，尤其是电商里面的订单扣款，以及业务削峰，在大量交易涌入时，后端可能无法及时处理的情况。RoketMQ 在稳定性上可能更值得信赖，这些业务场景在阿里双 11 已经经历了多次考验，如果你的业务有上述并发场景，建议可以选择 RocketMQ。</p><h4 id="RabbitMQ-1"><a href="#RabbitMQ-1" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h4><p>结合 erlang 语言本身的并发优势，性能好时效性微秒级，社区活跃度也比较高，管理界面用起来十分方便，如果你的数据量没有那么大，中小型公司优先选择功能比较完备的 RabbitMQ。</p><h2 id="RabbitMQ简介"><a href="#RabbitMQ简介" class="headerlink" title="RabbitMQ简介"></a>RabbitMQ简介</h2><p>2007年，Rabbit 技术公司基于 AMQP 标准开发的 RabbitMQ 1.0 发布。RabbitMQ 采用 Erlang 语言开发。Erlang 语言由 Ericson 设计，专门为开发高并发和分布式系统的一种语言，在电信领域使用广泛。</p><h3 id="RabbitMQ四大核心概念"><a href="#RabbitMQ四大核心概念" class="headerlink" title="RabbitMQ四大核心概念"></a>RabbitMQ四大核心概念</h3><ul><li><p>生产者<br>产生数据发送消息的程序是生产者</p></li><li><p>交换机<br>交换机是 RabbitMQ 非常重要的一个部件，一方面它接收来自生产者的消息，另一方面它将消息推送到队列中。交换机必须确切知道如何处理它接收到的消息，是将这些消息推送到特定队列还是推送到多个队列，亦或者是把消息丢弃，这个得有交换机类型决定。</p></li><li><p>队列</p><p>队列是 RabbitMQ 内部使用的一种数据结构，尽管消息流经 RabbitMQ 和应用程序，但它们只能存储在队列中。队列仅受主机的内存和磁盘限制的约束，本质上是一个大的消息缓冲区。许多生产者可以将消息发送到一个队列，许多消费者可以尝试从一个队列接收数据。这就是我们使用队列的方式。</p></li><li><p>消费者</p><p>消费与接收具有相似的含义。消费者大多时候是一个等待接收消息的程序。请注意生产者，消费者和消息中间件很多时候并不在同一机器上。同一个应用程序既可以是生产者又是可以是消费者。</p></li></ul><p><img src="/images/studyNote/rabbitMQ/20210903_143731.png"></p><h3 id="RabbitMQ的工作模式"><a href="#RabbitMQ的工作模式" class="headerlink" title="RabbitMQ的工作模式"></a>RabbitMQ的工作模式</h3><p><img src="/images/studyNote/rabbitMQ/20210902_222744.png"></p><ol><li><strong>简单模式</strong> HelloWorld： 一个生产者、一个消费者，不需要设置交换机（使用默认的交换机）。</li><li><strong>工作队列模式</strong> Work Queue：   一个生产者、多个消费者（竞争关系），不需要设置交换机（使用默认的交换机）。</li><li><strong>发布订阅模式</strong> Publish/subscribe：需要设置类型为 fanout 的交换机，并且交换机和队列进行绑定，当发送消息到交换机后，交换机会将消息发送到绑定的队列。</li><li><strong>路由模式</strong> Routing：   需要设置类型为 direct 的交换机，交换机和队列进行绑定，并且指定 routing key，当发送消息到交换机后，交换机会根据 routing key 将消息发送到对应的队列。</li><li><strong>通配符模式</strong> Topic：需要设置类型为 topic 的交换机，交换机和队列进行绑定，并且指定通配符方式的 routing key，当发送消息到交换机后，交换机会根据 routing key 将消息发送到对应的队列。</li></ol><h3 id="RabbitMQ工作原理"><a href="#RabbitMQ工作原理" class="headerlink" title="RabbitMQ工作原理"></a>RabbitMQ工作原理</h3><p><img src="/images/studyNote/rabbitMQ/20210902_222911.png"></p><p><strong>Broker：</strong>接收和分发消息的应用，RabbitMQ Server 就是 Message Broker</p><p><strong>Virtual host：</strong>出于多租户和安全因素设计的，把 AMQP 的基本组件划分到一个虚拟的分组中，类似于网络中的 namespace 概念。当多个不同的用户使用同一个 RabbitMQ server 提供的服务时，可以划分出多个 vhost，每个用户在自己的 vhost 创建 exchange／queue 等</p><p><strong>Connection：</strong>publisher／consumer 和 broker 之间的 TCP 连接</p><p><strong>Channel：</strong>如果每一次访问 RabbitMQ 都建立一个 Connection，在消息量大的时候建立 TCPConnection 的开销将是巨大的，效率也较低。Channel 是在 connection 内部建立的逻辑连接，如果应用程序支持多线程，通常每个 thread 创建单独的 channel 进行通讯，AMQP method 包含了 channel id 帮助客户端和 message broker 识别 channel，所以 channel 之间是完全隔离的。 l Channel  作为轻量级的Connection 极大减少了操作系统建立 TCP connection 的开销</p><p><strong>Exchange ：</strong> message 到达 broker 的第一站，根据分发规则，匹配查询表中的 routing key，分发消息到 queue 中去。常用的类型有：direct (point-to-point), topic (publish-subscribe) and fanout(multicast)</p><p><strong>Queue ：</strong> 消息最终被送到这里等待 consumer 取走</p><p><strong>Binding ：</strong> exchange 和 queue 之间的虚拟连接，binding 中可以包含 routing key，Binding 信息被保存到 exchange 中的查询表中，用于 message 的分发依据</p><h3 id="RabbitMQ安装"><a href="#RabbitMQ安装" class="headerlink" title="RabbitMQ安装"></a>RabbitMQ安装</h3><p>略….推荐使用Docker安装学习，参考文章：Docker操作笔记-从小白到入门</p><p>RabbitMQ在安装好后，可以访问<a href="http://ip地址:15672/">http://ip地址:15672</a> ;其自带了guest/guest的 用户名和密码。</p><h4 id="角色说明"><a href="#角色说明" class="headerlink" title="角色说明"></a>角色说明</h4><ul><li>超级管理员(administrator)：可登陆管理控制台，可查看所有的信息，并且可以对用户，策略(policy)进行操 作。</li><li>监控者(monitoring)：可登陆管理控制台，同时可以查看rabbitmq节点的相关信息(进程数，内存使用 情况，磁盘使用情况等)。</li><li>策略制定者(policymaker)：可登陆管理控制台, 同时可以对policy进行管理。但无法查看节点的相关信息(上 图红框标识的部分)。</li><li>普通管理者(management)：仅可登陆管理控制台，无法看到节点信息，也无法对策略进行管理。</li><li>其他：无法登陆管理控制台，通常就是普通的生产者和消费者。</li></ul><h2 id="消息应答及持久化"><a href="#消息应答及持久化" class="headerlink" title="消息应答及持久化"></a>消息应答及持久化</h2><h3 id="消息应答机制"><a href="#消息应答机制" class="headerlink" title="消息应答机制"></a>消息应答机制</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>消费者完成一个任务可能需要一段时间，如果其中一个消费者处理一个长的任务并仅只完成了部分突然它挂掉了，会发生什么情况。RabbitMQ 一旦向消费者传递了一条消息，便立即将该消息标记为删除。在这种情况下，突然有个消费者挂掉了，我们将丢失正在处理的消息。以及后续发送给该消费这的消息，因为它无法接收到。为了保证消息在发送过程中不丢失，rabbitmq 引入消息应答机制，消息应答就是: <strong>消费者在接收到消息并且处理该消息之后</strong>，告诉rabbitmq  它已经处理了，rabbitmq  可以把该消息删除了。</p><h4 id="自动应答"><a href="#自动应答" class="headerlink" title="自动应答"></a>自动应答</h4><p>消息发送后立即被认为已经传送成功，这种模式需要在<strong>高吞吐量和数据传输安全性方面做权衡</strong>,因为这种模式如果消息在接收到之前，消费者那边出现连接或者 channel 关闭，那么消息就丢失了,当然另一方面这种模式消费者那边可以传递过载的消息，<strong>没有对传递的消息数量进行限制</strong>，当然这样有可能使得消费者这边由于接收太多还来不及处理的消息，导致这些消息的积压，最终使得内存耗尽，最终这些消费者线程被操作系统杀死， 所以<strong>这种模式仅适用在消费者可以高效并以某种速率能够处理这些消息的情况下使用</strong>。</p><p>总结：尽量少用自动应答，自动应答是在接收到消息的一刹那就进行了应答，如果后续对消息进行了处理出现错误，不能重新从队列中获取消息处理。</p><h4 id="手动应答"><a href="#手动应答" class="headerlink" title="手动应答"></a>手动应答</h4><h5 id="消息应答的方法"><a href="#消息应答的方法" class="headerlink" title="消息应答的方法"></a>消息应答的方法</h5><ul><li>Channel.basicAck(用于肯定确认)：RabbitMQ 已知道该消息并且成功的处理消息，可以将其丢弃了</li><li>Channel.basicNack(用于否定确认)</li><li>Channel.basicReject(用于否定确认)：与 Channel.basicNack 相比少一个参数(是否批量处理)，不处理该消息了直接拒绝，可以将其丢弃了</li></ul><p>手动应答的好处是可以批量应答并且减少网络拥堵</p><p><img src="/images/studyNote/rabbitMQ/20210902_225727.png"></p><p>multiple 的 true 和 false 代表不同意思</p><ul><li>true 代表批量应答 channel 上未应答的消息，比如说 channel 上有传送 tag 的消息 5,6,7,8 当前 tag 是 8 那么此时5-8 的这些还未应答的消息都会被确认收到消息应答</li><li>false 同上面相比只会应答 tag=8 的消息 5,6,7 这三个消息依然不会被确认收到消息应答</li></ul><p><img src="/images/studyNote/rabbitMQ/20210902_225929.png"></p><h3 id="消息自动重新入队"><a href="#消息自动重新入队" class="headerlink" title="消息自动重新入队"></a>消息自动重新入队</h3><p>如果消费者由于某些原因失去连接(其通道已关闭，连接已关闭或 TCP 连接丢失)，导致消息未发送 ACK 确认，<font color=red face="黑体">RabbitMQ 将了解到消息未完全处理，并将对其重新排队。</font>如果此时其他消费者可以处理，它将很快将其重新分发给另一个消费者。这样，即使某个消费者偶尔死亡，也可以确保不会丢失任何消息。</p><p><img src="/images/studyNote/rabbitMQ/20210902_230720.png"></p><h3 id="消息手动应答代码编写"><a href="#消息手动应答代码编写" class="headerlink" title="消息手动应答代码编写"></a>消息手动应答代码编写</h3><p>默认消息采用的是自动应答，所以我们要想实现消息消费过程中不丢失，需要把自动应答改为手动应答，消费者在上面代码的基础上增加下面画红色部分代码。</p><p><img src="/images/studyNote/rabbitMQ/20210903_093454.png"></p><h4 id="消息生产者"><a href="#消息生产者" class="headerlink" title="消息生产者"></a>消息生产者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 队列名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TASK_QUEUE_NAME = <span class="string">&quot;ack_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line">        <span class="comment">// 声明队列：队列名称，是否持久化，是否共享，自动删除，参数</span></span><br><span class="line">        channel.queueDeclare(TASK_QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">            String message = scanner.next();</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, TASK_QUEUE_NAME, <span class="keyword">null</span>,</span><br><span class="line">                    message.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">            log.info(<span class="string">&quot;生产者发送消息：&#123;&#125;&quot;</span>, message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>RabbitMQ 连接工具类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMqUtils</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 得到一个连接的 channel</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Channel <span class="title">getChannel</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个连接工厂</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;guest&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;guest&quot;</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;demo&quot;</span>);</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="keyword">return</span> channel;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Work01</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ACK_QUEUE_NAME = <span class="string">&quot;ack_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line">        System.out.println(<span class="string">&quot;Work01  等待接收消息处理时间较短&quot;</span>);</span><br><span class="line">        <span class="comment">// 消息消费的时候如何处理消息</span></span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            String message = <span class="keyword">new</span> String(delivery.getBody());</span><br><span class="line">            <span class="comment">// 业务处理耗时1秒</span></span><br><span class="line">            SleepUtils.sleep(<span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot; 接收到消息:&quot;</span> + message);</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 采用手动应答</span></span><br><span class="line"><span class="comment">             * 1. 消息标记 tag</span></span><br><span class="line"><span class="comment">             * 2. 是否批量应答未应答消息：不批量信道中的消息</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// ***采用手动应答</span></span><br><span class="line">        <span class="keyword">boolean</span> autoAck = <span class="keyword">false</span>;</span><br><span class="line">        channel.basicConsume(ACK_QUEUE_NAME, autoAck, deliverCallback, (consumerTag) -&gt; &#123;</span><br><span class="line">            System.out.println(consumerTag + <span class="string">&quot; 消费者取消消费接口回调逻辑&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>睡眠工具</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepUtils</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">int</span> second)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000L</span> * second);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RabbitMQ-持久化"><a href="#RabbitMQ-持久化" class="headerlink" title="RabbitMQ 持久化"></a><strong>RabbitMQ</strong> 持久化</h3><h4 id="持久化概念"><a href="#持久化概念" class="headerlink" title="持久化概念"></a>持久化概念</h4><p>刚刚我们已经看到了如何处理任务不丢失的情况，但是如何<strong>保障当 RabbitMQ 服务停掉以后消息生产者发送过来的消息不丢失</strong>。默认情况下 RabbitMQ 退出或由于某种原因崩溃时，它忽视队列和消息，除非告知它不要这样做。确保消息不会丢失需要做两件事：我们需要将<strong>队列和消息</strong>都标记为持久化。</p><h4 id="队列实现持久化"><a href="#队列实现持久化" class="headerlink" title="队列实现持久化"></a>队列实现持久化</h4><p>之前我们创建的队列都是非持久化的，rabbitmq 如果重启的化，该队列就会被删除掉，如果 要队列实现持久化 需要在声明队列的时候把 durable 参数设置为持久化</p><p><img src="/images/studyNote/rabbitMQ/20210903_104223.png"></p><p>但是需要注意的就是如果之前声明的队列不是持久化的，需要把原先队列先删除，或者重新创建一个持久化的队列，不然就会出现错误。</p><p><img src="/images/studyNote/rabbitMQ/20210903_104728.png"></p><p>以下为控制台中持久化与非持久化队列的 UI 显示区：</p><p><img src="/images/studyNote/rabbitMQ/20210903_104945.png"> 这个时候即使重启 rabbitmq 队列也依然存在。</p><h4 id="消息实现持久化"><a href="#消息实现持久化" class="headerlink" title="消息实现持久化"></a>消息实现持久化</h4><p>要想让消息实现持久化需要在消息生产者修改代码，MessageProperties.PERSISTENT_TEXT_PLAIN 添加这个属性，如下图</p><p><img src="/images/studyNote/rabbitMQ/20210903_105242.png"></p><p>将消息标记为持久化并不能完全保证不会丢失消息。尽管它告诉 RabbitMQ 将消息保存到磁盘，但是 这里依然存在当消息刚准备存储在磁盘的时候 但是还没有存储完，消息还在缓存的一个间隔点。此时并没 有真正写入磁盘。持久性保证并不强，但是对于我们的简单任务队列而言，这已经绰绰有余了。如果需要 更强有力的持久化策略，参考后边课件发布确认章节。</p><h3 id="不公平分发"><a href="#不公平分发" class="headerlink" title="不公平分发"></a>不公平分发</h3><p>在最开始的时候我们学习到 RabbitMQ 分发消息采用的轮训分发，但是在某种场景下这种策略并不是很好，比方说有两个消费者在处理任务，其中有个消费者 1 处理任务的速度非常快，而另外一个消费者 2 处理速度却很慢，这个时候我们还是采用轮训分发的化就会到这处理速度快的这个消费者很大一部分时间处于空闲状态，而处理慢的那个消费者一直在干活，这种分配方式在这种情况下其实就不太好，但是<br>RabbitMQ 并不知道这种情况它依然很公平的进行分发。</p><p><font color=red>注：</font>为了避免这种情况，我们可以设置参数 channel.basicQos(1)，不公平分发由消费方设置，<font color=red >生产环境应该设置为不公平分发。</font> </p><p><img src="/images/studyNote/rabbitMQ/20210907_03532.png"></p><p><img src="/images/studyNote/rabbitMQ/20210907_03616.png"></p><p><img src="/images/studyNote/rabbitMQ/20210907_04707.png"></p><p>意思就是如果这个任务我还没有处理完或者我还没有应答你，你先别分配给我，我目前只能处理一个任务，然后 rabbitmq 就会把该任务分配给没有那么忙的那个空闲消费者，当然如果所有的消费者都没有完成手上任务，队列还在不停的添加新任务，队列有可能就会遇到队列被撑满的情况，这个时候就只能添加新的 worker 或者改变其他存储任务的策略。</p><h2 id="发布确认"><a href="#发布确认" class="headerlink" title="发布确认"></a>发布确认</h2><h3 id="发布确认原理"><a href="#发布确认原理" class="headerlink" title="发布确认原理"></a>发布确认原理</h3><p>生产者将信道设置成 confirm 模式，一旦信道进入confirm 模式，所有在该信道上面发布的消息都将会被指派一个唯一的ID(从1开始)，一旦消息被投递到所有匹配的队列之后，broker 就会发送一个确认给生产者(包含消息的唯一ID)，这就使得生产者知道消息已经正确到达目的队列了，如果消息和队列是可持久化的，那么确认消息会在将消息写入磁盘之后发出，broker回传 给生产者的确认消息中 delivery-tag 域包含了确认消息的序列号，此外broker也可以设置basic.ack的multiple域，表示到这个序列号之前的所有消息都已经得到了处理。confirm 模式最大的好处在于他是异步的，一旦发布一条消息，生产者应用程序就可以在等信道返回确认的同时继续发送下一条消息，当消息最终得到确认之后，生产者应用便可以通过回调方法来处理该确认消息，如果 RabbitMQ因为自身内部错误导致消息丢失，就会发送一条nack消 息，生产者应用程序同样可以在回调方法中处理该nack消息。</p><h3 id="发布确认的策略"><a href="#发布确认的策略" class="headerlink" title="发布确认的策略"></a>发布确认的策略</h3><h4 id="开启发布确认的方法"><a href="#开启发布确认的方法" class="headerlink" title="开启发布确认的方法"></a>开启发布确认的方法</h4><p>发布确认默认是没有开启的，如果要开启需要调用方法 confirmSelect，每当你要想使用发布确认，都需要在 channel 上调用该方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Channel channel = connection.createchannel();</span><br><span class="line">channel.confirmselect();</span><br></pre></td></tr></table></figure><h4 id="第一种：单个确认发布"><a href="#第一种：单个确认发布" class="headerlink" title="第一种：单个确认发布"></a>第一种：单个确认发布</h4><p>这是一种简单的确认方式，它是一种<strong>同步确认发布的方式</strong>，也就是发布一个消息之后只有它 被确认发布，后续的消息才能继续发布,waitForConfirmsOrDie(long)这个方法只有在消息被确认 的时候才返回，如果在指定时间范围内这个消息没有被确认那么它将抛出异常。这种确认方式有一个最大的缺点就是:<strong>发布速度特别的慢</strong>，因为如果没有确认发布的消息就会 阻塞所有后续消息的发布，这种方式最多提供每秒不超过数百条发布消息的吞吐量。当然对于某 些应用程序来说这可能已经足够了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发布单条消息1000条耗时测试： 722ms</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">publishMessageOne</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (Channel channel = RabbitMqUtils.getChannel()) &#123;</span><br><span class="line">        String queueName = UUID.randomUUID().toString();</span><br><span class="line">        channel.queueDeclare(queueName, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 开启发布确认</span></span><br><span class="line">        channel.confirmSelect();</span><br><span class="line">        <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MESSAGE_COUNT; i++) &#123;</span><br><span class="line">            String message = i + <span class="string">&quot;&quot;</span>;</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">            <span class="comment">// 发送之后马上进行发布确认，服务端返回 false 或超时时间内未返回，生产者可以消息重发</span></span><br><span class="line">            <span class="keyword">boolean</span> flag = channel.waitForConfirms();</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot; 消息发送成功&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot; 发布&quot;</span> + MESSAGE_COUNT + <span class="string">&quot; 个单独确认消息, 耗时&quot;</span> + (end - begin) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="第二种：批量确认发布"><a href="#第二种：批量确认发布" class="headerlink" title="第二种：批量确认发布"></a>第二种：批量确认发布</h4><p>上面那种方式非常慢，与单个等待确认消息相比，先发布一批消息然后一起确认可以极大地 提高吞吐量，当然这种方式的缺点就是:当发生故障导致发布出现问题时，不知道是哪个消息出现 问题了，我们必须将整个批处理保存在内存中，以记录重要的信息而后重新发布消息。当然这种 方案仍然是同步的，也一样阻塞消息的发布。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 批量发布确认 发布1000个消息，耗时141ms</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">publishMessageBatch</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (Channel channel = RabbitMqUtils.getChannel()) &#123;</span><br><span class="line">        String queueName = UUID.randomUUID().toString();</span><br><span class="line">        channel.queueDeclare(queueName, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 开启发布确认</span></span><br><span class="line">        channel.confirmSelect();</span><br><span class="line">        <span class="comment">// 批量确认消息大小</span></span><br><span class="line">        <span class="keyword">int</span> batchSize = <span class="number">100</span>;</span><br><span class="line">        <span class="comment">// 未确认消息个数</span></span><br><span class="line">        <span class="keyword">int</span> outstandingMessageCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MESSAGE_COUNT; i++) &#123;</span><br><span class="line">            String message = i + <span class="string">&quot;&quot;</span>;</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">            outstandingMessageCount++;</span><br><span class="line">            <span class="comment">// 100条确认一次</span></span><br><span class="line">            <span class="keyword">if</span> (outstandingMessageCount == batchSize) &#123;</span><br><span class="line">                channel.waitForConfirms();</span><br><span class="line">                outstandingMessageCount = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 为了确保还有剩余没有确认消息 再次确认</span></span><br><span class="line">        <span class="keyword">if</span> (outstandingMessageCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            channel.waitForConfirms();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot; 发布&quot;</span> + MESSAGE_COUNT + <span class="string">&quot; 个批量确认消息, 耗时&quot;</span> + (end - begin) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="第三种：异步确认发布"><a href="#第三种：异步确认发布" class="headerlink" title="第三种：异步确认发布"></a>第三种：异步确认发布</h4><p>异步确认虽然编程逻辑比上两个要复杂，但是性价比最高，无论是可靠性还是效率都没得说， 他是利用回调函数来达到消息可靠性传递的，这个中间件也是通过函数回调来保证是否投递成功， 下面就让我们来详细讲解异步确认是怎么实现的。</p><p><img src="/images/studyNote/rabbitMQ/20210907_11902.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异步发布确认  发布1000个消息，耗时62ms</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">publishMessageAsync</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (Channel channel = RabbitMqUtils.getChannel()) &#123;</span><br><span class="line">        String queueName = UUID.randomUUID().toString();</span><br><span class="line">        channel.queueDeclare(queueName, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 开启发布确认</span></span><br><span class="line">        channel.confirmSelect();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">             *  线程安全有序的一个哈希表，适用于高并发的情况</span></span><br><span class="line"><span class="comment">             * 1. 轻松的将序号与消息进行关联</span></span><br><span class="line"><span class="comment">             * 2. 轻松批量删除条目 只要给到序列号</span></span><br><span class="line"><span class="comment">             * 3. 支持并发访问</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        ConcurrentSkipListMap&lt;Long,  String&gt; outstandingConfirms  =  <span class="keyword">new</span></span><br><span class="line">            ConcurrentSkipListMap&lt;&gt;();</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">             *  确认收到消息的一个回调</span></span><br><span class="line"><span class="comment">             * 1. 消息序列号</span></span><br><span class="line"><span class="comment">             * 2.true 可以确认小于等于当前序列号的消息</span></span><br><span class="line"><span class="comment">             * false 确认当前序列号消息</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        ConfirmCallback ackCallback = (sequenceNumber, multiple) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (multiple) &#123;</span><br><span class="line">                <span class="comment">// 返回的是小于等于当前序列号的未确认消息 是一个 map</span></span><br><span class="line">                ConcurrentNavigableMap&lt;Long,  String&gt; confirmed  =</span><br><span class="line">                    outstandingConfirms.headMap(sequenceNumber, <span class="keyword">true</span>);</span><br><span class="line">                <span class="comment">// 清除该部分未确认消息</span></span><br><span class="line">                confirmed.clear();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 只清除当前序列号的消息</span></span><br><span class="line">                outstandingConfirms.remove(sequenceNumber);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        ConfirmCallback nackCallback = (sequenceNumber, multiple) -&gt; &#123;</span><br><span class="line">            String message = outstandingConfirms.get(sequenceNumber);</span><br><span class="line">            System.out.println(<span class="string">&quot; 发布的消息&quot;</span>+message+<span class="string">&quot; 未被确认，序列号&quot;</span>+sequenceNumber);</span><br><span class="line">        &#125;;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">             *  添加一个异步确认的监听器</span></span><br><span class="line"><span class="comment">             * 1. 确认收到消息的回调</span></span><br><span class="line"><span class="comment">             * 2. 未收到消息的回调</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        channel.addConfirmListener(ackCallback, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MESSAGE_COUNT; i++) &#123;</span><br><span class="line">            String message = <span class="string">&quot; 消息&quot;</span> + i;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * channel.getNextPublishSeqNo() 获取下一个消息的序列号</span></span><br><span class="line"><span class="comment">                 *  通过序列号与消息体进行一个关联</span></span><br><span class="line"><span class="comment">                 *  全部都是未确认的消息体</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">            outstandingConfirms.put(channel.getNextPublishSeqNo(), message);</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot; 发布&quot;</span> + MESSAGE_COUNT + <span class="string">&quot; 个异步确认消息, 耗时&quot;</span> + (end - begin) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="如何处理异步未确认消息"><a href="#如何处理异步未确认消息" class="headerlink" title="如何处理异步未确认消息"></a>如何处理异步未确认消息</h4><p>好的解决的解决方案就是把未确认的消息放到一个基于内存的能被发布线程访问的队列， 比如说用 ConcurrentLinkedQueue 这个队列在 confirm callbacks 与发布线程之间进行消息的传 递。</p><h4 id="3种发布确认速度对比"><a href="#3种发布确认速度对比" class="headerlink" title="3种发布确认速度对比"></a>3种发布确认速度对比</h4><ul><li>单独发布消息：同步等待确认，简单，但吞吐量非常有限。</li><li>批量发布消息：批量同步等待确认，简单，合理的吞吐量，一旦出现问题但很难推断出是那条消息出现了问题。</li><li>异步处理：最佳性能和资源使用，在出现错误的情况下可以很好地控制，但是实现起来稍微难些。</li></ul><h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><p>在上一节中，我们创建了一个工作队列。我们假设的是工作队列背后，每个任务都恰好交付给一个消 费者(工作进程)。在这一部分中，我们将做一些完全不同的事情-我们将消息传达给多个消费者。这种模式 称为 ”发布/订阅”，为了说明这种模式，我们将构建一个简单的日志系统。它将由两个程序组成:第一个程序将发出日志消 息，第二个程序是消费者。其中我们会启动两个消费者，其中一个消费者接收到消息后把日志存储在磁盘，另外一个消费者接收到消息后把消息打印在屏幕上，事实上第一个程序发出的日志消息将广播给所有消费者。</p><h3 id="Exchanges概念"><a href="#Exchanges概念" class="headerlink" title="Exchanges概念"></a>Exchanges概念</h3><p>RabbitMQ 消息传递模型的核心思想是: <strong>生产者生产的消息从不会直接发送到队列</strong>。实际上，通常生产者甚至都不知道这些消息传递传递到了哪些队列中。相反，**生产者只能将消息发送到交换机(exchange)**，交换机工作的内容非常简单，一方面它接收来 自生产者的消息，另一方面将它们推入队列。交换机必须确切知道如何处理收到的消息。是应该把这些消 息放到特定队列还是说把他们到许多队列中还是说应该丢弃它们。这就的由交换机的类型来决定。</p><h3 id="Exchanges-的类型"><a href="#Exchanges-的类型" class="headerlink" title="Exchanges 的类型"></a>Exchanges 的类型</h3><ul><li>直接(direct) — 路由类型</li><li>主题(topic) — 通配符匹配模式</li><li>标题(headers) — 已经不用了</li><li>扇出(fanout) — 发布订阅类型</li></ul><h3 id="无名-exchange"><a href="#无名-exchange" class="headerlink" title="无名 exchange"></a>无名 exchange</h3><p>第一个参数是交换机的名称。空字符串表示默认或无名称交换机：消息能路由发送到队列中其实是由 routingKey(bindingkey)绑定 key 指定的。</p><p><img src="/images/studyNote/rabbitMQ/20210903_140200.png"></p><h3 id="临时队列"><a href="#临时队列" class="headerlink" title="临时队列"></a>临时队列</h3><p>每当我们连接到 Rabbit 时，我们都需要一个全新的空队列，为此我们可以创建一个具有<strong>随机名称的队列</strong>，或者能让服务器为我们选择一个随机队列名称那就更好了。其次<strong>一旦我们断开了消费者的连接，队列将被自动删除。</strong>创建临时队列的方式如下:<br><code>String queueName = channel.queueDeclare().getQueue();</code></p><h3 id="绑定-bindings"><a href="#绑定-bindings" class="headerlink" title="绑定(bindings)"></a>绑定(bindings)</h3><p>什么是 bingding 呢，binding 其实是 exchange 和 queue 之间的桥梁，它告诉我们 exchange 和那个队 列进行了绑定关系。比如说下面这张图告诉我们的就是 X 与 Q1 和 Q2 进行了绑定</p><p><img src="/images/studyNote/rabbitMQ/20210903_140800.png"></p><h3 id="Fanout-发布订阅交换机"><a href="#Fanout-发布订阅交换机" class="headerlink" title="Fanout(发布订阅交换机)"></a>Fanout(发布订阅交换机)</h3><p>Fanout 这种类型非常简单。正如从名称中猜到的那样，它是将接收到的所有消息<strong>广播</strong>到它知道的 所有队列中。系统中默认有些 exchange 类型</p><p><img src="/images/studyNote/rabbitMQ/20210903_141025.png"></p><h4 id="Fanout-实战"><a href="#Fanout-实战" class="headerlink" title="Fanout  实战"></a>Fanout  实战</h4><p><img src="/images/studyNote/rabbitMQ/20210910_230006.png"></p><p>Logs 和临时队列的绑定关系如下图</p><p><img src="/images/studyNote/rabbitMQ/20210910_230126.png"></p><h5 id="发布订阅发布者"><a href="#发布订阅发布者" class="headerlink" title="发布订阅发布者"></a>发布订阅发布者</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmitLog</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">&quot;logs&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (Channel channel = RabbitMqUtils.getChannel()) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             *  声明一个 exchange</span></span><br><span class="line"><span class="comment">             * 1.exchange 的名称</span></span><br><span class="line"><span class="comment">             * 2.exchange 的类型</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;fanout&quot;</span>);</span><br><span class="line">            Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">            System.out.println(<span class="string">&quot; 请输入信息&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (sc.hasNext()) &#123;</span><br><span class="line">                String message = sc.nextLine();</span><br><span class="line">                channel.basicPublish(EXCHANGE_NAME, <span class="string">&quot;&quot;</span>, <span class="keyword">null</span>, message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                System.out.println(<span class="string">&quot; 生产者发出消息&quot;</span> + message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="发布订阅接收者1"><a href="#发布订阅接收者1" class="headerlink" title="发布订阅接收者1"></a>发布订阅接收者1</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveLogs01</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">&quot;logs&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;fanout&quot;</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  生成一个临时的队列 队列的名称是随机的</span></span><br><span class="line"><span class="comment">         *  当消费者断开和该队列的连接时 队列自动删除</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        String queueName = channel.queueDeclare().getQueue();</span><br><span class="line">        <span class="comment">// 把该临时队列绑定我们的 exchange  其中 routingkey( 也称之为 binding key) 为空字符串</span></span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;01等待接收消息, 把接收到的消息打印在屏幕.....&quot;</span>);</span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            String message = <span class="keyword">new</span> String(delivery.getBody(), StandardCharsets.UTF_8);</span><br><span class="line">            System.out.println(<span class="string">&quot;01控制台打印接收到的消息&quot;</span> + message);</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="发布订阅接收者2"><a href="#发布订阅接收者2" class="headerlink" title="发布订阅接收者2"></a>发布订阅接收者2</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveLogs02</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">&quot;logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;fanout&quot;</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  生成一个临时的队列 队列的名称是随机的</span></span><br><span class="line"><span class="comment">         *  当消费者断开和该队列的连接时 队列自动删除</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        String queueName = channel.queueDeclare().getQueue();</span><br><span class="line">        <span class="comment">// 把该临时队列绑定我们的 exchange  其中 routingkey( 也称之为 binding key) 为空字符串</span></span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;02等待接收消息, 把接收到的消息打印在屏幕.....&quot;</span>);</span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            String message = <span class="keyword">new</span> String(delivery.getBody(), StandardCharsets.UTF_8);</span><br><span class="line">            System.out.println(<span class="string">&quot;02控制台打印接收到的消息&quot;</span> + message);</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Direct-exchange-直接交换机"><a href="#Direct-exchange-直接交换机" class="headerlink" title="Direct exchange(直接交换机)"></a>Direct exchange(直接交换机)</h3><p>上一节中，我们构建了一个简单的日志记录系统。我们能够向许多接收者广播日志消息。在本节我们将向其中添加一些特别的功能-比方说我们只让某个消费者订阅发布的部分消息。例如我们只把严重错误消息定向存储到日志文件(以节省磁盘空间)，同时仍然能够在控制台上打印所有日志消息。我们再次来回顾一下什么是 bindings，绑定是交换机和队列之间的桥梁关系。也可以这么理解：队列只对它绑定的交换机的消息感兴趣。绑定用参数：routingKey 来表示也可称该参数为 binding key，创建绑定我们用代码:<code>channel.queueBind(queueName, EXCHANGE_NAME, &quot;routingKey&quot;);</code><strong>绑定之后的意义由其交换类型决定。</strong></p><p><img src="/images/studyNote/rabbitMQ/20210910_232643.png"></p><p><img src="/images/studyNote/rabbitMQ/20210910_232754.png"></p><h4 id="直接交换机发布者"><a href="#直接交换机发布者" class="headerlink" title="直接交换机发布者"></a>直接交换机发布者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmitLogDirect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">&quot;direct_logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (Channel channel = RabbitMqUtils.getChannel()) &#123;</span><br><span class="line">            channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class="line">            <span class="comment">// 创建多个 bindingKey</span></span><br><span class="line">            Map&lt;String, String&gt; bindingKeyMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            bindingKeyMap.put(<span class="string">&quot;info&quot;</span>, <span class="string">&quot; 普通 info  信息&quot;</span>);</span><br><span class="line">            bindingKeyMap.put(<span class="string">&quot;warning&quot;</span>, <span class="string">&quot; 警告 warning  信息&quot;</span>);</span><br><span class="line">            bindingKeyMap.put(<span class="string">&quot;error&quot;</span>, <span class="string">&quot; 错误 error  信息&quot;</span>);</span><br><span class="line">            <span class="comment">//debug 没有消费这接收这个消息 所有就丢失了</span></span><br><span class="line">            bindingKeyMap.put(<span class="string">&quot;debug&quot;</span>, <span class="string">&quot; 调试 debug  信息&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; bindingKeyEntry : bindingKeyMap.entrySet()) &#123;</span><br><span class="line">                String bindingKey = bindingKeyEntry.getKey();</span><br><span class="line">                String message = bindingKeyEntry.getValue();</span><br><span class="line">                channel.basicPublish(EXCHANGE_NAME, bindingKey, <span class="keyword">null</span>, message.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">                System.out.println(<span class="string">&quot; 生产者发出消息:&quot;</span> + message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="直接交换机消费者1"><a href="#直接交换机消费者1" class="headerlink" title="直接交换机消费者1"></a>直接交换机消费者1</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveLogsDirect01</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">&quot;direct_logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class="line">        String queueName = <span class="string">&quot;disk&quot;</span>;</span><br><span class="line">        channel.queueDeclare(queueName, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;error&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot; 等待接收消息.....&quot;</span>);</span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            String message = <span class="keyword">new</span> String(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            message = <span class="string">&quot; 接收绑定键:&quot;</span> + delivery.getEnvelope().getRoutingKey() + <span class="string">&quot;, 消息:&quot;</span> + message;</span><br><span class="line">            <span class="comment">// 写磁盘忽略</span></span><br><span class="line">            System.out.println(<span class="string">&quot; 错误日志已经接收&quot;</span> + message);</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="直接交换机消费者2"><a href="#直接交换机消费者2" class="headerlink" title="直接交换机消费者2"></a>直接交换机消费者2</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveLogsDirect02</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">&quot;direct_logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class="line">        String queueName = <span class="string">&quot;console&quot;</span>;</span><br><span class="line">        channel.queueDeclare(queueName, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;info&quot;</span>);</span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;warning&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot; 等待接收消息.....&quot;</span>);</span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            String message = <span class="keyword">new</span> String(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;  接 收 绑 定 键 :&quot;</span> + delivery.getEnvelope().getRoutingKey() + <span class="string">&quot;, 消息:&quot;</span> + message);</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Topics-主题交换机"><a href="#Topics-主题交换机" class="headerlink" title="Topics(主题交换机)"></a>Topics(主题交换机)</h3><p>在上一个小节中，我们改进了日志记录系统。我们没有使用只能进行随意广播的 fanout 交换机，而是使用了 direct 交换机，从而有能实现有选择性地接收日志。尽管使用 direct 交换机改进了我们的系统，但是它仍然存在局限性-比方说我们想接收的日志类型有info.base 和 info.advantage，某个队列只想 info.base 的消息，那这个时候 direct 就办不到了。这个时候就只能使用 topic 类型。</p><h4 id="Topic-要求"><a href="#Topic-要求" class="headerlink" title="Topic 要求"></a>Topic 要求</h4><p>发送到类型是 topic 交换机的消息的 routing_key 不能随意写，必须满足一定的要求，它必须是一个单词列表，以点号分隔开。这些单词可以是任意单词，比如说：”stock.usd.nyse”, “nyse.vmw”,”quick.orange.rabbit”.这种类型的。当然这个单词列表最多不能超过 255 个字节。在这个规则列表中，其中有两个替换符是大家需要注意的</p><ul><li>*(星号)可以代替一个单词</li><li>#(井号)可以替代零个或多个单词</li></ul><h4 id="Topic-匹配案例"><a href="#Topic-匹配案例" class="headerlink" title="Topic  匹配案例"></a>Topic  匹配案例</h4><p>下图绑定关系如下：<br>    Q1–&gt;绑定的是：中间带 orange 带 3 个单词的字符串(<em>.orange.</em>)<br>    Q2–&gt;绑定的是：最后一个单词是 rabbit 的 3 个单词(<em>.</em>.rabbit) 第一个单词是 lazy 的多个单词(lazy.#)</p><p><img src="/images/studyNote/rabbitMQ/20210910_235635.png"></p><p>上图是一个队列绑定关系图，我们来看看他们之间数据接收情况是怎么样的<br>quick.orange.rabbit      ————        被队列 Q1Q2 接收到<br>lazy.orange.elephant   ————           被队列 Q1Q2 接收到<br>quick.orange.fox          ————         被队列 Q1 接收到<br>lazy.brown.fox          ————          被队列 Q2 接收到<br>lazy.pink.rabbit            ————          虽然满足两个绑定但只被队列 Q2 接收一次<br>quick.brown.fox          ————          不匹配任何绑定不会被任何队列接收到会被丢弃<br>quick.orange.male.rabbit ————   是四个单词不匹配任何绑定会被丢弃<br>lazy.orange.male.rabbit  ————    是四个单词但匹配 Q2</p><p>当队列绑定关系是下列这种情况时需要引起注意  <strong>当一个队列绑定键是#,那么这个队列将接收所有数据</strong>，就有点像 fanout 了，如果队列绑定键当中没有#和*出现，那么该队列绑定类型就是 direct 了。</p><h2 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h2><h3 id="死信的概念"><a href="#死信的概念" class="headerlink" title="死信的概念"></a>死信的概念</h3><p>先从概念解释上搞清楚这个定义，死信，顾名思义就是无法被消费的消息，字面意思可以这样理 解，一般来说，producer 将消息投递到 broker 或者直接到 queue 里了，consumer 从 queue 取出消息 进行消费，但某些时候由于特定的原因导致 queue 中的某些消息无法被消费，这样的消息如果没有 后续的处理，就变成了死信，有死信自然就有了死信队列。</p><p>应用场景:为了保证订单业务的消息数据不丢失，需要使用到 RabbitMQ 的死信队列机制，当消息 消费发生异常时，将消息投入死信队列中.还有比如说: 用户在商城下单成功并点击去支付后在指定时 间未支付时自动失效</p><h4 id="死信的来源"><a href="#死信的来源" class="headerlink" title="死信的来源"></a>死信的来源</h4><ol><li>消息 TTL 过期</li><li>队列达到最大长度(队列满了，无法再添加数据到 mq 中)</li><li>消息被拒绝(basic.reject 或 basic.nack)并且 requeue=false.</li></ol><h4 id="代码架构图"><a href="#代码架构图" class="headerlink" title="代码架构图"></a>代码架构图</h4><p><img src="/images/studyNote/rabbitMQ/20210911_01243.png"></p><h4 id="消息TTL过期代码"><a href="#消息TTL过期代码" class="headerlink" title="消息TTL过期代码"></a>消息TTL过期代码</h4><h5 id="死信生产者"><a href="#死信生产者" class="headerlink" title="死信生产者"></a>死信生产者</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String NORMAL_EXCHANGE = <span class="string">&quot;normal_exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (Channel channel = RabbitMqUtils.getChannel()) &#123;</span><br><span class="line">            channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line">            <span class="comment">// 设置消息的 TTL 时间</span></span><br><span class="line">            AMQP.BasicProperties properties = <span class="keyword">new</span></span><br><span class="line">                    AMQP.BasicProperties().builder().expiration(<span class="string">&quot;10000&quot;</span>).build();</span><br><span class="line">            <span class="comment">// 该信息是用作演示队列个数限制</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">                String message = <span class="string">&quot;info&quot;</span> + i;</span><br><span class="line">                channel.basicPublish(NORMAL_EXCHANGE, <span class="string">&quot;zhangsan&quot;</span>, properties, message.getBytes());</span><br><span class="line">                System.out.println(<span class="string">&quot; 生产者发送消息:&quot;</span> + message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="死信消费者C1"><a href="#死信消费者C1" class="headerlink" title="死信消费者C1"></a>死信消费者C1</h5><p>消费者 C1 ( 启动之后关闭该消费者 模拟其接收不到消息)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer01</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 普通交换机名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String NORMAL_EXCHANGE = <span class="string">&quot;normal_exchange&quot;</span>;</span><br><span class="line">    <span class="comment">// 死信交换机名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEAD_EXCHANGE = <span class="string">&quot;dead_exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line">        <span class="comment">// 声明死信和普通交换机 类型为 direct</span></span><br><span class="line">        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line">        channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line">        <span class="comment">// 声明死信队列</span></span><br><span class="line">        String deadQueue = <span class="string">&quot;dead-queue&quot;</span>;</span><br><span class="line">        channel.queueDeclare(deadQueue, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 死信队列绑定死信交换机与 routingkey</span></span><br><span class="line">        channel.queueBind(deadQueue, DEAD_EXCHANGE, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        <span class="comment">// 正常队列绑定死信队列信息</span></span><br><span class="line">        Map&lt;String, Object&gt; params = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// 正常队列设置死信交换机 参数 key 是固定值</span></span><br><span class="line">        params.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, DEAD_EXCHANGE);</span><br><span class="line">        <span class="comment">// 正常队列设置死信 routing-key  参数 key 是固定值</span></span><br><span class="line">        params.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        String normalQueue = <span class="string">&quot;normal-queue&quot;</span>;</span><br><span class="line">        channel.queueDeclare(normalQueue, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, params);</span><br><span class="line">        channel.queueBind(normalQueue, NORMAL_EXCHANGE, <span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot; 等待接收消息.....&quot;</span>);</span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            String message = <span class="keyword">new</span> String(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Consumer01  接收到消息&quot;</span> + message);</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(normalQueue, <span class="keyword">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="死信队列消费者"><a href="#死信队列消费者" class="headerlink" title="死信队列消费者"></a>死信队列消费者</h5><p>消费者 C2  ( 以上步骤完成后 启动 C2  消费者它消费死信队列里面的消息)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer02</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEAD_EXCHANGE = <span class="string">&quot;dead_exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line">        channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line">        String deadQueue = <span class="string">&quot;dead-queue&quot;</span>;</span><br><span class="line">        channel.queueDeclare(deadQueue, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        channel.queueBind(deadQueue, DEAD_EXCHANGE, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot; 等待接收死信队列消息.....&quot;</span>);</span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            String message = <span class="keyword">new</span> String(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Consumer02  接收死信队列的消息&quot;</span> + message);</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(deadQueue, <span class="keyword">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/studyNote/rabbitMQ/20210911_02525.png"></p><h3 id="队列达到最大长度"><a href="#队列达到最大长度" class="headerlink" title="队列达到最大长度"></a>队列达到最大长度</h3><h4 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h4><p>消息生产者代码去掉 TTL 属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TooLongProducer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String NORMAL_EXCHANGE = <span class="string">&quot;normal_exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (Channel channel = RabbitMqUtils.getChannel()) &#123;</span><br><span class="line">            channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line">            <span class="comment">// 该信息是用作演示队列个数限制</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">                String message = <span class="string">&quot;info&quot;</span> + i;</span><br><span class="line">                channel.basicPublish(NORMAL_EXCHANGE, <span class="string">&quot;zhangsan&quot;</span>, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">                System.out.println(<span class="string">&quot; 生产者发送消息:&quot;</span> + message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="消费者-1"><a href="#消费者-1" class="headerlink" title="消费者"></a>消费者</h4><p>C1 消费者修改以下代码 ( 启动之后关闭该消费者 模拟其接收不到消息)</p><p><img src="/images/studyNote/rabbitMQ/20210911_03017.png"></p><p><font color=red >注意此时需要把原先队列删除 因为参数改变了</font>  ,C2 消费者代码不变( 启动 C2 消费者)</p><p><img src="/images/studyNote/rabbitMQ/20210911_03245.png"></p><h3 id="消息被拒进入死信"><a href="#消息被拒进入死信" class="headerlink" title="消息被拒进入死信"></a>消息被拒进入死信</h3><p>代码略</p><h2 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h2><p>延时队列,队列内部是有序的，最重要的特性就体现在它的延时属性上，延时队列中的元素是希望在指定时间到了以后或之前取出和处理，简单来说，延时队列就是用来存放需要在指定时间被处理的元素的队列。</p><h3 id="延迟队列使用场景"><a href="#延迟队列使用场景" class="headerlink" title="延迟队列使用场景"></a>延迟队列使用场景</h3><ol><li>订单在十分钟之内未支付则自动取消</li><li>新创建的店铺，如果在十天内都没有上传过商品，则自动发送消息提醒。</li><li>用户注册成功后，如果三天内没有登陆则进行短信提醒。</li><li>用户发起退款，如果三天内没有得到处理则通知相关运营人员。</li><li>预定会议后，需要在预定的时间点前十分钟通知各个与会人员参加会议</li></ol><h3 id="RabbitMQ-中的-TTL"><a href="#RabbitMQ-中的-TTL" class="headerlink" title="RabbitMQ  中的 TTL"></a>RabbitMQ  中的 TTL</h3><p>TTL 是什么呢？TTL 是 RabbitMQ 中一个消息或者队列的属性，表明一条消息或者该队列中的所有消息的最大存活时间，单位是毫秒。换句话说，如果一条消息设置了 TTL 属性或者进入了设置 TTL 属性的队列，那么这条消息如果在 TTL 设置的时间内没有被消费，则会成为”死信”。如果同时配置了队列的 TTL 和消息的TTL，那么较小的那个值将会被使用，有两种方式设置 TTL。</p><h4 id="消息设置-TTL"><a href="#消息设置-TTL" class="headerlink" title="消息设置 TTL"></a>消息设置 TTL</h4><p>另一种方式便是针对每条消息设置 TTL</p><p><img src="/images/studyNote/rabbitMQ/20210911_03858.png"></p><h4 id="队列设置-TTL"><a href="#队列设置-TTL" class="headerlink" title="队列设置 TTL"></a>队列设置 TTL</h4><p>第一种是在创建队列的时候设置队列的“x-message-ttl”属性</p><p><img src="/images/studyNote/rabbitMQ/20210911_04019.png"></p><h4 id="两者的区别"><a href="#两者的区别" class="headerlink" title="两者的区别"></a>两者的区别</h4><p>如果设置了队列的 TTL 属性，那么一旦消息过期，就会被队列丢弃(如果配置了死信队列被丢到死信队列中)，而第二种方式，消息即使过期，也不一定会被马上丢弃，因为消息是否过期是在即将投递到消费者之前判定的，如果当前队列有严重的消息积压情况，则已过期的消息也许还能存活较长时间；另外，还需要注意的一点是，如果不设置 TTL，表示消息永远不会过期，如果将 TTL 设置为 0，则表示除非此时可以直接投递该消息到消费者，否则该消息将会被丢弃。</p><p>前一小节我们介绍了死信队列，刚刚又介绍了 TTL，至此利用 RabbitMQ 实现延时队列的两大要素已经集齐，接下来只需要将它们进行融合，再加入一点点调味料，延时队列就可以新鲜出炉了。想想看，延时队列，不就是想要消息延迟多久被处理吗，<strong>TTL 则刚好能让消息在延迟多久之后成为死信</strong>，另一方面，成为死信的消息都会被投递到死信队列里，这样只需要消费者一直消费死信队列里的消息就完事了，因为里面的消息都是希望被立即处理的消息。</p><h2 id="整合SpringBoot"><a href="#整合SpringBoot" class="headerlink" title="整合SpringBoot"></a>整合SpringBoot</h2><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--RabbitMQ 依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--swagger--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--RabbitMQ 测试依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.amqp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-rabbit-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.rabbitmq.host</span>=<span class="string">127.0.0.1</span></span><br><span class="line"><span class="meta">spring.rabbitmq.port</span>=<span class="string">5672</span></span><br><span class="line"><span class="meta">spring.rabbitmq.username</span>=<span class="string">admin</span></span><br><span class="line"><span class="meta">spring.rabbitmq.password</span>=<span class="string">123</span></span><br></pre></td></tr></table></figure><h3 id="死信队列实现延迟MQ"><a href="#死信队列实现延迟MQ" class="headerlink" title="死信队列实现延迟MQ"></a>死信队列实现延迟MQ</h3><p>创建两个队列 QA 和 QB，两者队列 TTL 分别设置为 10S 和 40S，然后在创建一个交换机 X 和死信交换机 Y，它们的类型都是 direct，创建一个死信队列 QD，它们的绑定关系如下：</p><p><img src="/images/studyNote/rabbitMQ/20210911_04954.png"></p><h4 id="配置文件类代码"><a href="#配置文件类代码" class="headerlink" title="配置文件类代码"></a>配置文件类代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TtlQueueConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String X_EXCHANGE = <span class="string">&quot;X&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_A = <span class="string">&quot;QA&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_B = <span class="string">&quot;QB&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String Y_DEAD_LETTER_EXCHANGE = <span class="string">&quot;Y&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEAD_LETTER_QUEUE = <span class="string">&quot;QD&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  声明 xExchange</span></span><br><span class="line">    <span class="meta">@Bean(&quot;xExchange&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DirectExchange <span class="title">xExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(X_EXCHANGE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  声明 xExchange</span></span><br><span class="line">    <span class="meta">@Bean(&quot;yExchange&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DirectExchange <span class="title">yExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(Y_DEAD_LETTER_EXCHANGE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明队列 A ttl 为 10s 并绑定到对应的死信交换机</span></span><br><span class="line">    <span class="meta">@Bean(&quot;queueA&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queueA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; args = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 声明当前队列绑定的死信交换机</span></span><br><span class="line">        args.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, Y_DEAD_LETTER_EXCHANGE);</span><br><span class="line">        <span class="comment">// 声明当前队列的死信路由 key</span></span><br><span class="line">        args.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;YD&quot;</span>);</span><br><span class="line">        <span class="comment">// 声明队列的 TTL</span></span><br><span class="line">        args.put(<span class="string">&quot;x-message-ttl&quot;</span>, <span class="number">10000</span>);</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(QUEUE_A).withArguments(args).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  声明队列 A 绑定 X 交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">queueaBindingX</span><span class="params">(<span class="meta">@Qualifier(&quot;queueA&quot;)</span> Queue queueA,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="meta">@Qualifier(&quot;xExchange&quot;)</span> DirectExchange xExchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueA).to(xExchange).with(<span class="string">&quot;XA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明队列 B ttl 为 40s 并绑定到对应的死信交换机</span></span><br><span class="line">    <span class="meta">@Bean(&quot;queueB&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queueB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; args = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 声明当前队列绑定的死信交换机</span></span><br><span class="line">        args.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, Y_DEAD_LETTER_EXCHANGE);</span><br><span class="line">        <span class="comment">// 声明当前队列的死信路由 key</span></span><br><span class="line">        args.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;YD&quot;</span>);</span><br><span class="line">        <span class="comment">// 声明队列的 TTL</span></span><br><span class="line">        args.put(<span class="string">&quot;x-message-ttl&quot;</span>, <span class="number">40000</span>);</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(QUEUE_B).withArguments(args).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明队列 B 绑定 X 交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">queuebBindingX</span><span class="params">(<span class="meta">@Qualifier(&quot;queueB&quot;)</span> Queue queue1B,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="meta">@Qualifier(&quot;xExchange&quot;)</span> DirectExchange xExchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue1B).to(xExchange).with(<span class="string">&quot;XB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明死信队列 QD</span></span><br><span class="line">    <span class="meta">@Bean(&quot;queueD&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queueD</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(DEAD_LETTER_QUEUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明死信队列 QD 绑定关系</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">deadLetterBindingQAD</span><span class="params">(<span class="meta">@Qualifier(&quot;queueD&quot;)</span> Queue queueD,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="meta">@Qualifier(&quot;yExchange&quot;)</span> DirectExchange yExchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueD).to(yExchange).with(<span class="string">&quot;YD&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="生产者代码"><a href="#生产者代码" class="headerlink" title="生产者代码"></a>生产者代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;ttl&quot;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendMsgController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;sendMsg/&#123;message&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">(<span class="meta">@PathVariable</span> String message)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot; 当前时间：&#123;&#125;, 发送一条信息给两个 TTL  队列:&#123;&#125;&quot;</span>, <span class="keyword">new</span> Date(), message);</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;X&quot;</span>, <span class="string">&quot;XA&quot;</span>, <span class="string">&quot; 消息来自 ttl 为 为 10S  的队列: &quot;</span> + message);</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;X&quot;</span>, <span class="string">&quot;XB&quot;</span>, <span class="string">&quot; 消息来自 ttl 为 为 40S  的队列: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="消费者代码"><a href="#消费者代码" class="headerlink" title="消费者代码"></a>消费者代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLetterQueueConsumer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;QD&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveD</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String msg = <span class="keyword">new</span> String(message.getBody());</span><br><span class="line">        log.info(<span class="string">&quot; 当前时间：&#123;&#125;, 收到死信队列信息&#123;&#125;&quot;</span>, <span class="keyword">new</span> Date().toString(), msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一条消息在 10S 后变成了死信消息，然后被消费者消费掉，第二条消息在 40S 之后变成了死信消息，然后被消费掉，这样一个延时队列就打造完成了。<br>不过，如果这样使用的话，岂不是<strong>每增加一个新的时间需求，就要新增一个队列</strong>，这里只有 10S 和 40S两个时间选项，如果需要一个小时后处理，那么就需要增加 TTL 为一个小时的队列，如果是预定会议室然后提前通知这样的场景，岂不是要增加无数个队列才能满足需求？</p><h4 id="延时队列优化"><a href="#延时队列优化" class="headerlink" title="延时队列优化"></a>延时队列优化</h4><p>在这里新增了一个队列 QC,绑定关系如下,该队列不设置 TTL 时间</p><p><img src="/images/studyNote/rabbitMQ/20210911_10712.png"></p><p>看起来似乎没什么问题，但是在最开始的时候，就介绍过如果使用在消息属性上设置 TTL 的方式，消息可能并不会按时“死亡“，<strong>因为 RabbitMQ 只会检查第一个消息是否过期</strong>，如果过期则丢到死信队列，<font color=red >如果第一个消息的延时时长很长，而第二个消息的延时时长很短，第二个消息并不会优先得到执行。</font> </p><h3 id="Rabbitmq插件实现延迟队列"><a href="#Rabbitmq插件实现延迟队列" class="headerlink" title="Rabbitmq插件实现延迟队列"></a>Rabbitmq插件实现延迟队列</h3><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><ol><li><a href="https://www.jianshu.com/p/451958b1adca">SpringBoot+RabbitMQ用死信队列和插件形式实现延迟队列</a> </li><li><a href="https://www.cnblogs.com/geekdc/p/13549613.html">Docker安装Rabbitmq及其延时队列插件</a> </li></ol><h4 id="安装延时队列插件"><a href="#安装延时队列插件" class="headerlink" title="安装延时队列插件"></a>安装延时队列插件</h4><p><a href="https://www.rabbitmq.com/community-plugins.html">在官网</a> ，下载<a href="https://github.com/rabbitmq/rabbitmq-delayed-message-exchange/releases/tag/v3.8.0">rabbitmq_delayed_message_exchange</a>插件，然后解压放置到 RabbitMQ 的插件目录。进入 RabbitMQ 的安装目录下的 plgins 目录，执行下面命令让该插件生效，然后重启 RabbitMQ</p><ul><li>/usr/lib/rabbitmq/lib/rabbitmq_server-3.8.8/plugins</li><li>rabbitmq-plugins enable rabbitmq_delayed_message_exchange</li></ul><p><img src="/images/studyNote/rabbitMQ/20210911_11230.png"></p><h2 id="发布确认高级姿势"><a href="#发布确认高级姿势" class="headerlink" title="发布确认高级姿势"></a>发布确认高级姿势</h2><p>在生产环境中由于一些不明原因，导致 rabbitmq 重启，在 RabbitMQ 重启期间生产者消息投递失败，导致消息丢失，需要手动处理和恢复。于是，我们开始思考，如何才能进行 RabbitMQ 的消息可靠投递呢？特别是在这样比较极端的情况，RabbitMQ 集群不可用的时候，无法投递的消息该如何处理呢:</p><h3 id="发布确认-springboot-版本"><a href="#发布确认-springboot-版本" class="headerlink" title="发布确认 springboot 版本"></a>发布确认 springboot 版本</h3><h4 id="确认机制方案"><a href="#确认机制方案" class="headerlink" title="确认机制方案"></a>确认机制方案</h4><p><img src="/images/studyNote/rabbitMQ/20210911_11918.png"></p><h4 id="代码架构图-1"><a href="#代码架构图-1" class="headerlink" title="代码架构图"></a>代码架构图</h4><p><img src="/images/studyNote/rabbitMQ/20210911_11958.png"></p><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在配置文件当中需要添加</span></span><br><span class="line"><span class="meta">spring.rabbitmq.publisher-confirm-type</span>=<span class="string">correlated</span></span><br></pre></td></tr></table></figure><ul><li>NONE：禁用发布确认模式，是默认值</li><li>CORRELATED：发布消息成功到交换器后会触发回调方法</li><li>SIMPLE：经测试有两种效果，其一效果和 CORRELATED 值一样会触发回调方法，其二在发布消息成功后使用 rabbitTemplate 调用 waitForConfirms 或 waitForConfirmsOrDie 方法等待 broker 节点返回发送结果，根据返回结果来判定下一步的逻辑，要注意的点是 waitForConfirmsOrDie 方法如果返回 false 则会关闭 channel，则接下来无法发送消息到 broker，注：此配置同步确认消息，生产不建议使用</li></ul><h4 id="交换机发布确认代码"><a href="#交换机发布确认代码" class="headerlink" title="交换机发布确认代码"></a>交换机发布确认代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageConfirmCallBack</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">RabbitTemplate</span>.<span class="title">ConfirmCallback</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        rabbitTemplate.setConfirmCallback(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换机确认回调方法 (发布者发送消息是否到交换机触发回调)</span></span><br><span class="line"><span class="comment">     * 1. 发消息 交换机接收到消息，回调</span></span><br><span class="line"><span class="comment">     * 1.1 correlationData 保存毁掉消息的id及相关信息</span></span><br><span class="line"><span class="comment">     * 1.2 交换机接收到消息 true</span></span><br><span class="line"><span class="comment">     * 1.3 失败原因-null</span></span><br><span class="line"><span class="comment">     * 2. 发消息 交换机接收失败 回调</span></span><br><span class="line"><span class="comment">     * 2.1 correlationData 保存毁掉消息的id及相关信息</span></span><br><span class="line"><span class="comment">     * 2.2 false</span></span><br><span class="line"><span class="comment">     * 2.3 失败原因</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirm</span><span class="params">(CorrelationData correlationData, <span class="keyword">boolean</span> ack, String cause)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (ack) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;发布确认:交换机收到消息id：&#123;&#125;&quot;</span>, correlationData.getId());</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;发布确认:交换机未收到消息，id为：&#123;&#125;,原因：&#123;&#125;&quot;</span>, correlationData.getId(), cause);</span><br><span class="line">              <span class="comment">// TODO 保存数据库重新发送等逻辑保证消息重新发送给交换机</span></span><br><span class="line">          &#125; </span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="回退消息"><a href="#回退消息" class="headerlink" title="回退消息"></a>回退消息</h3><p><strong>在仅开启了生产者确认机制的情况下，交换机接收到消息后，会直接给消息生产者发送确认消息，如果发现该消息不可路由，那么消息会被直接丢弃，此时生产者是不知道消息被丢弃这个事件的。</strong>那么如何让无法被路由的消息帮我想办法处理一下？最起码通知我一声，我好自己处理啊。通过设置 mandatory 参数可以在当消息传递过程中不可达目的地时将消息<strong>返回给生产者。</strong></p><h4 id="添加配置"><a href="#添加配置" class="headerlink" title="添加配置"></a>添加配置</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 消息回退配置，如果消息无法路由，则回退给生产者</span></span><br><span class="line"><span class="meta">spring.rabbitmq.publisher-returns</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure><h4 id="回退代码演示"><a href="#回退代码演示" class="headerlink" title="回退代码演示"></a>回退代码演示</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageReturnCallBack</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">RabbitTemplate</span>.<span class="title">ReturnCallback</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        rabbitTemplate.setReturnCallback(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可以将消息传递过程中不可达到目的地(队列)的消息返回给生产者</span></span><br><span class="line"><span class="comment">     * 只有不可达 才会回退消息</span></span><br><span class="line"><span class="comment">     * 请注意!!!如果你使用了延迟队列插件，那么一定会调用该callback方法，因为数据并没有提交上去，</span></span><br><span class="line"><span class="comment">     * 而是提交在交换器中，过期时间到了才提交上去，并非是bug！你可以用if进行判断交换机名称来捕捉该报错</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnedMessage</span><span class="params">(Message message, <span class="keyword">int</span> replyCode, String replyText, String exchange, String routingKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(exchange.equals(delayedQueueProperties.getDelayedExchangeName()))&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;消息&#123;&#125;，被交换机&#123;&#125;退回，退回原因：&#123;&#125;，路由Key：&#123;&#125;&quot;</span>, <span class="keyword">new</span> String(message.getBody()), exchange, replyText, routingKey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="备份交换机"><a href="#备份交换机" class="headerlink" title="备份交换机"></a>备份交换机</h3><p>有了 mandatory 参数和回退消息，我们获得了对无法投递消息的感知能力，有机会在生产者的消息无法被投递时发现并处理。但有时候，我们并不知道该如何处理这些无法路由的消息，最多打个日志，然后触发报警，再来手动处理。而通过日志来处理这些无法路由的消息是很不优雅的做法，特别是当生产者所在的服务有多台机器的时候，手动复制日志会更加麻烦而且容易出错。而且设置 mandatory 参数会增加生产者的复杂性，需要添加处理这些被退回的消息的逻辑。如果既不想丢失消息，又不想增加生产者的复杂性，该怎么做呢？前面在设置死信队列的文章中，我们提到，可以为队列设置死信交换机来存储那些处理失败的消息，可是这些不可路由消息根本没有机会进入到队列，因此无法使用死信队列来保存消息。在 RabbitMQ 中，有一种备份交换机的机制存在，可以很好的应对这个问题。什么是备份交换机呢？备份交换机可以理解为 RabbitMQ 中交换机的“备胎”，当我们为某一个交换机声明一个对应的备份交换机时，就是为它创建一个备胎，当交换机接收到一条不可路由消息时，将会把这条消息转发到备份交换机中，由备份交换机来进行转发和处理，通常备份交换机的类型为 Fanout ，这样就能把所有消息都投递到与其绑定的队列中，然后我们在备份交换机下绑定一个队列，这样所有那些原交换机无法被路由的消息，就会都进入这个队列了。当然，我们还可以建立一个报警队列，用独立的消费者来进行监测和报警。</p><p><img src="/images/studyNote/rabbitMQ/20210912_01328.png"></p><h4 id="备份交换机代码声明"><a href="#备份交换机代码声明" class="headerlink" title="备份交换机代码声明"></a>备份交换机代码声明</h4><p>在原来的代码上面多声明一个交换机和两个队列，还有一个报警消费者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfirmConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONFIRM_EXCHANGE_NAME = <span class="string">&quot;confirm.exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONFIRM_QUEUE_NAME = <span class="string">&quot;confirm.queue&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BACKUP_EXCHANGE_NAME = <span class="string">&quot;backup.exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BACKUP_QUEUE_NAME = <span class="string">&quot;backup.queue&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String WARNING_QUEUE_NAME = <span class="string">&quot;warning.queue&quot;</span>;</span><br><span class="line">    <span class="comment">//  声明确认队列</span></span><br><span class="line">    <span class="meta">@Bean(&quot;confirmQueue&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">confirmQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(CONFIRM_QUEUE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 声明确认队列绑定关系</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">queueBinding</span><span class="params">(<span class="meta">@Qualifier(&quot;confirmQueue&quot;)</span> Queue queue,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="meta">@Qualifier(&quot;confirmExchange&quot;)</span> DirectExchange exchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="string">&quot;key1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 声明备份 Exchange</span></span><br><span class="line">    <span class="meta">@Bean(&quot;backupExchange&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FanoutExchange <span class="title">backupExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FanoutExchange(BACKUP_EXCHANGE_NAME);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 声明确认 Exchange 交换机的备份交换机</span></span><br><span class="line">    <span class="meta">@Bean(&quot;confirmExchange&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DirectExchange <span class="title">confirmExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ExchangeBuilder exchangeBuilder =</span><br><span class="line">                ExchangeBuilder.directExchange(CONFIRM_EXCHANGE_NAME)</span><br><span class="line">                        .durable(<span class="keyword">true</span>)</span><br><span class="line">                        <span class="comment">// 设置该交换机的备份交换机</span></span><br><span class="line">                        .withArgument(<span class="string">&quot;alternate-exchange&quot;</span>, BACKUP_EXCHANGE_NAME);</span><br><span class="line">        <span class="keyword">return</span> (DirectExchange) exchangeBuilder.build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  声明警告队列</span></span><br><span class="line">    <span class="meta">@Bean(&quot;warningQueue&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">warningQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(WARNING_QUEUE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  声明报警队列绑定关系</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">warningBinding</span><span class="params">(<span class="meta">@Qualifier(&quot;warningQueue&quot;)</span> Queue queue,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="meta">@Qualifier(&quot;backupExchange&quot;)</span> FanoutExchange</span></span></span><br><span class="line"><span class="params"><span class="function">                                          backupExchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(backupExchange);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  声明备份队列</span></span><br><span class="line">    <span class="meta">@Bean(&quot;backQueue&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">backQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(BACKUP_QUEUE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  声明备份队列绑定关系</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">backupBinding</span><span class="params">(<span class="meta">@Qualifier(&quot;backQueue&quot;)</span> Queue queue,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="meta">@Qualifier(&quot;backupExchange&quot;)</span> FanoutExchange backupExchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(backupExchange);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="报警消费者"><a href="#报警消费者" class="headerlink" title="报警消费者"></a>报警消费者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WarningConsumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String WARNING_QUEUE_NAME = <span class="string">&quot;warning.queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = WARNING_QUEUE_NAME)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveWarningMsg</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        String msg = <span class="keyword">new</span> String(message.getBody());</span><br><span class="line">        log.error(<span class="string">&quot; 报警发现不可路由消息：&#123;&#125;&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试注意事项</strong></p><p>重新启动项目的时候需要把原来的 confirm.exchange 删除因为我们修改了其绑定属性，不然报错。</p><h4 id="备份交换机和回退优先级"><a href="#备份交换机和回退优先级" class="headerlink" title="备份交换机和回退优先级"></a>备份交换机和回退优先级</h4><p>mandatory 参数与备份交换机可以一起使用的时候，如果两者同时开启，消息究竟何去何从？谁优先级高，经过上面结果显示答案是备份交换机优先级高。</p><h2 id="RabbitMQ其他知识点"><a href="#RabbitMQ其他知识点" class="headerlink" title="RabbitMQ其他知识点"></a>RabbitMQ其他知识点</h2><h3 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a>幂等性</h3><p>用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用。举个最简单的例子，那就是支付，用户购买商品后支付，支付扣款成功，但是返回结果的时候网络异常，此时钱已经扣了，用户再次点击按钮，此时会进行第二次扣款，返回结果成功，用户查询余额发现多扣钱了，流水记录也变成了两条。在以前的单应用系统中，我们只需要把数据操作放入事务中即可，发生错误立即回滚，但是再响应客户端的时候也有可能出现网络中断或者异常等等</p><h4 id="消息重复消费"><a href="#消息重复消费" class="headerlink" title="消息重复消费"></a>消息重复消费</h4><p>消费者在消费 MQ 中的消息时，MQ 已把消息发送给消费者，消费者在给 MQ 返回 ack 时网络中断，故 MQ 未收到确认信息，该条消息会重新发给其他的消费者，或者在网络重连后再次发送给该消费者，但实际上该消费者已成功消费了该条消息，造成消费者消费了重复的消息。</p><h4 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h4><p>MQ 消费者的幂等性的解决一般使用全局 ID 或者写个唯一标识比如时间戳 或者 UUID 或者订单消费者消费 MQ 中的消息也可利用 MQ 的该 id 来判断，或者可按自己的规则生成一个全局唯一 id，每次消费消息时用该 id 先判断该消息是否已消费过。</p><h4 id="消费端的幂等性保障"><a href="#消费端的幂等性保障" class="headerlink" title="消费端的幂等性保障"></a>消费端的幂等性保障</h4><p>在海量订单生成的业务高峰期，生产端有可能就会重复发生了消息，这时候消费端就要实现幂等性，这就意味着我们的消息永远不会被消费多次，即使我们收到了一样的消息。业界主流的幂等性有两种操作:a.唯一 ID+指纹码机制,利用数据库主键去重, b.利用 redis 的原子性去实现</p><h4 id="唯一ID-指纹码机制"><a href="#唯一ID-指纹码机制" class="headerlink" title="唯一ID+ 指纹码机制"></a>唯一ID+ 指纹码机制</h4><p>指纹码:我们的一些规则或者时间戳加别的服务给到的唯一信息码,它并不一定是我们系统生成的，基本都是由我们的业务规则拼接而来，但是一定要保证唯一性，然后就利用查询语句进行判断这个 id 是否存在数据库中,优势就是实现简单就一个拼接，然后查询判断是否重复；劣势就是在高并发时，如果是单个数据库就会有写入性能瓶颈当然也可以采用分库分表提升性能，但也不是我们最推荐的方式。</p><h4 id="Redis原子性"><a href="#Redis原子性" class="headerlink" title="Redis原子性"></a>Redis原子性</h4><p>利用 redis 执行 setnx 命令，天然具有幂等性。从而实现不重复消费，此方式为目前用的最多的方案。</p><h3 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h3><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>在我们系统中有一个订单催付的场景，我们的客户在天猫下的订单,淘宝会及时将订单推送给我们，如果在用户设定的时间内未付款那么就会给用户推送一条短信提醒，很简单的一个功能对吧，但是，tmall商家对我们来说，肯定是要分大客户和小客户的对吧，比如像苹果，小米这样大商家一年起码能给我们创造很大的利润，所以理应当然，他们的订单必须得到优先处理，而曾经我们的后端系统是使用 redis 来存放的定时轮询，大家都知道 redis 只能用 List 做一个简简单单的消息队列，并不能实现一个优先级的场景，所以订单量大了后采用 RabbitMQ 进行改造和优化,如果发现是大客户的订单给一个相对比较高的优先级，否则就是默认优先级。</p><h4 id="如何添加"><a href="#如何添加" class="headerlink" title="如何添加"></a>如何添加</h4><p>a.控制台页面添加</p><p><img src="/images/studyNote/rabbitMQ/20210912_02829.png"></p><p>b.队列中代码添加优先级</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; params = <span class="keyword">new</span> HashMap();</span><br><span class="line">params.put(<span class="string">&quot;x-max-priority&quot;</span>, <span class="number">10</span>);</span><br><span class="line">channel.queueDeclare(<span class="string">&quot;hello&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, params);</span><br></pre></td></tr></table></figure><p><img src="/images/studyNote/rabbitMQ/20210912_03043.png"></p><p>c.消息中代码添加优先级</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AMQP.BasicProperties  properties  =  <span class="keyword">new</span> AMQP.BasicProperties().builder().priority(<span class="number">5</span>).build();</span><br></pre></td></tr></table></figure><p>d.<font color=red >注意事项</font> </p><p>要让队列实现优先级需要做的事情有如下事情:<strong>队列需要设置为优先级队列，消息需要设置消息的优先级</strong>，消费者需要等待消息已经发送到队列中才去消费因为，这样才有机会对消息进行排序</p><h4 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h4><h5 id="生产者-1"><a href="#生产者-1" class="headerlink" title="生产者"></a>生产者</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (Channel channel = RabbitMqUtils.getChannel();) &#123;</span><br><span class="line">            <span class="comment">// 给消息赋予一个 priority 属性</span></span><br><span class="line">            AMQP.BasicProperties properties = <span class="keyword">new</span></span><br><span class="line">                    AMQP.BasicProperties().builder().priority(<span class="number">5</span>).build();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">                String message = <span class="string">&quot;info&quot;</span> + i;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">5</span>) &#123;</span><br><span class="line">                    channel.basicPublish(<span class="string">&quot;&quot;</span>, QUEUE_NAME, properties, message.getBytes());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    channel.basicPublish(<span class="string">&quot;&quot;</span>, QUEUE_NAME, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot; 发送消息完成:&quot;</span> + message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="消费者-2"><a href="#消费者-2" class="headerlink" title="消费者"></a>消费者</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line">        <span class="comment">// 设置队列的最大优先级 最大可以设置到 255  官网推荐 1-10 如果设置太高比较吃内存和 CPU</span></span><br><span class="line">        Map&lt;String, Object&gt; params = <span class="keyword">new</span> HashMap();</span><br><span class="line">        params.put(<span class="string">&quot;x-max-priority&quot;</span>, <span class="number">10</span>);</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, params);</span><br><span class="line">        System.out.println(<span class="string">&quot; 消费者启动等待消费......&quot;</span>);</span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            String receivedMessage = <span class="keyword">new</span> String(delivery.getBody());</span><br><span class="line">            System.out.println(<span class="string">&quot; 接收到消息:&quot;</span> + receivedMessage);</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, deliverCallback, (consumerTag) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot; 消费者无法消费 消息时调用，如队列被删除&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="惰性队列"><a href="#惰性队列" class="headerlink" title="惰性队列"></a>惰性队列</h3><p>RabbitMQ 从 3.6.0 版本开始引入了惰性队列的概念。惰性队列会尽可能的将消息存入磁盘中，而在消费者消费到相应的消息时才会被加载到内存中，它的一个重要的设计目标是能够支持更长的队列，即支持更多的消息存储。<strong>当消费者由于各种各样的原因(比如消费者下线、宕机亦或者是由于维护而关闭等)而致使长时间内不能消费消息造成堆积时，惰性队列就很有必要了。</strong><br>默认情况下，当生产者将消息发送到 RabbitMQ 的时候，队列中的消息会尽可能的存储在内存之中，这样可以更加快速的将消息发送给消费者。即使是持久化的消息，在被写入磁盘的同时也会在内存中驻留一份备份。当 RabbitMQ 需要释放内存的时候，会将内存中的消息换页至磁盘中，这个操作会耗费较长的时间，也会阻塞队列的操作，进而无法接收新的消息。虽然 RabbitMQ 的开发者们一直在升级相关的算法，但是效果始终不太理想，尤其是在消息量特别大的时候。</p><h4 id="两种模式"><a href="#两种模式" class="headerlink" title="两种模式"></a>两种模式</h4><p>队列具备两种模式：default 和 lazy。默认的为 default 模式，在 3.6.0 之前的版本无需做任何变更。lazy模式即为惰性队列的模式，可以通过调用 channel.queueDeclare 方法的时候在参数中设置，也可以通过Policy 的方式设置，如果一个队列同时使用这两种方式设置的话，那么 Policy 的方式具备更高的优先级。如果要通过声明的方式改变已有队列的模式的话，那么只能先删除队列，然后再重新声明一个新的。<br>在队列声明的时候可以通过“x-queue-mode”参数来设置队列的模式，取值为“default”和“lazy”。下面示<br>例中演示了一个惰性队列的声明细节：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; args = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">args.put(<span class="string">&quot;x-queue-mode&quot;</span>, <span class="string">&quot;lazy&quot;</span>);</span><br><span class="line">channel.queueDeclare(<span class="string">&quot;myqueue&quot;</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, args);</span><br></pre></td></tr></table></figure><h4 id="内存开销对比"><a href="#内存开销对比" class="headerlink" title="内存开销对比"></a>内存开销对比</h4><p><img src="/images/studyNote/rabbitMQ/20210912_04201.png"></p><p>在发送 1 百万条消息，每条消息大概占 1KB 的情况下，普通队列占用内存是 1.2GB，而惰性队列仅仅占用 1.5MB</p><h2 id="RabbitMQ-集群"><a href="#RabbitMQ-集群" class="headerlink" title="RabbitMQ 集群"></a>RabbitMQ 集群</h2><h3 id="clustering集群模式"><a href="#clustering集群模式" class="headerlink" title="clustering集群模式"></a>clustering集群模式</h3><h4 id="使用集群的原因"><a href="#使用集群的原因" class="headerlink" title="使用集群的原因"></a>使用集群的原因</h4><p>最开始我们介绍了如何安装及运行 RabbitMQ 服务，不过这些是单机版的，无法满足目前真实应用的要求。如果 RabbitMQ 服务器遇到内存崩溃、机器掉电或者主板故障等情况，该怎么办？单台 RabbitMQ服务器可以满足每秒 1000 条消息的吞吐量，那么如果应用需要 RabbitMQ 服务满足每秒 10 万条消息的吞吐量呢？购买昂贵的服务器来增强单机 RabbitMQ 务的性能显得捉襟见肘，搭建一个 RabbitMQ 集群才是解决实际问题的关键。</p><h4 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h4><p><strong>1.修改 3 台机器的主机名称</strong></p><p>vim /etc/hostname</p><p><strong>2.配置各个节点的 hosts 文件，让各个节点都能互相识别对方</strong></p><p>vim /etc/hosts<br>10.211.55.74 node1<br>10.211.55.75 node2<br>10.211.55.76 node3</p><p><img src="/images/studyNote/rabbitMQ/20210912_105900.png"></p><p><strong>3.以确保各个节点的 cookie 文件使用的是同一个值</strong></p><p>在 node1 上执行远程操作命令<br>scp /var/lib/rabbitmq/.erlang.cookie root@node2:/var/lib/rabbitmq/.erlang.cookie<br>scp /var/lib/rabbitmq/.erlang.cookie root@node3:/var/lib/rabbitmq/.erlang.cookie</p><p><strong>4.启动 RabbitMQ 服务,顺带启动 Erlang 虚拟机和 RbbitMQ 应用服务(在三台节点上分别执行以下命令)</strong></p><p><code>rabbitmq-server -detached</code></p><p><strong>5.在节点 2 执行</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl stop_app (rabbitmqctl stop 会将 Erlang 虚拟机关闭，rabbitmqctl stop_app 只关闭 RabbitMQ 服务)</span><br><span class="line">rabbitmqctl reset</span><br><span class="line">rabbitmqctl join_cluster rabbit@node1</span><br><span class="line">rabbitmqctl start_app(只启动应用服务)</span><br></pre></td></tr></table></figure><p><strong>6.在节点 3 执行</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl stop_app</span><br><span class="line">rabbitmqctl reset</span><br><span class="line">rabbitmqctl join_cluster rabbit@node2</span><br><span class="line">rabbitmqctl start_app</span><br></pre></td></tr></table></figure><p><strong>7.集群状态</strong></p><p><code>rabbitmqctl cluster_status</code></p><p><strong>8.需要重新设置用户</strong></p><p>创建账号<br><code>rabbitmqctl add_user admin 123</code><br>设置用户角色<br><code>rabbitmqctl set_user_tags admin administrator</code><br>设置用户权限<br><code>rabbitmqctl set_permissions -p &quot;/&quot; admin &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</code></p><p><strong>9.解除集群节点(node2 和 node3 机器分别执行)</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl stop_app</span><br><span class="line">rabbitmqctl reset</span><br><span class="line">rabbitmqctl start_app</span><br><span class="line">rabbitmqctl cluster_status</span><br><span class="line">rabbitmqctl forget_cluster_node rabbit@node2(node1 机器上执行)</span><br></pre></td></tr></table></figure><h3 id="镜像队列"><a href="#镜像队列" class="headerlink" title="镜像队列"></a>镜像队列</h3><h4 id="使用镜像的原因"><a href="#使用镜像的原因" class="headerlink" title="使用镜像的原因"></a>使用镜像的原因</h4><p>如果 RabbitMQ 集群中只有一个 Broker 节点，那么该节点的失效将导致整体服务的临时性不可用，并且也可能会导致消息的丢失。可以将所有消息都设置为持久化，并且对应队列的durable属性也设置为true，但是这样仍然无法避免由于缓存导致的问题：因为消息在发送之后和被写入磁盘井执行刷盘动作之间存在一个短暂却会产生问题的时间窗。通过 publisherconfirm 机制能够确保客户端知道哪些消息己经存入磁盘，尽管如此，一般不希望遇到因单点故障导致的服务不可用。<br>引入镜像队列(Mirror Queue)的机制，可以将队列镜像到集群中的其他 Broker 节点之上，如果集群中的一个节点失效了，队列能自动地切换到镜像中的另一个节点上以保证服务的可用性。</p><h4 id="搭建步骤-1"><a href="#搭建步骤-1" class="headerlink" title="搭建步骤"></a>搭建步骤</h4><p><strong>1.启动三台集群节点</strong></p><p><strong>2.随便找一个节点添加 policy</strong></p><p><img src="/images/studyNote/rabbitMQ/20210912_121053.png"></p><p><strong>3.在 node1 上创建一个队列发送一条消息，队列存在镜像队列</strong></p><p><img src="/images/studyNote/rabbitMQ/20210912_121220.png"></p><p><strong>4.停掉 node1 之后发现 node2 成为镜像队列</strong></p><p><img src="/images/studyNote/rabbitMQ/20210912_121348.png"></p><p><strong>5.就算整个集群只剩下一台机器了 依然能消费队列里面的消息</strong></p><p>说明队列里面的消息被镜像队列传递到相应机器里面了</p><h3 id="实现高可用负载均衡"><a href="#实现高可用负载均衡" class="headerlink" title="实现高可用负载均衡"></a>实现高可用负载均衡</h3><h4 id="整体架构图"><a href="#整体架构图" class="headerlink" title="整体架构图"></a>整体架构图</h4><p><img src="/images/studyNote/rabbitMQ/20210912_121820.png"></p><h4 id="Haproxy-实现负载均衡"><a href="#Haproxy-实现负载均衡" class="headerlink" title="Haproxy 实现负载均衡"></a>Haproxy 实现负载均衡</h4><p>HAProxy 提供高可用性、负载均衡及基于 TCPHTTP 应用的代理，支持虚拟主机，它是免费、快速并且可靠的一种解决方案，包括 Twitter,Reddit,StackOverflow,GitHub 在内的多家知名互联网公司在使用。HAProxy 实现了一种事件驱动、单一进程模型，此模型支持非常大的井发连接数。</p><p>扩展 nginx,lvs,haproxy 之间的区别: <a href="http://www.ha97.com/5646.html">http://www.ha97.com/5646.html</a></p><h4 id="Keepalived实现双机"><a href="#Keepalived实现双机" class="headerlink" title="Keepalived实现双机"></a>Keepalived实现双机</h4><p>试想如果前面配置的 HAProxy 主机突然宕机或者网卡失效，那么虽然 RbbitMQ 集群没有任何故障但是对于外界的客户端来说所有的连接都会被断开结果将是灾难性的为了确保负载均衡服务的可靠性同样显得十分重要，这里就要引入 Keepalived 它能够通过自身健康检查、资源接管功能做高可用(双机热备)，实现故障转移。</p><h3 id="Federation-Exchange"><a href="#Federation-Exchange" class="headerlink" title="Federation Exchange"></a>Federation Exchange</h3><p>​        (broker 北京)，(broker 深圳)彼此之间相距甚远，网络延迟是一个不得不面对的问题。有一个在北京的业务(Client 北京) 需要连接(broker 北京)，向其中的交换器 exchangeA 发送消息，此时的网络延迟很小，(Client 北京)可以迅速将消息发送至 exchangeA 中，就算在开启了 publisherconfirm 机制或者事务机制的情况下，也可以迅速收到确认信息。此时又有个在深圳的业务(Client 深圳)需要向 exchangeA 发送消息，那么(Client 深圳) (broker 北京)之间有很大的网络延迟，(Client 深圳) 将发送消息至 exchangeA 会经历一定的延迟，尤其是在开启了 publisherconfirm 机制或者事务机制的情况下，(Client 深圳) 会等待很长的延迟时间来接收(broker 北京)的确认信息，进而必然造成这条发送线程的性能降低，甚至造成一定程度上的阻塞。<br>​        将业务(Client 深圳)部署到北京的机房可以解决这个问题，但是如果(Client 深圳)调用的另些服务都部署在深圳，那么又会引发新的时延问题，总不见得将所有业务全部部署在一个机房，那么容灾又何以实现？这里使用 Federation 插件就可以很好地解决这个问题.</p><h4 id="搭建步骤-2"><a href="#搭建步骤-2" class="headerlink" title="搭建步骤"></a>搭建步骤</h4><p><strong>1.需要保证每台节点单独运行</strong></p><p><strong>2.在每台机器上开启 federation 相关插件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins enable rabbitmq_federation</span><br><span class="line">rabbitmq-plugins enable rabbitmq_federation_management</span><br></pre></td></tr></table></figure><p><strong>3.原理图(先运行 consumer 在 node2 创建 fed_exchange)</strong></p><p><img src="/images/studyNote/rabbitMQ/20210912_123834.png"></p><p><strong>4.在 downstream(node2)配置 upstream(node1)</strong></p><p><img src="/images/studyNote/rabbitMQ/20210912_123911.png"></p><p><strong>5.添加 policy</strong></p><p><img src="/images/studyNote/rabbitMQ/20210912_123958.png"></p><p><strong>6.成功的前提</strong></p><p><img src="/images/studyNote/rabbitMQ/20210912_124034.png"></p><h3 id="Federation-Queue"><a href="#Federation-Queue" class="headerlink" title="Federation Queue"></a>Federation Queue</h3><p>联邦队列可以在多个 Broker 节点(或者集群)之间为单个队列提供均衡负载的功能。一个联邦队列可以连接一个或者多个上游队列(upstream queue)，并从这些上游队列中获取消息以满足本地消费者消费消息的需求。</p><h4 id="搭建步骤-3"><a href="#搭建步骤-3" class="headerlink" title="搭建步骤"></a>搭建步骤</h4><p><strong>1.原理图</strong></p><p><img src="/images/studyNote/rabbitMQ/20210912_124323.png"></p><p><strong>2.添加 upstream(同上)</strong></p><p><strong>3.添加 policy</strong></p><p><img src="/images/studyNote/rabbitMQ/20210912_124407.png"></p><h3 id="Shovel"><a href="#Shovel" class="headerlink" title="Shovel"></a>Shovel</h3><p>Federation 具备的数据转发功能类似，Shovel 够可靠、持续地从一个 Broker 中的队列(作为源端，即source)拉取数据并转发至另一个 Broker 中的交换器(作为目的端，即 destination)。作为源端的队列和作为目的端的交换器可以同时位于同一个 Broker，也可以位于不同的 Broker 上。Shovel 可以翻译为”铲子”，是一种比较形象的比喻，这个”铲子”可以将消息从一方”铲子”另一方。Shovel 行为就像优秀的客户端应用程序能够负责连接源和目的地、负责消息的读写及负责连接失败问题的处理。</p><h4 id="搭建步骤-4"><a href="#搭建步骤-4" class="headerlink" title="搭建步骤"></a>搭建步骤</h4><p><strong>1.开启插件(需要的机器都开启)</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins enable rabbitmq_shovel</span><br><span class="line">rabbitmq-plugins enable rabbitmq_shovel_management</span><br></pre></td></tr></table></figure><h4 id="2-原理图"><a href="#2-原理图" class="headerlink" title="2.原理图"></a>2.原理图</h4><p>在源头发送的消息直接回进入到目的地队列</p><p><img src="/images/studyNote/rabbitMQ/20210912_124534.png"></p><p><strong>3.添加 shovel 源和目的地</strong></p><p><img src="/images/studyNote/rabbitMQ/20210912_124609.png"></p><h2 id="RabbitMQ工具类"><a href="#RabbitMQ工具类" class="headerlink" title="RabbitMQ工具类"></a>RabbitMQ工具类</h2><p>在企业开发过程中，直接使用SpringBoot提供的RabbitTemplate还是略显复杂，通常我们一个系统发送消息基本上也是只依赖于一个交换机和一个队列（延迟消息需单独依赖于延迟交换机），基于此，我们可以把交换机、队列以及路由key等声明直接放在配置文件中，然后封装发送普通消息的工具类，和发送延迟消息的工具类，发送的消息体内容我们可以增加交易码这个概念，消费者通过不同交易码，处理不同的业务。消息体通过泛型，在发消息时声明消息体类型，通过json序列化传输。</p><h3 id="工具类使用"><a href="#工具类使用" class="headerlink" title="工具类使用"></a>工具类使用</h3><h4 id="延迟消息发送"><a href="#延迟消息发送" class="headerlink" title="延迟消息发送"></a>延迟消息发送</h4><p>项目启动时，直接声明好延迟交换机，延迟队列以及路由key，发送延迟消息只需要一句代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendDelayMsg</span><span class="params">(<span class="meta">@PathVariable</span> String message, <span class="meta">@PathVariable</span> Integer delayTime)</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;当前时间：&#123;&#125;,发送一条时长&#123;&#125;毫秒TTL信息给队列QC:&#123;&#125;&quot;</span>, <span class="keyword">new</span> Date(), delayTime, message);</span><br><span class="line">    MsgData&lt;String&gt; msgData = <span class="keyword">new</span> MsgData&lt;&gt;(<span class="string">&quot;0001&quot;</span>, message, <span class="string">&quot;这是我的测试延迟消息！&quot;</span>);</span><br><span class="line">    EventDispatcherUtil.eventDispatch(msgData, delayTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="普通消息发送"><a href="#普通消息发送" class="headerlink" title="普通消息发送"></a>普通消息发送</h4><p>普通消息通过发布订阅模式实现，其他系统若要接收次消息，只需要声明一个队列然后添加监听，绑定到此交换机上即可，发送普通消息也只需要一句代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendFanoutMsg</span><span class="params">(<span class="meta">@PathVariable</span> String message)</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;当前时间：&#123;&#125;,发送一条信息给队列QC:&#123;&#125;&quot;</span>, <span class="keyword">new</span> Date(), message);</span><br><span class="line">    MsgData&lt;String&gt; msgData = <span class="keyword">new</span> MsgData&lt;&gt;(<span class="string">&quot;0001&quot;</span>, message, <span class="string">&quot;这是我的测订阅消息！&quot;</span>);</span><br><span class="line">    EventDispatcherUtil.eventDispatch(msgData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RabbitMQ相关面试题"><a href="#RabbitMQ相关面试题" class="headerlink" title="RabbitMQ相关面试题"></a>RabbitMQ相关面试题</h2><h3 id="如何保证消息不丢失？"><a href="#如何保证消息不丢失？" class="headerlink" title="如何保证消息不丢失？"></a>如何保证消息不丢失？</h3><ol><li>队列和消息持久化：保证MQ宕机了消息不丢失，必须保证在磁盘上才能（3.4.2、3.4.3）</li><li>消息发布确认：开启消息发布确认，MQ将消息发送到交换机并且保存在磁盘上之后返回一个确认，此时可以保证生产者发送的消息绝对不丢失。见：9.1</li><li>消息回退处理：当消息到达交换机无法路由到队列时，交换机把消息回退给生产者，也可以通过<strong>备份交换机</strong>实现。见：9.2</li><li>消息应答机制：设置为手动应答，保证消费者正确处理完消息，如果处理失败，消息重新入队</li><li>集群环境下，添加镜像队列。见：11.2</li></ol><h3 id="消息的类型"><a href="#消息的类型" class="headerlink" title="消息的类型"></a>消息的类型</h3><p>主要是交换机的类型，包括：</p><ol><li>直接(direct)：路由类型</li><li>主题(topic)</li><li>标题(headers) ：已经不用了</li><li>扇出(fanout)：发布订阅类型</li></ol>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法</title>
      <link href="/2022/01/17/%E9%9D%A2%E8%AF%95%E5%9F%BA%E5%9C%B0/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
      <url>/2022/01/17/%E9%9D%A2%E8%AF%95%E5%9F%BA%E5%9C%B0/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="常见算法技巧"><a href="#常见算法技巧" class="headerlink" title="常见算法技巧"></a>常见算法技巧</h2><h3 id="巧用位运算"><a href="#巧用位运算" class="headerlink" title="巧用位运算"></a>巧用位运算</h3><p>1、如果和char字符串变为一个int整形 ,不能强转,通过减去’0’</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="keyword">int</span> i = (<span class="keyword">int</span>)c;<span class="comment">//实际值为48，ASCII的值，详细请查看:https://easeapi.com/tool/ascii</span></span><br><span class="line"><span class="keyword">int</span> j = c -<span class="string">&#x27;0&#x27;</span>;<span class="comment">// 结果为0</span></span><br></pre></td></tr></table></figure><p>2、巧用与或运算。int数或0x00000000,int数与0xffffffff</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> b = a | <span class="number">0x00000000</span>;<span class="comment">//结果是100，</span></span><br><span class="line"><span class="keyword">int</span> c = a &amp; <span class="number">0xffffffff</span>;<span class="comment">//结果是100</span></span><br></pre></td></tr></table></figure><p>3、巧用位运算。奇偶数判断，用a&amp;1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">31</span>;</span><br><span class="line"><span class="keyword">int</span> num1 = num &amp; <span class="number">1</span>;<span class="comment">//想想下二进制的8421,只要为的最后一位为1，那它一定是基数，否则就是偶数</span></span><br></pre></td></tr></table></figure><p>4、巧用异或 a^a = 0,a^0=a;异或进行数据交换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> y = <span class="number">2</span>;</span><br><span class="line">x = x^y;<span class="comment">//记住原本xy的属性，相当于temp</span></span><br><span class="line">y = x^y;<span class="comment">//(x^y)^y=x^(y^y)=x^0=x,完成y=x的交换</span></span><br><span class="line">x = x^y;<span class="comment">//x^y^x=(x^x)^y=0^y=y,完成x=y的交换</span></span><br></pre></td></tr></table></figure><p>5、高效找中间值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a  = <span class="number">1</span>;<span class="comment">// 0</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;<span class="comment">//length-1</span></span><br><span class="line"><span class="keyword">int</span> middle = (a+b)/<span class="number">2</span>;<span class="comment">//越界</span></span><br><span class="line"><span class="keyword">int</span> middle = b-(b-a)&lt;&lt;<span class="number">1</span>;</span><br></pre></td></tr></table></figure><h2 id="常见算法题"><a href="#常见算法题" class="headerlink" title="常见算法题"></a>常见算法题</h2><h3 id="单链表反转"><a href="#单链表反转" class="headerlink" title="单链表反转"></a>单链表反转</h3><ol><li>遍历方式反转</li></ol><blockquote><p>通过遍历形式反转，需要记录保存全局当前节点和前一个节点，循环内为了防止断链，通过局域变量保存下一个。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">revertList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 给下一个节点使用</span></span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        ListNode current = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 保存下一个节点，防止断链</span></span><br><span class="line">            ListNode next = current.next;</span><br><span class="line">            <span class="comment">// 当前节点指向上一个节点</span></span><br><span class="line">            current.next = pre;</span><br><span class="line">            <span class="comment">// 把新的当前节点记录下来，给下一个节点使用</span></span><br><span class="line">            pre = current;</span><br><span class="line">            <span class="comment">// 移动处理</span></span><br><span class="line">            current = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>递归形式反转</li></ol><blockquote><p>递归形式反转需要注意递归的三条原则。1.大问题可以拆为小问题。2.小问题的求解方式和大问题一样。3.小问题存在解。参考斐波拉切数的解决方案。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">revertList2</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 递，一直拆分，知道剩下一个节点。假设我们的只剩下两个节点head和head.next</span></span><br><span class="line">        ListNode revert = revertList2(head.next);</span><br><span class="line">        <span class="comment">// 归并，如果有两个节点</span></span><br><span class="line">        head.next.next = head;<span class="comment">//把下一个节点的next指向自己，这个时候是个双链表 head.next = x,x.next=head;</span></span><br><span class="line">        head.next = <span class="keyword">null</span>;<span class="comment">//断开本身的链接</span></span><br><span class="line">        <span class="keyword">return</span>  revert;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法与数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
