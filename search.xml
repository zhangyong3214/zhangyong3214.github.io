<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>面试知识点整理</title>
      <link href="/2022/02/16/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-2022/"/>
      <url>/2022/02/16/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86-2022/</url>
      
        <content type="html"><![CDATA[<h1 id="2022-知识点梳理"><a href="#2022-知识点梳理" class="headerlink" title="2022-知识点梳理"></a>2022-知识点梳理</h1><h2 id="1、redis-keys执行了会怎么样"><a href="#1、redis-keys执行了会怎么样" class="headerlink" title="1、redis keys执行了会怎么样"></a>1、redis keys执行了会怎么样</h2><blockquote><p>1、当redis集群中的key数量不多时候没有什么大问题，但是随着key数量的增长，这样可能引起redis的客户端访问redis阻塞。</p><p>2、因为Redis是单线程的，执行任何命令时候其他命令会阻塞，而且由于key命令的时间复杂度是O(n)，redis服务端会匹配查找完所有的key才结束，比较耗时，如果在线上执行非常危险。</p><p>3、如果命令执行时间过长可能会触发服务器的安全策略，导致主从切换或者重新选主</p></blockquote><p><strong>可用scan命令替换keys命令，达到同样效果</strong></p><p>Scan命令在Redis的2.8版本爱是支持，相当于db中的分页查询,虽然也是O(n)的时间复杂度，但是数量进行制定，查询时间稳定</p><blockquote><p>Scan  0 match  test* count 100</p></blockquote><h2 id="2、redis缓存击穿-穿透"><a href="#2、redis缓存击穿-穿透" class="headerlink" title="2、redis缓存击穿 穿透"></a>2、redis缓存击穿 穿透</h2><p>前提条件：我们把db的热点数据放在了redis，并设置了超时时间，目前是较少DB的访问次数或者DB支持不了这么大压力。但是在查询时候有又进行了DB兜底的情况。</p><p><strong>缓存击穿</strong>：当缓存过期的一瞬间，大量请求达到redis，因为redis没有，所以一瞬间的所有流量都打到了DB</p><p><strong>缓存穿透</strong>:在缓存中查询不到数据，去数据库中查询数据也没查到，相当于无效请求到了BD，有大量这样请求都打到了DB。</p><p>缓存击穿的解决方案()：</p><ul><li>访问DB的位置加互斥锁</li><li>热点数据续时</li><li>异步同步，不用db兜底</li></ul><p>缓存击穿(前置拦截)：</p><ul><li>接口验证。非法请求降级等等。</li><li>缓存空值并进行超时时间控制</li><li>布隆过滤器–不存在请求先过滤</li></ul><h2 id="3、-zookeeper-eureka区别"><a href="#3、-zookeeper-eureka区别" class="headerlink" title="3、 zookeeper eureka区别"></a>3、 zookeeper eureka区别</h2><h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h3><ol><li>都可以作为注册中心</li></ol><h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><ol><li>Eureka 是AP模型(关注可用性)，ZK是CP模型(关注数据一致性)</li><li>Eureka支持负载均衡策略，ZK不支持</li><li>Eureka访问支持http协议，ZK不支持</li></ol><h2 id="4、dubbo-ribon负载均衡"><a href="#4、dubbo-ribon负载均衡" class="headerlink" title="4、dubbo ribon负载均衡"></a>4、dubbo ribon负载均衡</h2><h2 id="5、-spring中的设计模式和用法示例"><a href="#5、-spring中的设计模式和用法示例" class="headerlink" title="5、 spring中的设计模式和用法示例"></a>5、 spring中的设计模式和用法示例</h2><h2 id="6、-数据库查询最近100万的数据"><a href="#6、-数据库查询最近100万的数据" class="headerlink" title="6、 数据库查询最近100万的数据"></a>6、 数据库查询最近100万的数据</h2><h2 id="7、mysql-acid怎么保证"><a href="#7、mysql-acid怎么保证" class="headerlink" title="7、mysql acid怎么保证"></a>7、mysql acid怎么保证</h2><h2 id="8、mysql-b-树和b树-avl树区别"><a href="#8、mysql-b-树和b树-avl树区别" class="headerlink" title="8、mysql b+树和b树 avl树区别"></a>8、mysql b+树和b树 avl树区别</h2><h2 id="9、分布式锁redis宕机怎么办"><a href="#9、分布式锁redis宕机怎么办" class="headerlink" title="9、分布式锁redis宕机怎么办"></a>9、分布式锁redis宕机怎么办</h2><h2 id="10、dubbo-zookeeper集群宕机还能发现吗"><a href="#10、dubbo-zookeeper集群宕机还能发现吗" class="headerlink" title="10、dubbo zookeeper集群宕机还能发现吗"></a>10、dubbo zookeeper集群宕机还能发现吗</h2><h2 id="11、springboot-properties-yaml读取顺序"><a href="#11、springboot-properties-yaml读取顺序" class="headerlink" title="11、springboot properties yaml读取顺序"></a>11、springboot properties yaml读取顺序</h2><h2 id="12、dubbo-properties-xml读取顺序"><a href="#12、dubbo-properties-xml读取顺序" class="headerlink" title="12、dubbo properties xml读取顺序"></a>12、dubbo properties xml读取顺序</h2>]]></content>
      
      
      <categories>
          
          <category> 面试知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/02/13/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/netty%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2022/02/13/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/netty%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="netty"><a href="#netty" class="headerlink" title="netty"></a>netty</h2><h3 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h3><blockquote><p>IO模型就是说用什么样的通道进行数据的发放和接收</p></blockquote><ol><li><p>BIO</p><blockquote><p>同步阻塞模型，一个客户端连接一个线程，如果有多个客户端，需要有多个线程来处理，可能超过服务端的资源限制。</p></blockquote></li></ol><p>在使用NIO过程中使用了socket.accept()。服务端的outputStream.write()。客户端的inputStream.read();都是阻塞方法。为了提升服务端的吞吐量，一般都会才会多线程的方式。</p><p>这个模型有以下几个致命问题</p><ul><li>线程的创建和销毁，在Linux这样的操作系统中，线程本质是一个进程。创建和销毁都是重量级的系统函数。</li><li>线程本身占用较大的内存，内存一般都会有内存的分配，如果系统的线程过多，那么整个JVM内存可能会吃完。</li><li>线程的切换成本也很很高，操作系统在发生线程切换时候需要保存线程的上线文，然后执行系统调用。</li></ul><blockquote><p>结论：NIO模型在线程过多时候(客户端并发度很高时候)，那么这种模型很占用大量的服务资源。</p></blockquote><ol start="2"><li>NIO</li></ol><blockquote><p>同步非阻塞IO模型。</p></blockquote><p>Channel、Buffer、选择器</p><p>ServerSocketChannel </p><p>Selector注册。多路复用选择器</p><p>和BIO相比，NIO把原来的阻塞读写(占用线程)编程了单线程轮训，找到可以进行读写的网络文件描述符进行读写。除了时间轮训是阻塞的，剩余IO操作都是存CPU操作，没必要开启多线程。</p><blockquote><p>由于线程的节约，连接数大的时候因为携程切换带来的问题也随之解决，进而为处理海量了解提供了可能。</p></blockquote><p>在NIO的模型下，我们需要三类线程</p><ul><li>事件分发器，单线程选择就绪事件。</li><li>I/O处理器，包括connnect、read、write等，这种存CPU操作，一般开启CPU核心线程数就可以</li><li>业务线程，在处理完I/O后，业务一般还会有自己的业务逻辑，有时候还会有阻塞I/O，如DB操作、PRC等操作</li></ul><ol start="3"><li>AIO</li></ol><blockquote><p>异步非阻塞。AIO底层是NIO的封装，同步转异步的方式。</p></blockquote><p>tcp的连接，数据读取和写入都不进行等待，通过回调的方式进行连接和读写。</p><h3 id="netty核心功能"><a href="#netty核心功能" class="headerlink" title="netty核心功能"></a>netty核心功能</h3><h3 id="netty的源码解析"><a href="#netty的源码解析" class="headerlink" title="netty的源码解析"></a>netty的源码解析</h3><h3 id="netty的高性能场景"><a href="#netty的高性能场景" class="headerlink" title="netty的高性能场景"></a>netty的高性能场景</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/02/01/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/Spring%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"/>
      <url>/2022/02/01/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/Spring%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring知识点"><a href="#Spring知识点" class="headerlink" title="Spring知识点"></a>Spring知识点</h1><h2 id="Spring-底层核心原理解析"><a href="#Spring-底层核心原理解析" class="headerlink" title="Spring 底层核心原理解析"></a>Spring 底层核心原理解析</h2><h3 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationContext</span> <span class="keyword">extends</span> <span class="title">EnvironmentCapable</span>, <span class="title">ListableBeanFactory</span>, <span class="title">HierarchicalBeanFactory</span>,</span></span><br><span class="line"><span class="class"><span class="title">MessageSource</span>, <span class="title">ApplicationEventPublisher</span>, <span class="title">ResourcePatternResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the unique id of this application context.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the unique id of the context, or &#123;<span class="doctag">@code</span> null&#125; if none</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">String <span class="title">getId</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return a name for the deployed application that this context belongs to.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a name for the deployed application, or the empty String by default</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">String <span class="title">getApplicationName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return a friendly name for this context.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a display name for this context (never &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">String <span class="title">getDisplayName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the timestamp when this context was first loaded.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the timestamp (ms) when this context was first loaded</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getStartupDate</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the parent context, or &#123;<span class="doctag">@code</span> null&#125; if there is no parent</span></span><br><span class="line"><span class="comment"> * and this is the root of the context hierarchy.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the parent context, or &#123;<span class="doctag">@code</span> null&#125; if there is no parent</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">ApplicationContext <span class="title">getParent</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Expose AutowireCapableBeanFactory functionality for this context.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This is not typically used by application code, except for the purpose of</span></span><br><span class="line"><span class="comment"> * initializing bean instances that live outside of the application context,</span></span><br><span class="line"><span class="comment"> * applying the Spring bean lifecycle (fully or partly) to them.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Alternatively, the internal BeanFactory exposed by the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> ConfigurableApplicationContext&#125; interface offers access to the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> AutowireCapableBeanFactory&#125; interface too. The present method mainly</span></span><br><span class="line"><span class="comment"> * serves as a convenient, specific facility on the ApplicationContext interface.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;<span class="doctag">NOTE:</span> As of 4.2, this method will consistently throw IllegalStateException</span></span><br><span class="line"><span class="comment"> * after the application context has been closed.&lt;/b&gt; In current Spring Framework</span></span><br><span class="line"><span class="comment"> * versions, only refreshable application contexts behave that way; as of 4.2,</span></span><br><span class="line"><span class="comment"> * all application context implementations will be required to comply.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the AutowireCapableBeanFactory for this context</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalStateException if the context does not support the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> AutowireCapableBeanFactory&#125; interface, or does not hold an</span></span><br><span class="line"><span class="comment"> * autowire-capable bean factory yet (e.g. if &#123;<span class="doctag">@code</span> refresh()&#125; has</span></span><br><span class="line"><span class="comment"> * never been called), or if the context has been closed already</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ConfigurableApplicationContext#refresh()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ConfigurableApplicationContext#getBeanFactory()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">AutowireCapableBeanFactory <span class="title">getAutowireCapableBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> IllegalStateException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>ApplicationContext我们通常称之为Spring的上下文，基本上Spring的核心操作都能通过这个上线文获取。</p></blockquote><h2 id="Spring的bean"><a href="#Spring的bean" class="headerlink" title="Spring的bean"></a>Spring的bean</h2><p>前提条件</p><p>Bean的创建的生命周期</p><p>xxxService –&gt;容器初始化(产生一个对象)–&gt;依赖注入(属性赋值)-&gt;初始化前-&gt;初始化–&gt;初始化后-&gt;Spring的bean</p><p>Spring上线文的初始化</p><ul><li>扫描bean</li><li>创建非懒加载的单例bean</li></ul><h3 id="BeanDefinition"><a href="#BeanDefinition" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h3><ol><li>AbstractBeanDefinition</li><li>AnnotatedBeanDefinition</li><li>GenericBeanDefinition</li><li>AnnotatedGenericBeanDefinition</li><li>ScannerGenericBeanDefinition</li></ol><h3 id="BeanDefinitionReader"><a href="#BeanDefinitionReader" class="headerlink" title="BeanDefinitionReader"></a>BeanDefinitionReader</h3><ol><li>AnnotatedBeanDefinitionReader：读取注解的reader,把一个普通类转换为一个Spring容器的Bean定义(BeanDefinition)</li><li>XmlBeanFefinitionReader：xml定义的读取器，获取</li><li>ClassPathBeanDefinitionScanner：扫描器，通过输入的路径进行扫描</li></ol><h3 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h3><p>DefautListableBeanFactory</p><h3 id="ApplicationContext-1"><a href="#ApplicationContext-1" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h3><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>Property</p><p>ConditionConverter</p><p>SimpleTypeConverter</p><h3 id="比较器"><a href="#比较器" class="headerlink" title="比较器"></a>比较器</h3><p>OrderComparator</p><h3 id="MetadataReader"><a href="#MetadataReader" class="headerlink" title="MetadataReader"></a>MetadataReader</h3><p>读取一个类的元数据，解析类。</p><h3 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h3><h4 id="ConfigirableListableBeanFactory"><a href="#ConfigirableListableBeanFactory" class="headerlink" title="ConfigirableListableBeanFactory"></a>ConfigirableListableBeanFactory</h4><p>Configurable  可配置</p><p>Listable 可列举</p><blockquote><p>类型转换器</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beanFactory.addPropertyEditorRegistrar(<span class="keyword">new</span> ResourceEditorRegistrar(<span class="keyword">this</span>, getEnvironment()));</span><br></pre></td></tr></table></figure><blockquote><p>默认beanPostProcesssor</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationContextAwareProcessor(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(<span class="keyword">this</span>));</span><br><span class="line">## 通过环境变量</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>忽略接口</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">beanFactory.ignoreDependencyInterface(EnvironmentAware.class);</span><br><span class="line">beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);</span><br><span class="line">beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);</span><br><span class="line">beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);</span><br><span class="line">beanFactory.ignoreDependencyInterface(MessageSourceAware.class);</span><br><span class="line">beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);</span><br><span class="line">beanFactory.ignoreDependencyInterface(ApplicationStartupAware.class);</span><br></pre></td></tr></table></figure><blockquote><p>解析实现</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class="line">beanFactory.registerResolvableDependency(ResourceLoader.class, <span class="keyword">this</span>);</span><br><span class="line">beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, <span class="keyword">this</span>);</span><br><span class="line">beanFactory.registerResolvableDependency(ApplicationContext.class, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><h4 id="HierarchicalMessageSource"><a href="#HierarchicalMessageSource" class="headerlink" title="HierarchicalMessageSource"></a>HierarchicalMessageSource</h4><h3 id="Spring-bean的扫描过程"><a href="#Spring-bean的扫描过程" class="headerlink" title="Spring bean的扫描过程"></a>Spring bean的扫描过程</h3><h3 id="Spring-bean初始化"><a href="#Spring-bean初始化" class="headerlink" title="Spring bean初始化"></a>Spring bean初始化</h3><ol><li>实例化前: InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation() 。有就直接返回，给用户提供了自己实例化bean的机会(如果有的话)</li><li></li></ol><p>@Resource通过CommonAnnotationBeanPostProcessor</p><h3 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h3><ol><li>实例化AService</li><li>填充BService属性 –&gt;去单例池找BService–&gt;没有则创建BService<ul><li>实例化BService–&gt;得到了对象</li><li>填充AService属性–&gt;去单例池找AService-&gt;没有则创建AService。。。(也找不到)</li></ul></li><li>填充其他属性 –&gt;</li><li>初始化前、初始化</li><li>初始化后</li><li>放入单例池</li></ol><p><strong>三级缓存</strong></p><p>singletonObjects：单例池。完成了完整生命周期的单例bean.</p><p>earlySingletonObjects：只进行了实例化，还没有进行数据赋值的对象。解决循环依赖，解决单例的情况</p><p>singletonFacories：出现循环信赖时候，创建bean的lambda表达式。</p><p>earlyProxyObjects：因为循环信赖提前进行了AOP的对象池</p><p>Spring循环依赖只能解决单例的情况，如果是原型的情况下是支持不了的</p><p>构造方法的循环依赖，情况直接用也是不行的，需要用@Lazy</p><p>BeanProcesson和advise</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构和算法</title>
      <link href="/2022/01/27/%E9%9D%A2%E8%AF%95%E5%9F%BA%E5%9C%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
      <url>/2022/01/27/%E9%9D%A2%E8%AF%95%E5%9F%BA%E5%9C%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><h3 id="高效交换算法-异或"><a href="#高效交换算法-异或" class="headerlink" title="高效交换算法(异或^)"></a>高效交换算法(异或^)</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul><li>0^N = N  ; N^N = 0 </li><li>相同为0，不同为1，也可以叫做无进位相加，这么做的前提：需要交换的两个数指向的内存是两位位置</li><li>异或运算满足交换律和结合律</li><li>不用额外变量交换两个数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 交换arr的i和j位置上的值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    arr[i] = arr[i] ^ arr[j];</span><br><span class="line">    arr[j] = arr[i] ^ arr[j];</span><br><span class="line">    arr[i] = arr[i] ^ arr[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="一种数出现奇数次"><a href="#一种数出现奇数次" class="headerlink" title="一种数出现奇数次"></a>一种数出现奇数次</h4><p>一个数组中有一个数出现奇数次，其他数都出现偶数次，怎么找到这一个数？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printOddTimesNum1</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> eor = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">      eor ^= arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(eor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="两种数出现奇数次"><a href="#两种数出现奇数次" class="headerlink" title="两种数出现奇数次"></a>两种数出现奇数次</h4><p>一个数组中有两个数出现奇数次，其他数都出现了偶数次，怎么找到这两个数？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printOddTimesNum2</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> eor = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">      eor ^= arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// a 和 b是两种数</span></span><br><span class="line">    <span class="comment">// eor != 0</span></span><br><span class="line">    <span class="comment">// eor最右侧的1，提取出来</span></span><br><span class="line">    <span class="comment">// eor :     00110010110111000</span></span><br><span class="line">    <span class="comment">// rightOne :00000000000001000</span></span><br><span class="line">    <span class="keyword">int</span> rightOne = eor &amp; (-eor); <span class="comment">// 提取出最右的1</span></span><br><span class="line">    <span class="keyword">int</span> onlyOne = <span class="number">0</span>; <span class="comment">// eor&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; arr.length;i++) &#123;</span><br><span class="line">      <span class="comment">//  arr[1] =  111100011110000</span></span><br><span class="line">      <span class="comment">// rightOne=  000000000010000</span></span><br><span class="line">      <span class="keyword">if</span> ((arr[i] &amp; rightOne) != <span class="number">0</span>) &#123;</span><br><span class="line">        onlyOne ^= arr[i];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(onlyOne + <span class="string">&quot; &quot;</span> + (eor ^ onlyOne));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><ul><li>基本冒泡排序算法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 0 ~ N-1</span></span><br><span class="line">    <span class="comment">// 0 ~ N-2</span></span><br><span class="line">    <span class="comment">// 0 ~ N-3</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> e = arr.length - <span class="number">1</span>; e &gt; <span class="number">0</span>; e--) &#123; <span class="comment">// 0 ~ e</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; e; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">          swap(arr, i, i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li>冒泡排序算法优化</li></ul><p>在一趟排序过程中如果一次都没有交换过，那说明后续的数都是有序的，不需要在进行后续的排序了，如果元素本来就是有序的，就只比较一次就结束了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 标识变量，表示是否进行过交换</span></span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="comment">// 如果前面的数比后面的数大，则交换</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在一趟排序中，一次交换都没有发生过</span></span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 重置flag!!!, 进行下次判断</span></span><br><span class="line">            flag = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><ul><li>0 ~ N-1  找到最小值，在哪，放到0位置上</li><li>1 ~ n-1  找到最小值，在哪，放到1 位置上</li><li>2 ~ n-1  找到最小值，在哪，放到2 位置上</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123; <span class="comment">// i ~ N-1 上找最小值的下标 </span></span><br><span class="line">            minIndex = arr[j] &lt; arr[minIndex] ? j : minIndex;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, i, minIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><ul><li>0~1单范围有序</li><li>0~2范围有序</li><li>0~3范围有序</li><li>0~N范围有序</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不只1个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123; <span class="comment">// 0 ~ i 做到有序</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; arr[j + <span class="number">1</span>]; j--) &#123;</span><br><span class="line">        swap(arr, j, j + <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h2><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>二分法的详解与扩展</p><ol><li>在一个有序数组中，查找某个数是否存在</li><li>在一个有序数组中，找&gt;=某个数最左侧的位置</li><li>局部最小值问题</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">int</span>[] sortedArr, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sortedArr == <span class="keyword">null</span> || sortedArr.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> R = sortedArr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// L..R</span></span><br><span class="line">    <span class="keyword">while</span> (L &lt; R) &#123; <span class="comment">// L..R 至少两个数的时候</span></span><br><span class="line">        mid = L + ((R - L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (sortedArr[mid] == num) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sortedArr[mid] &gt; num) &#123;</span><br><span class="line">            R = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            L = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sortedArr[L] == num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组范围上求最大值"><a href="#数组范围上求最大值" class="headerlink" title="数组范围上求最大值"></a>数组范围上求最大值</h3><p>递归解法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// arr[L..R]范围上只有一个数，直接返回，base case</span></span><br><span class="line">    <span class="keyword">if</span> (L == R) &#123; </span><br><span class="line">        <span class="keyword">return</span> arr[L];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// L...R 不只一个数</span></span><br><span class="line">    <span class="comment">// mid = (L + R) / 2</span></span><br><span class="line">    <span class="keyword">int</span> mid = L + ((R - L) &gt;&gt; <span class="number">1</span>); <span class="comment">// 中点</span></span><br><span class="line">    <span class="keyword">int</span> leftMax = process(arr, L, mid);</span><br><span class="line">    <span class="keyword">int</span> rightMax = process(arr, mid + <span class="number">1</span>, R);</span><br><span class="line">    <span class="keyword">return</span> Math.max(leftMax, rightMax);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对数器的概念"><a href="#对数器的概念" class="headerlink" title="对数器的概念"></a>对数器的概念</h2><ol><li>有一个你想要测试的方法a</li><li>实现复杂度不好但是容易实现的方法b</li><li>实现一个随机样本产生器</li><li>把方法a和方法b跑相同的随机样本，看看得到的结果是否一样</li><li>如果有一个随机样本时的比对结果不一致，打印样本进行人工干预，改对方法a或者方法b</li><li>当样本数量很多时比对测试依然正确，可以确定方法a已经正确</li></ol><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="ab数组合并到a"><a href="#ab数组合并到a" class="headerlink" title="ab数组合并到a"></a>ab数组合并到a</h3><ul><li><p>题目：给出两个有序的整数数组A和B，请将数组B合并到数组A中，变成一个有序的数组。注意：可以假设A数组有足够的空间存放B数组的元素，A和B中初始的元素数目分别为m和n。</p></li><li><p>题解：最优解：从后往前处理,不需要开辟额外空间。从后往前，这样不需要进行冗余处理。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a 数组a，有足够的空间合并数组b</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> m 数组a里面的元素个数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> b 数组b</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n 数组b里面的元素个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> m, <span class="keyword">int</span>[] b, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = m - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> j = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> index = m + n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &gt; b[j] )&#123;</span><br><span class="line">            a[index--] = a[i--];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            a[index--] = b[j--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果A的数字比B多，则不会进入后续处理；如果B的数字比A多，则进入后续处理，将B剩余数字添加到数组A中。</span></span><br><span class="line">    <span class="keyword">while</span> (j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        a[index--] = b[j--];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ab数组合并到c"><a href="#ab数组合并到c" class="headerlink" title="ab数组合并到c"></a>ab数组合并到c</h3><ul><li>题目： 合并两个有序整型数据（入参两个需要合并的数组，返回值合并好的新数组）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] margeArr(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] c = <span class="keyword">new</span> <span class="keyword">int</span>[a.length + b.length];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//比较指针i,j指向的值，小的值存入指针index指向的结果数组中，当有一个指针（i或j）先到达数组末尾时，比较结束；</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; a.length &amp;&amp; j &lt; b.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt; b[j]) &#123;</span><br><span class="line">            c[index++] = a[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            c[index++] = b[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l;</span><br><span class="line">    <span class="comment">//将指针（i或j）没有到达数组末尾的数组复制到指针index指向的结果数组中</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; a.length) &#123;</span><br><span class="line">        <span class="keyword">for</span> (l = i; l &lt; a.length; l++) &#123;</span><br><span class="line">            c[index++] = a[l];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将指针（i或j）没有到达数组末尾的数组复制到指针index指向的结果数组中</span></span><br><span class="line">    <span class="keyword">if</span> (j &lt; b.length) &#123;</span><br><span class="line">        <span class="keyword">for</span> (l = j; l &lt; b.length; l++) &#123;</span><br><span class="line">            c[index++] = b[l];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查找两数之和等于目标数"><a href="#查找两数之和等于目标数" class="headerlink" title="查找两数之和等于目标数"></a>查找两数之和等于目标数</h3><ul><li>题目：给定一个数组和一个目标数，从数组中找到两个数，是这两个数之和等于目标数。返回其在数组中的编号</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(target - nums[i])) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;map.get(target - nums[i]), i&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="螺旋打印二维数组"><a href="#螺旋打印二维数组" class="headerlink" title="螺旋打印二维数组"></a>螺旋打印二维数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printEdge</span><span class="params">(<span class="keyword">int</span>[][] m, <span class="keyword">int</span> tR, <span class="keyword">int</span> tC, <span class="keyword">int</span> dR, <span class="keyword">int</span> dC)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tR == dR) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = tC; i &lt;= dC; i++) &#123;</span><br><span class="line">            System.out.print(m[tR][i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tC == dC) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = tR; i &lt;= dR; i++) &#123;</span><br><span class="line">            System.out.print(m[i][tC] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> curC = tC;</span><br><span class="line">        <span class="keyword">int</span> curR = tR;</span><br><span class="line">        <span class="keyword">while</span> (curC != dC) &#123;</span><br><span class="line">            System.out.print(m[tR][curC] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            curC++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (curR != dR) &#123;</span><br><span class="line">            System.out.print(m[curR][dC] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            curR++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (curC != tC) &#123;</span><br><span class="line">            System.out.print(m[dR][curC] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            curC--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (curR != tR) &#123;</span><br><span class="line">            System.out.print(m[curR][tC] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            curR--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">spiralOrderPrint</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tR = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> tC = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> dR = matrix.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> dC = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (tR &lt;= dR &amp;&amp; tC &lt;= dC) &#123;</span><br><span class="line">        printEdge(matrix, tR++, tC++, dR--, dC--);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] matrix = &#123; &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;, &#123; <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span> &#125;, &#123; <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span> &#125;,</span><br><span class="line">                      &#123; <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span> &#125; &#125;;</span><br><span class="line">    spiralOrderPrint(matrix);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><ol><li>对于笔试，不用太在乎空间复杂度，一切为了时间复杂度</li><li>对于面试，时间复杂度依然放在第一位，但是一定要找到空间最省的方法</li></ol><ul><li>重要技巧<ul><li>额外数据结构记录（哈希表等）</li><li>快慢指针</li></ul></li></ul><h3 id="链表反转"><a href="#链表反转" class="headerlink" title="链表反转"></a>链表反转</h3><h4 id="单向链表反转"><a href="#单向链表反转" class="headerlink" title="单向链表反转"></a>单向链表反转</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单向链表节点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">        value = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  head 单向链表反转算法</span></span><br><span class="line"><span class="comment">//   a    -&gt;   b    -&gt;  c  -&gt;  null</span></span><br><span class="line"><span class="comment">//   c    -&gt;   b    -&gt;  a  -&gt;  null</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">reverseLinkedList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    Node pre = <span class="keyword">null</span>;</span><br><span class="line">    Node next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        next = head.next;</span><br><span class="line">        head.next = pre;</span><br><span class="line">        pre = head;</span><br><span class="line">        head = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归反转方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">reverseLinkedList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    Node newHead = reverseLinkedList(head.next);</span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="双向链表反转"><a href="#双向链表反转" class="headerlink" title="双向链表反转"></a>双向链表反转</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双向链表节点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> DoubleNode last;</span><br><span class="line">    <span class="keyword">public</span> DoubleNode next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DoubleNode</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">        value = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双向链表反转算法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DoubleNode <span class="title">reverseDoubleList</span><span class="params">(DoubleNode head)</span> </span>&#123;</span><br><span class="line">    DoubleNode pre = <span class="keyword">null</span>;</span><br><span class="line">    DoubleNode next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        next = head.next;</span><br><span class="line">        head.next = pre;</span><br><span class="line">        head.last = next;</span><br><span class="line">        pre = head;</span><br><span class="line">        head = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查找链表中点"><a href="#查找链表中点" class="headerlink" title="查找链表中点"></a>查找链表中点</h3><p>快慢指针应用</p><h4 id="查找链表中点或中点上一个"><a href="#查找链表中点或中点上一个" class="headerlink" title="查找链表中点或中点上一个"></a>查找链表中点或中点上一个</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// head 头  解：查找链表中点或者中点前一个节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">midOrUpMidNode</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> || head.next.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 链表有3个点或以上</span></span><br><span class="line">    Node slow = head.next;</span><br><span class="line">    Node fast = head.next.next;</span><br><span class="line">    <span class="keyword">while</span> (fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查找链表中点或中点下一个"><a href="#查找链表中点或中点下一个" class="headerlink" title="查找链表中点或中点下一个"></a>查找链表中点或中点下一个</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找链表中点或者中点下一个节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">midOrDownMidNode</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    Node slow = head.next;</span><br><span class="line">    Node fast = head.next;</span><br><span class="line">    <span class="keyword">while</span> (fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判断一个链表是否是回文结构"><a href="#判断一个链表是否是回文结构" class="headerlink" title="判断一个链表是否是回文结构"></a>判断一个链表是否是回文结构</h3><p>【题目】给定一个单向链表的头节点head，请判断该链表是否为回文结构。【例子】1-&gt;2-&gt;1,返回true;1-&gt;2-&gt;2-&gt;1,返回true；15-&gt;6-&gt;15，返回true；1-&gt;2-&gt;3，返回false。如果链表长度为N，时间复杂度达到O(N)，额外空间复杂度达到O(1)。</p><ol><li><font color=red>解题思路1：</font> 1：遍历链表，把每个元素放到栈里面；2：从栈里面依次弹出元素和原来链表挨个元素比对。</li><li><font color=red>解题思路2：</font> 1：通过快慢指针找到中点和结束点，只把右侧部分放到栈里面去；2：从栈里面依次弹出元素和原来链表挨个元素比对。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1：遍历链表，把每个元素放到栈里面；2：从栈里面依次弹出元素和原来链表挨个元素比对</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPalindrome1</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">    Node cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        stack.push(cur);</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head.value != stack.pop().value) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1：通过快慢指针找到中点和结束点，只把右侧部分放到栈里面去；2：从栈里面依次弹出元素和原来链表挨个元素比对</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPalindrome2</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node right = head.next;</span><br><span class="line">    Node cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur.next != <span class="keyword">null</span> &amp;&amp; cur.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        right = right.next;</span><br><span class="line">        cur = cur.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">    <span class="keyword">while</span> (right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        stack.push(right);</span><br><span class="line">        right = right.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head.value != stack.pop().value) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表排序"><a href="#链表排序" class="headerlink" title="链表排序"></a>链表排序</h3><h4 id="单向链表分左中右"><a href="#单向链表分左中右" class="headerlink" title="单向链表分左中右"></a>单向链表分左中右</h4><p>【题目】 将单向链表按照某值划分成左边小，中间相等，右边大的形式：给定一个单链表头节点head，节点的值类型是整型，再给定一个整数pivot。实现一个调整链表的函数，将链表调整为做部分都是值小于pivot的节点，中间部分都是值等于piovt的节点，有部分都是值大于piovt的节点。【进阶】在实现原问题功能的基础上增加要求：小于，等于，大于pivot节点之间顺序和之前一样，时间复杂度O(N)，额外空间复杂度O(1)。</p><p><font color=red>解题思路1：</font> 将链表放入数组，排序，再转成链表</p><p><font color=red>解题思路2：</font> 左中右分别准备两个指针(共6个变量)，然后遍历原链表，排序之后分别插入相应位置(考虑边界问题)</p><img src="https://raw.githubusercontent.com/lizejiao/img_bed/master/images/20210917001438.png" style="zoom: 67%;" />  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将链表放入数组，排序，再转成链表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">listPartition1</span><span class="params">(Node head, <span class="keyword">int</span> pivot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    Node cur = head;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        i++;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    Node[] nodeArr = <span class="keyword">new</span> Node[i];</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    cur = head;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i != nodeArr.length; i++) &#123;</span><br><span class="line">        nodeArr[i] = cur;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    arrPartition(nodeArr, pivot);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i != nodeArr.length; i++) &#123;</span><br><span class="line">        nodeArr[i - <span class="number">1</span>].next = nodeArr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    nodeArr[i - <span class="number">1</span>].next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> nodeArr[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">arrPartition</span><span class="params">(Node[] nodeArr, <span class="keyword">int</span> pivot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> small = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> big = nodeArr.length;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (index != big) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nodeArr[index].value &lt; pivot) &#123;</span><br><span class="line">            swap(nodeArr, ++small, index++);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nodeArr[index].value == pivot) &#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            swap(nodeArr, --big, index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Node[] nodeArr, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    Node tmp = nodeArr[a];</span><br><span class="line">    nodeArr[a] = nodeArr[b];</span><br><span class="line">    nodeArr[b] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 左中右分别准备两个指针(共6个变量)，然后遍历原链表，排序之后分别插入相应位置(考虑边界问题)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">listPartition2</span><span class="params">(Node head, <span class="keyword">int</span> pivot)</span> </span>&#123;</span><br><span class="line">    Node sH = <span class="keyword">null</span>; <span class="comment">// small head</span></span><br><span class="line">    Node sT = <span class="keyword">null</span>; <span class="comment">// small tail</span></span><br><span class="line">    Node eH = <span class="keyword">null</span>; <span class="comment">// equal head</span></span><br><span class="line">    Node eT = <span class="keyword">null</span>; <span class="comment">// equal tail</span></span><br><span class="line">    Node mH = <span class="keyword">null</span>; <span class="comment">// big head</span></span><br><span class="line">    Node mT = <span class="keyword">null</span>; <span class="comment">// big tail</span></span><br><span class="line">    Node next = <span class="keyword">null</span>; <span class="comment">// save next node</span></span><br><span class="line">    <span class="comment">// every node distributed to three lists</span></span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        next = head.next;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (head.value &lt; pivot) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sH == <span class="keyword">null</span>) &#123;</span><br><span class="line">                sH = head;</span><br><span class="line">                sT = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sT.next = head;</span><br><span class="line">                sT = head;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (head.value == pivot) &#123;</span><br><span class="line">            <span class="keyword">if</span> (eH == <span class="keyword">null</span>) &#123;</span><br><span class="line">                eH = head;</span><br><span class="line">                eT = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                eT.next = head;</span><br><span class="line">                eT = head;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mH == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mH = head;</span><br><span class="line">                mT = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mT.next = head;</span><br><span class="line">                mT = head;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        head = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 小于区域的尾巴，连等于区域的头，等于区域的尾巴连大于区域的头</span></span><br><span class="line">    <span class="keyword">if</span> (sT != <span class="keyword">null</span>) &#123; <span class="comment">// 如果有小于区域</span></span><br><span class="line">        sT.next = eH;</span><br><span class="line">        eT = eT == <span class="keyword">null</span> ? sT : eT; <span class="comment">// 下一步，谁去连大于区域的头，谁就变成eT</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 下一步，一定是需要用eT 去接 大于区域的头</span></span><br><span class="line">    <span class="comment">// 有等于区域，eT -&gt; 等于区域的尾结点</span></span><br><span class="line">    <span class="comment">// 无等于区域，eT -&gt; 小于区域的尾结点</span></span><br><span class="line">    <span class="comment">// eT 尽量不为空的尾巴节点</span></span><br><span class="line">    <span class="keyword">if</span> (eT != <span class="keyword">null</span>) &#123; <span class="comment">// 如果小于区域和等于区域，不是都没有</span></span><br><span class="line">        eT.next = mH;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sH != <span class="keyword">null</span> ? sH : (eH != <span class="keyword">null</span> ? eH : mH);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表闭环及相交问题"><a href="#链表闭环及相交问题" class="headerlink" title="链表闭环及相交问题"></a>链表闭环及相交问题</h3><h4 id="单链表查找闭环位置"><a href="#单链表查找闭环位置" class="headerlink" title="单链表查找闭环位置"></a>单链表查找闭环位置</h4><p>注：单链表闭环只能有一个环，如果产生环，必然会出现闭环</p><p><strong>解法1：额外空间解决</strong></p><ol><li>申请一个set集合，从头节点遍历链表，每遍历一个元素就查询该节点是否在集合中，如果没有就把该节点放进去，如果有，该节点就是环位置</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">....</span><br></pre></td></tr></table></figure><p><strong>解法2：有限几个变量解决</strong></p><ol><li>快慢指针从单链表头节点开始走，直至两个节点相遇，说明有环，最后指向null，说明无环</li><li>相遇之后快指针回到头节点，之后一次走一步，慢指针停在原地，再次相遇的位置即是环节点位置(记住结论，不要问为什么)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 找到链表第一个入环节点，如果无环，返回null</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getLoopNode</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> || head.next.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// n1 慢  n2 快</span></span><br><span class="line">    Node slow = head.next; <span class="comment">// n1 -&gt; slow</span></span><br><span class="line">    Node fast = head.next.next; <span class="comment">// n2 -&gt; fast</span></span><br><span class="line">    <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fast.next == <span class="keyword">null</span> || fast.next.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// slow fast  相遇</span></span><br><span class="line">    fast = head; <span class="comment">// n2 -&gt; walk again from head</span></span><br><span class="line">    <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="两个无环链表交点位置"><a href="#两个无环链表交点位置" class="headerlink" title="两个无环链表交点位置"></a>两个无环链表交点位置</h4><p><strong>注：</strong></p><ul><li>如果两个单向链表相交，相交后面的部分必然是共有的，那么两个链表最后的那个节点必然是同一个节点</li><li>长链表先走两个链表差值的步数，然后短链表在开始走，他俩一定会在第一个相交的位置相遇</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果两个链表都无环，返回第一个相交节点，如果不想交，返回null</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">noLoop</span><span class="params">(Node head1, Node head2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head1 == <span class="keyword">null</span> || head2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node cur1 = head1;</span><br><span class="line">    Node cur2 = head2;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur1.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        n++;</span><br><span class="line">        cur1 = cur1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (cur2.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        n--;</span><br><span class="line">        cur2 = cur2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cur1 != cur2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// n  :  链表1长度减去链表2长度的值</span></span><br><span class="line">    cur1 = n &gt; <span class="number">0</span> ? head1 : head2; <span class="comment">// 谁长，谁的头变成cur1</span></span><br><span class="line">    cur2 = cur1 == head1 ? head2 : head1; <span class="comment">// 谁短，谁的头变成cur2</span></span><br><span class="line">    n = Math.abs(n);</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">        n--;</span><br><span class="line">        cur1 = cur1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (cur1 != cur2) &#123;</span><br><span class="line">        cur1 = cur1.next;</span><br><span class="line">        cur2 = cur2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="两条有环链表查找交点"><a href="#两条有环链表查找交点" class="headerlink" title="两条有环链表查找交点"></a>两条有环链表查找交点</h4><p>分为两种情况：入环节点可能是同一个节点，也可能不是同一个节点，如图</p><img src="https://raw.githubusercontent.com/lizejiao/img_bed/master/images/20211112225209.png" style="zoom:80%;" /><p>情况1：入环节点可能是同一个节点，就是求单链表的第一个环节点问题，只不过从相交位置开始走</p><p>情况2：如果链表1在转回到自己的过程中没有遇到链表2，就说明是各自成环的，相交节点返回空就醒来，如果遇到，就是情况2，返回两个节点，都对，都属于第一个相交的节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两个有环链表，返回第一个相交节点，如果不想交返回null</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">bothLoop</span><span class="params">(Node head1, Node loop1, Node head2, Node loop2)</span> </span>&#123;</span><br><span class="line">    Node cur1 = <span class="keyword">null</span>;</span><br><span class="line">    Node cur2 = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (loop1 == loop2) &#123;</span><br><span class="line">        cur1 = head1;</span><br><span class="line">        cur2 = head2;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur1 != loop1) &#123;</span><br><span class="line">            n++;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (cur2 != loop2) &#123;</span><br><span class="line">            n--;</span><br><span class="line">            cur2 = cur2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur1 = n &gt; <span class="number">0</span> ? head1 : head2;</span><br><span class="line">        cur2 = cur1 == head1 ? head2 : head1;</span><br><span class="line">        n = Math.abs(n);</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            n--;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (cur1 != cur2) &#123;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">            cur2 = cur2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cur1 = loop1.next;</span><br><span class="line">        <span class="keyword">while</span> (cur1 != loop1) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur1 == loop2) &#123;</span><br><span class="line">                <span class="keyword">return</span> loop1;</span><br><span class="line">            &#125;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查找两个链表相交节点"><a href="#查找两个链表相交节点" class="headerlink" title="查找两个链表相交节点"></a>查找两个链表相交节点</h4><p>注：难点为考虑是否有环，有环链表相交以及无环链表相交问题，没有用到额外数据结构，只用到有限几个变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getIntersectNode</span><span class="params">(Node head1, Node head2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head1 == <span class="keyword">null</span> || head2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 分别找到两个链表的环位置</span></span><br><span class="line">    Node loop1 = getLoopNode(head1);</span><br><span class="line">    Node loop2 = getLoopNode(head2);</span><br><span class="line">    <span class="keyword">if</span> (loop1 == <span class="keyword">null</span> &amp;&amp; loop2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 无环链表相交问题</span></span><br><span class="line">        <span class="keyword">return</span> noLoop(head1, head2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (loop1 != <span class="keyword">null</span> &amp;&amp; loop2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 两条有环链表相交问题</span></span><br><span class="line">        <span class="keyword">return</span> bothLoop(head1, loop1, head2, loop2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>数据结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h3><ul><li>先序遍历：头-&gt;左-&gt;右</li><li>中序遍历：左-&gt;头-&gt;右</li><li>后序遍历：左-&gt;右-&gt;头</li></ul><h4 id="递归遍历二叉树"><a href="#递归遍历二叉树" class="headerlink" title="递归遍历二叉树"></a>递归遍历二叉树</h4><p><strong>遍历说明</strong></p><p>递归通过打印时机不同，实现先，中，后序遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1 前序</span></span><br><span class="line">    f(head.left);</span><br><span class="line">    <span class="comment">// 2 中序</span></span><br><span class="line">    f(head.right);</span><br><span class="line">    <span class="comment">// 3 后序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="非递归遍历二叉树"><a href="#非递归遍历二叉树" class="headerlink" title="非递归遍历二叉树"></a>非递归遍历二叉树</h4><ul><li>先序遍历(深度性遍历)</li></ul><ol><li>准备一个栈，根节点入栈弹出，打印，然后先压右，再压左</li><li>弹出打印，先压右再压左，周而复始</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pre</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    System.out.print(<span class="string">&quot;pre-order: &quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">        stack.add(head);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            head = stack.pop();</span><br><span class="line">            System.out.print(head.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (head.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(head.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (head.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(head.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>后序遍历</li></ul><ol><li>在先序遍历的基础之上，增加一个收集栈，弹出来就放到收集栈中(不打印)，然后<strong>先压左，再压右</strong></li><li>把收集栈中的元素依次出栈，打印</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pos1</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    System.out.print(<span class="string">&quot;pos-order: &quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Stack&lt;Node&gt; s1 = <span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">        Stack&lt;Node&gt; s2 = <span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">        s1.push(head);</span><br><span class="line">        <span class="keyword">while</span> (!s1.isEmpty()) &#123;</span><br><span class="line">            head = s1.pop(); <span class="comment">// 头 右 左</span></span><br><span class="line">            s2.push(head);</span><br><span class="line">            <span class="keyword">if</span> (head.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                s1.push(head.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (head.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                s1.push(head.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左 右 头</span></span><br><span class="line">        <span class="keyword">while</span> (!s2.isEmpty()) &#123;</span><br><span class="line">            System.out.print(s2.pop().value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>中序遍历</li></ul><ol><li>整棵树左边界进栈，依次弹出的过程中，打印，对弹出节点的右树周而复始</li></ol><p>为什么？ 因为整个树都会被他的左边界分解掉，我们把头和左边界压栈，然后再右，出栈的时候就是左，头，右</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">in</span><span class="params">(Node cur)</span> </span>&#123;</span><br><span class="line">    System.out.print(<span class="string">&quot;in-order: &quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() || cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = stack.pop();</span><br><span class="line">                System.out.print(cur.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="宽度遍历"><a href="#宽度遍历" class="headerlink" title="宽度遍历"></a>宽度遍历</h4><p>宽度遍历就是横着遍历，也是层次遍历</p><ol><li>用队列，头节点放队列，每一次弹出就打印，然后先放左再放右，每一个元素出队列都是先放左再放右</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从node出发，进行宽度优先遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">width</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(head);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        Node cur = queue.poll();</span><br><span class="line">        System.out.println(cur.value);</span><br><span class="line">        <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.add(cur.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.add(cur.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求二叉树的最大宽度-难"><a href="#求二叉树的最大宽度-难" class="headerlink" title="求二叉树的最大宽度(难)"></a>求二叉树的最大宽度(难)</h3><p>分析：宽度性遍历的时候要知道每一层的节点个数</p><p>解：遍历每个节点的时候，知道他在第几层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用hash表的解法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxWidthUseMap</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(head);</span><br><span class="line">    <span class="comment">// key 在 哪一层，value</span></span><br><span class="line">    HashMap&lt;Node, Integer&gt; levelMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    levelMap.put(head, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> curLevel = <span class="number">1</span>; <span class="comment">// 当前你正在统计哪一层的宽度</span></span><br><span class="line">    <span class="keyword">int</span> curLevelNodes = <span class="number">0</span>; <span class="comment">// 当前层curLevel层，宽度目前是多少</span></span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        Node cur = queue.poll();</span><br><span class="line">        <span class="keyword">int</span> curNodeLevel = levelMap.get(cur);</span><br><span class="line">        <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            levelMap.put(cur.left, curNodeLevel + <span class="number">1</span>);</span><br><span class="line">            queue.add(cur.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            levelMap.put(cur.right, curNodeLevel + <span class="number">1</span>);</span><br><span class="line">            queue.add(cur.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (curNodeLevel == curLevel) &#123;</span><br><span class="line">            curLevelNodes++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            max = Math.max(max, curLevelNodes);</span><br><span class="line">            curLevel++;</span><br><span class="line">            curLevelNodes = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    max = Math.max(max, curLevelNodes);</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不用hash表的方法 (难度高)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxWidthNoMap</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(head);</span><br><span class="line">    Node curEnd = head; <span class="comment">// 当前层，最右节点是谁</span></span><br><span class="line">    Node nextEnd = <span class="keyword">null</span>; <span class="comment">// 下一层，最右节点是谁</span></span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> curLevelNodes = <span class="number">0</span>; <span class="comment">// 当前层的节点数</span></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        Node cur = queue.poll();</span><br><span class="line">        <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.add(cur.left);</span><br><span class="line">            nextEnd = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.add(cur.right);</span><br><span class="line">            nextEnd = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">        curLevelNodes++;</span><br><span class="line">        <span class="keyword">if</span> (cur == curEnd) &#123;</span><br><span class="line">            max = Math.max(max, curLevelNodes);</span><br><span class="line">            curLevelNodes = <span class="number">0</span>;</span><br><span class="line">            curEnd = nextEnd;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="折纸问题"><a href="#折纸问题" class="headerlink" title="折纸问题"></a>折纸问题</h3><ol><li>结果可看做头节点是凹，所有的左子树头节点都是凹，所有右子树头肩点都是凸的二叉树</li><li>中序遍历即可打印出从上到下的所有结构</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = <span class="number">4</span>;</span><br><span class="line">    process(<span class="number">1</span>, N, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这个节点在第i层，一共有N层，N固定不变的</span></span><br><span class="line"><span class="comment">// 这个节点如果是凹的话，down = T</span></span><br><span class="line"><span class="comment">// 这个节点如果是凸的话，down = F</span></span><br><span class="line"><span class="comment">// 函数的功能：中序打印以你想象的节点为头的整棵树！</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> N, <span class="keyword">boolean</span> down)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; N) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    process(i + <span class="number">1</span>, N, <span class="keyword">true</span>);</span><br><span class="line">    System.out.print(down ? <span class="string">&quot;凹 &quot;</span> : <span class="string">&quot;凸 &quot;</span>);</span><br><span class="line">    process(i + <span class="number">1</span>, N, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="搜索二叉树-递归套路"><a href="#搜索二叉树-递归套路" class="headerlink" title="搜索二叉树(递归套路)"></a>搜索二叉树(递归套路)</h3><ul><li><strong>题目：</strong>如何判断一颗二叉树是搜索二叉树？</li><li><strong>搜索二叉树的特点：</strong>任何一个节点，左子树的节点一定比它小，右子树的节点一定比它大</li><li><strong>解题：</strong> 中序遍历一定是升序，如果某个位置有降序，一定不是搜索二叉树</li><li><font color=red>递归套路题解</font > :向我左树要信息，右树要信息，左树必须是搜索二叉树且左树最大值小于我，右树是搜索二叉树并且最小值大于我；左树信息：1.是否是搜索二叉树，2.最大值，3.最小值；右树也是</li><li><strong>注意：</strong>递归套路，可以解决一切树形DP 问题，无非是可能性的罗列有难度</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法1： 额外引入数组</span></span><br><span class="line"><span class="comment">// 节点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 中序遍历到一个数组中，然后判断数组是不是升序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isBST1</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ArrayList&lt;Node&gt; arr = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    in(head, arr);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr.get(i).value &lt;= arr.get(i - <span class="number">1</span>).value) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">in</span><span class="params">(Node head, ArrayList&lt;Node&gt; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    in(head.left, arr);</span><br><span class="line">    arr.add(head);</span><br><span class="line">    in(head.right, arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法2：递归方式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> preValue = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkBST</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> checkLeft = checkBST(head.left);</span><br><span class="line">    <span class="keyword">if</span> (!checkLeft) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 中序打印的时机，换成了中序比较的时机</span></span><br><span class="line">    <span class="keyword">if</span> (head.value &lt;= preValue) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        preValue = head.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> checkBST(head.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法3：递归套路</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归返回值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Info</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> isBST; <span class="comment">// 是否是搜索二叉树</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> max; <span class="comment">// 最大值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> min; <span class="comment">// 最小值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Info</span><span class="params">(<span class="keyword">boolean</span> i, <span class="keyword">int</span> ma, <span class="keyword">int</span> mi)</span> </span>&#123;</span><br><span class="line">        isBST = i;</span><br><span class="line">        max = ma;</span><br><span class="line">        min = mi;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Info <span class="title">process</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Info leftInfo = process(x.left);</span><br><span class="line">    Info rightInfo = process(x.right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> min = x.value;</span><br><span class="line">    <span class="keyword">int</span> max = x.value;</span><br><span class="line">    <span class="comment">// 最小值和最大值就是我当前节点的值和它比较得出的最小值和最大值</span></span><br><span class="line">    <span class="keyword">if</span> (leftInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        min = Math.min(min, leftInfo.min);</span><br><span class="line">        max = Math.max(max, leftInfo.max);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rightInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        min = Math.min(min, rightInfo.min);</span><br><span class="line">        max = Math.max(max, rightInfo.max);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 是否是搜索二叉树</span></span><br><span class="line">    <span class="keyword">boolean</span> isBST = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 左边有信息并且左边不是搜索二叉树</span></span><br><span class="line">    <span class="keyword">if</span> (leftInfo != <span class="keyword">null</span> &amp;&amp; !leftInfo.isBST) &#123;</span><br><span class="line">        isBST = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rightInfo != <span class="keyword">null</span> &amp;&amp; !rightInfo.isBST) &#123;</span><br><span class="line">        isBST = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 左边有信息，但是左边的最大值大于等于我的值</span></span><br><span class="line">    <span class="keyword">if</span> (leftInfo != <span class="keyword">null</span> &amp;&amp; leftInfo.max &gt;= x.value) &#123;</span><br><span class="line">        isBST = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 右边有信息，右边的最小值小于等于我当前值</span></span><br><span class="line">    <span class="keyword">if</span> (rightInfo != <span class="keyword">null</span> &amp;&amp; rightInfo.min &lt;= x.value) &#123;</span><br><span class="line">        isBST = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Info(isBST, max, min);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><ul><li>如何判断一个二叉树是完全二叉树</li><li>完全二叉树：一颗二叉树从左到右是依次变满的，即使不满，也是变满的样子</li><li>解题：二叉树宽度遍历，1.任何一个节点如果有有节点，没左节点，false；2.在第一个条件不违规情况，如果遇到第一个左右两个节点不双全情况，接下来遇到的所有节点，必须是叶子节点</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isCBT</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LinkedList&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 是否遇到过左右两个孩子不双全的节点</span></span><br><span class="line">    <span class="keyword">boolean</span> leaf = <span class="keyword">false</span>;</span><br><span class="line">    Node l = <span class="keyword">null</span>;</span><br><span class="line">    Node r = <span class="keyword">null</span>;</span><br><span class="line">    queue.add(head);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        head = queue.poll();</span><br><span class="line">        l = head.left;</span><br><span class="line">        r = head.right;</span><br><span class="line">        <span class="comment">// 如果遇到了不双全的节点之后，又发现当前节点不是叶节点</span></span><br><span class="line">        <span class="keyword">if</span> ((leaf &amp;&amp; (l != <span class="keyword">null</span> || r != <span class="keyword">null</span>)) || (l == <span class="keyword">null</span> &amp;&amp; r != <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (l != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.add(l);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.add(r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遇到左右两个节点不双全的情况，修改标记</span></span><br><span class="line">        <span class="keyword">if</span> (l == <span class="keyword">null</span> || r == <span class="keyword">null</span>) &#123;</span><br><span class="line">            leaf = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><ul><li>如何判断一棵树是平衡二叉树</li><li><strong>平衡二叉树特性：</strong>对于任何一个子树来说，左树的高度和右树的高度差，都不超过1</li><li><strong>解决思路：</strong>假设我可以向我的左树要信息，可以向右树要信息，如果我整棵树是平衡二叉树，我左树得是平的，右树得是平的，对于X节点来说，左树-右树高度差&lt;=1；我向左树要信息：1.是否是平的；2.高度是多少，右树要信息：1.是否是平的；2.高度是多少</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回值信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Info</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> isBalanced;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> height;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Info</span><span class="params">(<span class="keyword">boolean</span> i, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">        isBalanced = i;</span><br><span class="line">        height = h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Info <span class="title">process</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Info(<span class="keyword">true</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Info leftInfo = process(x.left);</span><br><span class="line">    Info rightInfo = process(x.right);</span><br><span class="line">    <span class="comment">// x为头的节点的高度：左树和右树较大的那个高度再加上我自己(+1)</span></span><br><span class="line">    <span class="keyword">int</span> height = Math.max(leftInfo.height, rightInfo.height) + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 是否是平衡树：我左树得是平衡，右树得是平衡树，并且我左树和右树的高度差的绝对值得小于2</span></span><br><span class="line">    <span class="keyword">boolean</span> isBalanced = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!leftInfo.isBalanced) &#123;</span><br><span class="line">        isBalanced = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!rightInfo.isBalanced) &#123;</span><br><span class="line">        isBalanced = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Math.abs(leftInfo.height - rightInfo.height) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        isBalanced = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Info(isBalanced, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h3><ul><li>如何判断一棵树是满二叉树</li><li>树最大深度L，节点个数N，满足N=2(L次方)-1</li><li><strong>解法(递归套路)：</strong>先求二叉树最大深度L，再求节点个数N，满足N=2(L次方)-1</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 满二叉树解法：递归套路</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回值信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Info</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> height;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> nodes;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Info</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        height = h;</span><br><span class="line">        nodes = n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Info all = process(head);</span><br><span class="line">    <span class="comment">// N=2(L次方)-1</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; all.height) - <span class="number">1</span> == all.nodes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Info <span class="title">process</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Info(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Info leftInfo = process(head.left);</span><br><span class="line">    Info rightInfo = process(head.right);</span><br><span class="line">    <span class="comment">// 高度等于左树和右树最高的高度+1</span></span><br><span class="line">    <span class="keyword">int</span> height = Math.max(leftInfo.height, rightInfo.height) + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 总个数等于左边的个数加上右边的个数加1</span></span><br><span class="line">    <span class="keyword">int</span> nodes = leftInfo.nodes + rightInfo.nodes + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Info(height, nodes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树最低公共祖先"><a href="#二叉树最低公共祖先" class="headerlink" title="二叉树最低公共祖先"></a>二叉树最低公共祖先</h3><ul><li>给定两个二叉树节点node1和node2，找到他们的最低公共祖先节点</li><li>解法1：遍历整棵树，把所有节点的父节点都维护到一个Map中，然后找到node1的所有父节点维护到set中，再遍历node2的所有的父，第一个在set中遇到的节点就是最低公共祖先</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">lca</span><span class="params">(Node head, Node o1, Node o2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    HashMap&lt;Node, Node&gt; parentMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    parentMap.put(head, <span class="keyword">null</span>);</span><br><span class="line">    fillParentMap(head, parentMap);</span><br><span class="line">    HashSet&lt;Node&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Node cur = o1;</span><br><span class="line">    set.add(cur);</span><br><span class="line">    <span class="comment">// 只有头节点才等于自己的父，如果当前节点不等于自己的父，就可以往上走</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">null</span> != parentMap.get(cur)) &#123;</span><br><span class="line">        cur = parentMap.get(cur);</span><br><span class="line">        set.add(cur);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// o1往上所有节点都在这个set里面，只有最初的head不在里面</span></span><br><span class="line">    cur = o2;</span><br><span class="line">    <span class="keyword">while</span> (!set.contains(cur)) &#123;</span><br><span class="line">        cur = parentMap.get(cur);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 维护整棵树的所有父节点到Map中</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fillParentMap</span><span class="params">(Node head, HashMap&lt;Node, Node&gt; fatherMap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        fatherMap.put(head.left, head);</span><br><span class="line">        fillParentMap(head.left, fatherMap);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (head.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        fatherMap.put(head.right, head);</span><br><span class="line">        fillParentMap(head.right, fatherMap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>解法2(非常抽象)：可能的情况有1：node1和node2互为公共祖先；2：node1和node2不互为公共祖先；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解法2：可能的情况有1：node1和node2互为公共祖先；2：node1和node2不互为公共祖先；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">lowestCommonAncestor</span><span class="params">(Node head, Node o1, Node o2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head == o1 || head == o2) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    Node left = lowestCommonAncestor(head.left, o1, o2);</span><br><span class="line">    Node right = lowestCommonAncestor(head.right, o1, o2);</span><br><span class="line">    <span class="keyword">if</span> (left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left != <span class="keyword">null</span> ? left : right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><ul><li>常见的表示图的方法：临接表法，和临接矩阵法，数组等</li><li>做模板，然后把所有的图的问题转化为自己熟悉的数据结构，带着模板上考场</li></ul><h3 id="图的宽度优先遍历"><a href="#图的宽度优先遍历" class="headerlink" title="图的宽度优先遍历"></a>图的宽度优先遍历</h3><h3 id="约瑟夫圆环问题"><a href="#约瑟夫圆环问题" class="headerlink" title="约瑟夫圆环问题"></a>约瑟夫圆环问题</h3><h2 id="逆波兰计算器"><a href="#逆波兰计算器" class="headerlink" title="逆波兰计算器"></a>逆波兰计算器</h2><ul><li>实现一个计算器，只有加减乘除法，没有括号，输入是一个字符串如10+2+3*5</li><li>解题：表达式转化为后缀表达式（逆波兰表达式）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解题</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String str = <span class="string">&quot;10+2+3*5&quot;</span>;</span><br><span class="line">    <span class="comment">// 表达式转换为操作数和操作符的中缀表达式数组</span></span><br><span class="line">    String[] strArr = changeStrArr(str);</span><br><span class="line">    <span class="comment">// 中缀表达式转化为后缀表达式</span></span><br><span class="line">    List&lt;String&gt; polandList = polandNotation(strArr);</span><br><span class="line">    System.out.println(polandList);</span><br><span class="line">    <span class="comment">// 后缀表达式计算</span></span><br><span class="line">    System.out.println(calculate(polandList));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字符串转成中缀的数组</span></span><br><span class="line"><span class="comment"> * 只有加减乘除，没有扩号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String[] changeStrArr(String str) &#123;</span><br><span class="line">    StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : str.toCharArray()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;+-*/&quot;</span>.contains(String.valueOf(c))) &#123;</span><br><span class="line">            stringBuilder.append(<span class="string">&quot;;&quot;</span>);</span><br><span class="line">            stringBuilder.append(c);</span><br><span class="line">            stringBuilder.append(<span class="string">&quot;;&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stringBuilder.append(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stringBuilder.toString().split(<span class="string">&quot;;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中缀表达式转化为后缀表达式</span></span><br><span class="line"><span class="comment"> * 1.初始化两个栈，运算符栈s1和储存中间结果的栈s2</span></span><br><span class="line"><span class="comment"> * 2.从左到右扫描中缀表达式</span></span><br><span class="line"><span class="comment"> * 3.遇到操作数，入栈s2</span></span><br><span class="line"><span class="comment"> * 4.遇到运算符，比较其与s1栈顶运算符的优先级：</span></span><br><span class="line"><span class="comment"> * (1).如果s1为空，或者栈顶运算符为左括号&quot;(&quot;,直接将运算符入栈；</span></span><br><span class="line"><span class="comment"> * (2).否则，若优先级比栈顶运算符高，也将运算符入栈s1;</span></span><br><span class="line"><span class="comment"> * (3).否则，将s1栈顶运算符弹出入栈s2中，再次转到(4-1) 与s1中新的栈顶运算符比较；</span></span><br><span class="line"><span class="comment"> * 本方法只考虑到加减乘除操作，不考虑扩号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">polandNotation</span><span class="params">(String[] str)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; s2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Stack&lt;String&gt; s1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String itm : str) &#123;</span><br><span class="line">        <span class="comment">// 遇到操作数，直接入栈s2</span></span><br><span class="line">        <span class="keyword">if</span> (itm.matches(<span class="string">&quot;\\d+&quot;</span>)) &#123;</span><br><span class="line">            s2.add(itm);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果栈不为空，并且栈顶优先级比我目前运算符优先级高，就把栈顶运算符如s2，然后吧当前运算符如s1</span></span><br><span class="line">            <span class="keyword">while</span> (!s1.isEmpty() &amp;&amp; Operation.getValue(s1.peek()) &gt;= Operation.getValue(itm)) &#123;</span><br><span class="line">                s2.add(s1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">            s1.push(itm);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!s1.isEmpty()) &#123;</span><br><span class="line">        s2.add(s1.pop());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 运算符比较</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Operation</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> ADD = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> SUB = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> MUL = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> DIV = <span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">(String operation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">switch</span> (operation) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                result = ADD;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                result = SUB;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                result = MUL;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                result = DIV;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 逆波兰表达式计算</span></span><br><span class="line"><span class="comment"> * 1.定义一个栈，匹配到非运算符就入栈</span></span><br><span class="line"><span class="comment"> * 2.遇到运算符就把栈顶两个数字出栈，用后出栈的数和先出栈的数做运算，把运算结果再入栈</span></span><br><span class="line"><span class="comment"> * 3.直到最后，栈顶结果即为计算结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(List&lt;String&gt; polandList)</span> </span>&#123;</span><br><span class="line">    Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String itm : polandList) &#123;</span><br><span class="line">        <span class="comment">// 匹配的是多位数</span></span><br><span class="line">        <span class="keyword">if</span> (itm.matches(<span class="string">&quot;\\d+&quot;</span>)) &#123;</span><br><span class="line">            stack.push(itm);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 弹出两个数，并运算，再入栈</span></span><br><span class="line">            <span class="keyword">int</span> num2 = Integer.parseInt(stack.pop());</span><br><span class="line">            <span class="keyword">int</span> num1 = Integer.parseInt(stack.pop());</span><br><span class="line">            <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (itm.equals(<span class="string">&quot;+&quot;</span>)) &#123;</span><br><span class="line">                res = num1 + num2;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (itm.equals(<span class="string">&quot;-&quot;</span>)) &#123;</span><br><span class="line">                res = num1 - num2;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (itm.equals(<span class="string">&quot;*&quot;</span>)) &#123;</span><br><span class="line">                res = num1 * num2;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (itm.equals(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">                res = num1 / num2;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;运算符有误&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(String.valueOf(res));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Integer.parseInt(stack.pop());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="前缀树"><a href="#前缀树" class="headerlink" title="前缀树"></a>前缀树</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前缀树数据结构</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> pass;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> end;</span><br><span class="line">    <span class="keyword">public</span> Node1[] nexts;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// char tmp = &#x27;b&#x27;  (tmp - &#x27;a&#x27;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        pass = <span class="number">0</span>;</span><br><span class="line">        end = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 0    a</span></span><br><span class="line">        <span class="comment">// 1    b</span></span><br><span class="line">        <span class="comment">// 2    c</span></span><br><span class="line">        <span class="comment">// ..   ..</span></span><br><span class="line">        <span class="comment">// 25   z</span></span><br><span class="line">        <span class="comment">// nexts[i] == null   i方向的路不存在</span></span><br><span class="line">        <span class="comment">// nexts[i] != null   i方向的路存在</span></span><br><span class="line">        nexts = <span class="keyword">new</span> Node1[<span class="number">26</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (word == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>[] str = word.toCharArray();</span><br><span class="line">    Node1 node = root;</span><br><span class="line">    node.pass++;</span><br><span class="line">    <span class="keyword">int</span> path = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123; <span class="comment">// 从左往右遍历字符</span></span><br><span class="line">        path = str[i] - <span class="string">&#x27;a&#x27;</span>; <span class="comment">// 由字符，对应成走向哪条路</span></span><br><span class="line">        <span class="keyword">if</span> (node.nexts[path] == <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.nexts[path] = <span class="keyword">new</span> Node1();</span><br><span class="line">        &#125;</span><br><span class="line">        node = node.nexts[path];</span><br><span class="line">        node.pass++;</span><br><span class="line">    &#125;</span><br><span class="line">    node.end++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// word这个单词之前加入过几次</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (word == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>[] chs = word.toCharArray();</span><br><span class="line">    Node1 node = root;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chs.length; i++) &#123;</span><br><span class="line">        index = chs[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (node.nexts[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node = node.nexts[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node.end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有加入的字符串中，有几个是以pre这个字符串作为前缀的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">prefixNumber</span><span class="params">(String pre)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pre == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>[] chs = pre.toCharArray();</span><br><span class="line">    Node1 node = root;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chs.length; i++) &#123;</span><br><span class="line">        index = chs[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (node.nexts[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node = node.nexts[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node.pass;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (search(word) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span>[] chs = word.toCharArray();</span><br><span class="line">        Node1 node = root;</span><br><span class="line">        node.pass--;</span><br><span class="line">        <span class="keyword">int</span> path = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chs.length; i++) &#123;</span><br><span class="line">            path = chs[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (--node.nexts[path].pass == <span class="number">0</span>) &#123;</span><br><span class="line">                node.nexts[path] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.nexts[path];</span><br><span class="line">        &#125;</span><br><span class="line">        node.end--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><p>在某一个标准下，优先考虑最满足标准的样本，最后考虑最不满足标准的样本，最终得到一个答案的算法，叫做贪心算法。也就是说，不从整体最优上加以考虑，所做出的是某种意义上的局部最优解。</p><h3 id="会议室占用问题"><a href="#会议室占用问题" class="headerlink" title="会议室占用问题"></a>会议室占用问题</h3><p>问题：只有一个会议室，多个会议占用会议室的时间有冲突，如何让会议室进行的会议最多，返回最多的会议场次</p><p>解：哪个会议结束时间早，就优先安排，然后接下来继续找下一个会议结束时间早的会议</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 会议开始时间和结束时间</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Program</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Program</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 比较器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ProgramComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Program</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Program o1, Program o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1.end - o2.end;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会议的开始时间和结束时间，都是数值，不会 &lt; 0</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bestArrange2</span><span class="params">(Program[] programs)</span> </span>&#123;</span><br><span class="line">    Arrays.sort(programs, <span class="keyword">new</span> ProgramComparator());</span><br><span class="line">    <span class="keyword">int</span> timeLine = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 依次遍历每一个会议，结束时间早的会议先遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; programs.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (timeLine &lt;= programs[i].start) &#123;</span><br><span class="line">            result++;</span><br><span class="line">            timeLine = programs[i].end;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="八皇后问题"><a href="#八皇后问题" class="headerlink" title="八皇后问题"></a>八皇后问题</h3><h2 id="多线程相关"><a href="#多线程相关" class="headerlink" title="多线程相关"></a>多线程相关</h2><h3 id="三个线程交替打印"><a href="#三个线程交替打印" class="headerlink" title="三个线程交替打印"></a>三个线程交替打印</h3><ul><li>三个线程交替打印，1线程打印1；2线程打印2；3线程打印3；1线程打印4……一直打印到100</li><li>解题方式由很多，无非就是涉及到线程通信问题以及修改共享变量问题</li></ul><p><strong>题解1：</strong>不加锁，利用线程可见性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPrint</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Thread1());</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Thread2());</span><br><span class="line">        Thread thread3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Thread3());</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;t1=&quot;</span> + i);</span><br><span class="line">                    i++;</span><br><span class="line">                    flag = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;t2=&quot;</span> + i);</span><br><span class="line">                    i++;</span><br><span class="line">                    flag = <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread3</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (flag == <span class="number">2</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;t3=&quot;</span> + i);</span><br><span class="line">                    i++;</span><br><span class="line">                    flag = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>题解2</strong>：LockSupport 实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPrint2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> number = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Thread thread1, thread2,thread3;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        thread1 = <span class="keyword">new</span> Thread(ThreadPrint2::thread1, <span class="string">&quot;thread1&quot;</span>);</span><br><span class="line">        thread2 = <span class="keyword">new</span> Thread(ThreadPrint2::thread2, <span class="string">&quot;thread2&quot;</span>);</span><br><span class="line">        thread3 = <span class="keyword">new</span> Thread(ThreadPrint2::thread3, <span class="string">&quot;thread3&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">thread1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (ThreadPrint2.number &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;thread1:&quot;</span> + ThreadPrint2.number);</span><br><span class="line">            ThreadPrint2.number++;</span><br><span class="line">            LockSupport.unpark(thread2);</span><br><span class="line">            LockSupport.park();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">thread2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (ThreadPrint2.number &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            System.out.println(<span class="string">&quot;thread2:&quot;</span> + ThreadPrint2.number);</span><br><span class="line">            ThreadPrint2.number++;</span><br><span class="line">            LockSupport.unpark(thread3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">thread3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (ThreadPrint2.number &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            System.out.println(<span class="string">&quot;thread3:&quot;</span> + ThreadPrint2.number);</span><br><span class="line">            ThreadPrint2.number++;</span><br><span class="line">            LockSupport.unpark(thread1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>题解3</strong>：经典实现 实现wait-&gt;notifyAll</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPrint3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (count &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (count % <span class="number">3</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---&gt;&quot;</span> + count);</span><br><span class="line">                            count++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        lock.notifyAll();</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125;</span><br><span class="line">                    lock.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;T1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (count &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (count % <span class="number">3</span> == <span class="number">2</span>) &#123;</span><br><span class="line">                            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---&gt;&quot;</span> + count);</span><br><span class="line">                            count++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        lock.notifyAll();</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125;</span><br><span class="line">                    lock.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;T2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (count &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (count % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---&gt;&quot;</span> + count);</span><br><span class="line">                            count++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        lock.notifyAll();</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125;</span><br><span class="line">                    lock.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;T3&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>题解4</strong>：Lock实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPrint4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        Condition c1 = lock.newCondition();</span><br><span class="line">        Condition c2 = lock.newCondition();</span><br><span class="line">        Condition c3 = lock.newCondition();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (cnt &lt;= <span class="number">100</span> &amp;&amp; cnt % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;----&gt;&quot;</span> + cnt);</span><br><span class="line">                    cnt++;</span><br><span class="line">                    c2.signal();</span><br><span class="line">                    c1.await();</span><br><span class="line">                &#125;</span><br><span class="line">                c3.signal();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;T1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (cnt &lt;= <span class="number">100</span> &amp;&amp; cnt % <span class="number">3</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;----&gt;&quot;</span> + cnt);</span><br><span class="line">                    cnt++;</span><br><span class="line">                    c3.signal();</span><br><span class="line">                    c2.await();</span><br><span class="line">                &#125;</span><br><span class="line">                c1.signal();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;T2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (cnt &lt;= <span class="number">100</span> &amp;&amp; cnt % <span class="number">3</span> == <span class="number">2</span>) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;----&gt;&quot;</span> + cnt);</span><br><span class="line">                    cnt++;</span><br><span class="line">                    c1.signal();</span><br><span class="line">                    c3.await();</span><br><span class="line">                &#125;</span><br><span class="line">                c2.signal();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;T3&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他算法题"><a href="#其他算法题" class="headerlink" title="其他算法题"></a>其他算法题</h2>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试知识点总结</title>
      <link href="/2022/01/27/%E9%9D%A2%E8%AF%95%E5%9F%BA%E5%9C%B0/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2022/01/27/%E9%9D%A2%E8%AF%95%E5%9F%BA%E5%9C%B0/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="面向对象的特征"><a href="#面向对象的特征" class="headerlink" title="面向对象的特征?"></a>面向对象的特征?</h3><p>面向对象的特征:封装、继承、多态、抽象。 封装:就是把对象的属性和行为(数据)结合为一个独立的整体，并尽可能隐藏对象的内 部实现细节，就是把不想告诉或者不该告诉别人的东西隐藏起来，把可以告诉别人的公开，别人只能用我提供的功能实现需求，而不知道是如何实现的。增加安全性。 继承:子类继承父类的数据属性和行为，并能根据自己的需求扩展出新的行为，提高了代 码的复用性。 多态:指允许不同的对象对同一消息做出相应。即同一消息可以根据发送对象的不同而采 用多种不同的行为方式(发送消息就是函数调用)。封装和继承几乎都是为多态而准备 的，在执行期间判断引用对象的实际类型，根据其实际的类型调用其相应的方法。 抽象:表示对问题领域进行分析、设计中得出的抽象的概念，是对一系列看上去不同，但是本质上相同的具体概念的抽象。在 Java 中抽象用 abstract 关键字来修饰，用abstract修饰类时，此类就不能被实例化，从这里可以看出，抽象类(接口)就是为了继承而存在的。</p><h3 id="常见的RuntimeException"><a href="#常见的RuntimeException" class="headerlink" title="常见的RuntimeException"></a>常见的RuntimeException</h3><ol><li>java.lang.NullPointerException 空指针异常;出现原因:调用了未经初始化的对象或者是不存在 的对象。</li><li>java.lang.ClassNotFoundException 指定的类找不到;出现原因:类的名称和路径加载错误;通常 都是程序试图通过字符串来加载某个类时可能引发异常。</li><li>java.lang.NumberFormatException 字符串转换为数字异常;出现原因:字符型数据中包含非数 字型字符。</li><li>java.lang.IndexOutOfBoundsException 数组角标越界异常，常见于操作数组对象时发生。</li><li>java.lang.IllegalArgumentException 方法传递参数错误。</li><li>java.lang.ClassCastException 数据类型转换异常。 </li><li>java.lang.NoClassDefFoundException 未找到类定义错误。</li><li>SQLException SQL 异常，常见于操作数据库时的 SQL 语句错误。</li><li>java.lang.InstantiationException实例化异常。</li><li>java.lang.NoSuchMethodException方法不存在异常。</li></ol><h3 id="常见的引用类型"><a href="#常见的引用类型" class="headerlink" title="常见的引用类型"></a>常见的引用类型</h3><p>java的引用类型一般分为四种：<strong>强引用</strong>、<strong>软引用</strong>、弱引用、虚引用</p><ul><li><strong>强引用</strong>：普通的变量引用</li><li><strong>软引用</strong>：将对象用SoftReference软引用类型的对象包裹，正常情况不会被回收，但是GC做完后发现释放不出空间存放新的对象，则会把这些软引用的对象回收掉。<strong>软引用可用来实现内存敏感的高速缓存。</strong></li><li><strong>弱引用</strong>：将对象用WeakReference软引用类型的对象包裹，弱引用跟没引用差不多，<strong>GC会直接回收掉</strong>，很少用</li><li><strong>虚引用：</strong>虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系，几乎不用</li></ul><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="jvm内存模型"><a href="#jvm内存模型" class="headerlink" title="jvm内存模型"></a>jvm内存模型</h3><img src="https://raw.githubusercontent.com/lizejiao/img_bed/master/images/20210920235127.png"  /><h3 id="对象创建过程"><a href="#对象创建过程" class="headerlink" title="对象创建过程"></a>对象创建过程</h3><img src="https://raw.githubusercontent.com/lizejiao/img_bed/master/images/jvm-object.png"/><ol><li><strong>类加载检查：</strong>虚拟机遇到一条new指令时，首先将去检查这个类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程：类加载过程中会通过jvm自带的三个类加载器按照双亲委派机制进行类加载过程，我们常见的ClassNotFoundException就是在这里发生的，我们代码中的静态代码块里面的内容也是在这个过程中执行的。</li><li><strong>分配内存：</strong>在类加载检查通过后，虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务等同于把 一块确定大小的内存从Java堆中划分出来。</li><li><strong>初始化零值：</strong>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</li><li><strong>设置对象头</strong>：初始化零值之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息(即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例)、对象的哈希码（HashCode）、对象的GC分代年龄、锁状态标志等信息。这些信息存放在对象的对象头Object Header之中。</li><li><strong>执行<init>方法</strong>：执行方法，即对象按照程序员的意愿进行初始化。对应到语言层面上讲，就是<strong>为属性赋值</strong>（注意，这与上面的赋零值不同，这是由程序员赋的值），和<strong>执行构造方法</strong>。</li></ol><h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><ol><li>引用计数法</li><li>可达性分析法</li></ol><p>对于可达性分析法，我们知道需要存在一个GC Root的对象作为起点，从这个节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连（就是从GC Roots到对象不可达）时，则证明此对象是不可用的。</p><h3 id="GC-Root有哪些？"><a href="#GC-Root有哪些？" class="headerlink" title="GC Root有哪些？"></a>GC Root有哪些？</h3><ul><li>虚拟机栈中的引用对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用对象</li><li>本地方法栈中JNI引用对象</li></ul><h3 id="垃圾回收器有哪些？"><a href="#垃圾回收器有哪些？" class="headerlink" title="垃圾回收器有哪些？"></a>垃圾回收器有哪些？</h3><ol><li><strong>Serial收集器</strong>(-XX:+UseSerialGC -XX:+UseSerialOldGC)：Serial（串行）收集器是一个单线程收集器，新生代采用复制算法，老年代采用标记-整理算法。</li><li><strong>Parallel Scavenge收集器</strong>(-XX:+UseParallelGC(年轻代),-XX:+UseParallelOldGC(老年代)) ：Parallel收集器其实就是Serial收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和Serial收集器类似。默认的收集线程数跟cpu核数相同</li><li><strong>ParNew收集器</strong>(-XX:+UseParNewGC)：只有它能与CMS收集器（真正意义上的并发收集器，后面会介绍到）配合工作</li><li><strong>CMS收集器</strong>(-XX:+UseConcMarkSweepGC(old))：收集器是一种以获取最短回收停顿时间为目标的收集器CMS收集器是一种 “标记-清除”算法实现的。CMS等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是CPU中用于运行用户代码的时间与CPU总消耗时间的比值。</li><li><strong>G1收集器</strong>(-XX:+UseG1GC)：G1 (Garbage-First)是一款面向服务器的垃圾收集器，主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征。G1将Java堆划分为多个大小相等的独立区域（Region），JVM最多可以有2048个Region。一般Region大小等于堆大小除以2048，比如堆大小为4096M，则Region大小为2M</li><li><strong>Shenandoah：</strong>可以看成是G1升级版</li><li><strong>ZGC收集器：</strong>ZGC是一款JDK 11中新加入的具有实验性质的低延迟垃圾收集器。1、支持TB量级的堆；2、最大GC停顿时间不超10ms；3、奠定未来GC特性的基础；4、最糟糕的情况下吞吐量会降低15%</li></ol><h3 id="CMS运行过程，缺点？"><a href="#CMS运行过程，缺点？" class="headerlink" title="CMS运行过程，缺点？"></a>CMS运行过程，缺点？</h3><p>整个过程分为四个步骤</p><ol><li><strong>初始标记(STW)：</strong> 暂停所有的其他线程(STW)，并记录下gc roots直接能引用的对象，速度很快</li><li><strong>并发标记：</strong> 并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对象图的过程， 这个过程耗时较长但是不需要停顿用户线程，因为用户程序继续运行，可能会有导致已经标记过的对象状态发生改变。</li><li><strong>重新标记(STW)：</strong> 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短。</li><li><strong>并发清理：</strong> 开启用户线程，同时GC线程开始对未标记的区域做清扫。</li><li><strong>并发重置：</strong>重置本次GC过程中的标记数据。</li></ol><p><strong>缺点：</strong></p><ol><li>对CPU资源敏感（会和服务抢资源）</li><li>无法处理浮动垃圾(在并发标记和并发清理阶段又产生垃圾，这种浮动垃圾只能等到下一次gc再清理了)；</li><li>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生，当然通过参数-XX:+UseCMSCompactAtFullCollection可以让jvm在执行完标记清除后再做整理</li><li>并发模式失败(最大问题)，执行过程中的不确定性，会存在上一次垃圾回收还没执行完，然后垃圾回收又被触发的情况，特别是在并发标记和并发清理阶段会出现，一边回收，系统一边运行，也许没回收完就再次触发full gc，也就是”concurrent mode failure”，此时会进入stop the world，用serial old垃圾收集器来回收</li></ol><h3 id="G1运行过程"><a href="#G1运行过程" class="headerlink" title="G1运行过程"></a>G1运行过程</h3><p>G1收集器一次GC的运作过程大致分为以下几个步骤：</p><ol><li>初始标记（initial mark，STW）：暂停所有的其他线程，并记录下gc roots直接能引用的对象，速度很快 ；</li><li>并发标记（Concurrent Marking）：同CMS的并发标记</li><li>最终标记（Remark，STW）：同CMS的重新标记</li><li>筛选回收（Cleanup，STW）：G1采用复制算法回收几乎不会有太多内存碎片</li></ol><h3 id="G1适合什么场景"><a href="#G1适合什么场景" class="headerlink" title="G1适合什么场景"></a>G1适合什么场景</h3><ol><li>50%以上的堆被存活对象占用</li><li>对象分配和晋升的速度变化非常大</li><li>垃圾回收时间特别长，超过1秒</li><li>8GB以上的堆内存(建议值)</li><li>停顿时间是500ms以内</li></ol><h3 id="判断元空间是无用的类"><a href="#判断元空间是无用的类" class="headerlink" title="判断元空间是无用的类"></a>判断元空间是无用的类</h3><p>法区（元空间）主要回收的是无用的类，那么如何判断一个类是无用的类呢？类需要同时满足下面3个条件才能算是 <strong>“无用的类”</strong> ：</p><ul><li>该类所有的对象实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li><li>加载该类的 ClassLoader 已经被回收。（条件苛刻，自定义类加载器会被回收掉）</li><li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul><h3 id="安全点和安全区域"><a href="#安全点和安全区域" class="headerlink" title="安全点和安全区域"></a>安全点和安全区域</h3><p><strong>安全点：</strong>就是指代码中一些特定的位置,当线程运行到这些位置时它的状态是确定的,这样JVM就可以安全的进行一些操作,比如GC等，所以GC不是想什么时候做就立即触发的，是需要等待所有线程运行到安全点后才能触发。这些特定的安全点位置主要有以下几种:</p><ol><li>方法返回之前</li><li>调用某个方法之后</li><li>抛出异常的位置</li><li>循环的末尾</li></ol><p>安全区域：如果一个线程处于 Sleep 或中断状态，它就不能响应 JVM 的中断请求，引用关系不会发生变化。在这个区域内的任意地方开始 GC 都是安全的。</p><h3 id="类加载器？双亲委派，好处？"><a href="#类加载器？双亲委派，好处？" class="headerlink" title="类加载器？双亲委派，好处？"></a>类加载器？双亲委派，好处？</h3><p><strong>JDK自带有三个类加载器</strong>：bootstrapClassLoader(引导类加载器)、ExtClassLoader(扩展类加载器)、AppClassLoader(系统类加载器)，bootstrapClassLoader是ExtClassLoader的父类加载器(并不是集成关系，是属性关系)默认加载%JAVA_HOME%/lib下的jar包和class文件ExtClassLoader是AppClassLoader的父类加载器，默认加载%JAVA_HOME%/lib/ext文件夹下的jar包和class文件AppClassLoader是自定义类加载器，负责加载classpath下的类文件</p><p><strong>双亲委派：</strong>分为向上委派和向下查找，每一个类加载器都有各自的缓存，都会记录自己加载过的类，当一个类需要加载，AppClassLoader先查找自己的缓存有没有加载过这个类，没有加载过就会调用ExtClassLoader去查找，ExtClassLoader没有加载过，就会调用bootstrapClassLoader类去加载，如果bootstrapClassLoader没有加载过，就会去他的类加载路径查找，如果没有找到ExtClassLoader就会查找他的类加载路径，向上委派就是查找缓存，查找到bootstrapClassLoader位置，向下查找就是查找类加载路径，查找到发起的类加载器为止。</p><p><strong>好处：</strong>1、安全性，避免自己写的类替换掉java核心类；2、避免类重复加载，相同class文件不同的类加载器加载的也是两个类。</p><h3 id="YGC和FGC发生的场景"><a href="#YGC和FGC发生的场景" class="headerlink" title="YGC和FGC发生的场景"></a>YGC和FGC发生的场景</h3><p>YGC：对新生代堆进行gc。频率比较高，因为大部分对象的存活寿命较短，在新生代里被回收。性能耗费较小。edn空间不足,执行 </p><p>FGC：全堆范围的gc。默认堆空间使用到达80%(可调整)的时候会触发fgc。生产环境，一般比较少会触发fgc，有时10天或一周左右会有一次。</p><p>老年代空间不足，永久区空间不足，调用方法System.gc() ，ygc时的悲观策略, dump live的内存信息时(jmap –dump:live)，都会执行full gc</p><h3 id="jstack，jmap，Jstat作用"><a href="#jstack，jmap，Jstat作用" class="headerlink" title="jstack，jmap，Jstat作用"></a>jstack，jmap，Jstat作用</h3><p><strong>jmap：</strong>可以用来查看内存信息，实例个数以及占用内存大小</p><ul><li>jmap -heap 进程号：查看堆内存信息</li><li>jmap ‐dump:format=b,file=eureka.hprof 进程号： 堆内存的快照信息，添加jvm参数也可以设置内存溢出自动导出dump文件</li></ul><p><strong>jstack:</strong> 可以获得java线程的运行情况，可以查看死锁，阻塞，等待</p><ul><li>Jstack -l PID &gt;&gt; 123.txt 打印某个java进程的堆栈信息</li></ul><p><strong>Jstat：</strong>jstat命令可以查看堆内存各部分的使用量，以及加载类的数量</p><ul><li>jstat -gc pid 最常用，可以评估程序内存使用及GC压力整体情况</li></ul><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><ul><li><p>死锁：是指一组互相竞争资源的线程，因为互相等待，导致永久阻塞的现象。</p></li><li><p>原因：必须同时满足以下四个条件</p><ol><li>共享互斥条件：共享资源x和y只能被一个线程占用</li><li>占有且等待：线程t1已经占有共享资源x，在等待共享资源y的时候不释放共享资源x</li><li>不可抢占：其他线程不能强行抢占线程t1占有的资源</li><li>循环等待：线程t1等待线程t2占有的资源，线程t2等待线程t1占有的资源</li></ol></li><li><p>如何避免死锁：</p><ol><li>既然产生死锁必然满足四个条件，那我们只要打破四个条件中的一个就可以避免，第一个互斥条件是无法被破坏的，因为锁本身就是通过互斥来解决线程安全的</li><li>针对后三个条件，我们逐一分析，占有且等待这个条件我们可以一次性申请所有资源，不存在等待；</li><li>不可抢占这个条件：占有部分资源的线程进一步申请其他资源的时候如果申请不到，可以主动释放已占有的资源，这样不可抢占这条件就破坏了；</li><li>循环等待这个条件：可以按照顺序去申请资源进行预防，就是说资源是有线性顺序的，申请的时候可以先申请资源序号小的，再申请资源序号大的，线性化之后，就不存在循环等待了</li></ol></li></ul><h3 id="sleep和wait区别"><a href="#sleep和wait区别" class="headerlink" title="sleep和wait区别"></a>sleep和wait区别</h3><ol><li>sleep 是 Thread 类的静态本地方法，wait 则是 Object 类的本地方法</li><li>sleep方法不会释放锁，但是wait会释放，而且会加入到等待队列中</li><li>sleep方法不依赖于同步器synchronized，但是wait需要依赖synchronized关键字</li><li>sleep不需要被唤醒（休眠之后推出阻塞），但是wait需要（不指定时间需要被别人中断）</li><li>sleep 一般用于当前线程休眠，或者轮循暂停操作，wait 则多用于多线程之间的通信</li><li>sleep 会让出 CPU 执行时间且强制上下文切换，而 wait 则不一定，wait 后可能还是有机会重新竞争到锁继续执行的。</li></ol><p>sleep就是把cpu的执行资格和执行权释放出去，不再运行此线程，当定时时间结束再取回cpu资源，参与cpu的调度，获取到cpu资源后就可以继续运行了。而如果sleep时该线程有锁，那么sleep不会释放这个锁，而是把锁带着进入了冻结状态，也就是说其他需要这个锁的线程根本不可能获取到这个锁。也就是说无法执行程序。如果在睡眠期间其他线程调用了这个线程的interrupt方法，那么这个线程也会抛出interruptexception异常返回，这点和wait是一样的。</p><p>当我们调用wait（）方法后，线程会放到等待池当中，等待池的线程是不会去竞争同步锁。只有调用了notify（）或notifyAll()后等待池的线程才会开始去竞争锁，notify（）是随机从等待池选出一个线程放到锁池，而notifyAll()是将等待池的所有线程放到锁池当中</p><h3 id="Volitile作用"><a href="#Volitile作用" class="headerlink" title="Volitile作用"></a>Volitile作用</h3><ol><li>可见性：对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。内存屏障-&gt;汇编Lock关键字-&gt;缓存一致性协议</li><li>原子性：对任意单个volatile变量的读/写具有原子性，但类似于volatile++这种复合操作不具有原子性</li><li>有序性：对volatile修饰的变量的读写操作前后加上各种特定的内存屏障来禁止指令重排序来保障有序性</li></ol><h3 id="Volitile如何保证可见性"><a href="#Volitile如何保证可见性" class="headerlink" title="Volitile如何保证可见性"></a>Volitile如何保证可见性</h3><ol><li><strong>缓存一致性：</strong>在共享内存多处理器系统中，每个处理器都有一个单独的缓存内存，共享数据在主内存和各处理器私有缓存同时存在。当数据的一个副本发生更改，其他副本需要感知到最新修改数据。缓存一致性的手段主要有：</li><li>总线锁定：总线锁定就是使用处理器提供的一个 LOCK＃信号，当其中一个处理器在总线上输出此信号时，其它处理器的请求将被阻塞，那么该处理器可以独占共享内存。</li><li>总线窥探(Bus snooping)：是缓存中的一致性控制器窥探总线事务的一种方案（该方案由Ravishankar和Goodman于1983年提出）当数据被多个缓存共享时，一个处理器修改了共享数据的值，可以是刷新缓存块或使缓存块失效还可以通过缓存块状态的改变，来达到缓存一致性的目的，主要取决于窥探协议类型：<ol><li>写失效（Write-invalidate） ：当一个处理器写入共享缓存时，其他缓存中的所有共享副本都会通过总线窥探失效。确保处理器只能读写一个数据副本，其他缓存中的所有其他副本都无效。这是最常用的窥探协议。MSI、MESI、MOSI、MOESI和MESIF协议属于该类型。</li><li>写更新（Write-update）：当处理器写入一个共享缓存块时，其他缓存的所有共享副本都会通过总线窥探更新。这个方法将写数据广播到总线上的所有缓存中。它比写失效协议引起更大的总线流量，因此这种方法不常见。Dragon和firefly协议属于此类别。</li></ol></li></ol><h3 id="指令重排序"><a href="#指令重排序" class="headerlink" title="指令重排序"></a>指令重排序</h3><p>Java语言规范规定JVM线程内部维持顺序化语义，即只要程序的最终结果与它顺序化情况的结果相等，那么指令的执行顺序可以与代码顺序不一致，此过程叫指令的重排序。指令重排序的意义：：JVM能根据处理器特性（CPU多级缓存系统、多核处理器等）适当的对机器指令进行重排序，使机器指令能更符合CPU的执行特性，最大限度的发挥机器性能。</p><h3 id="Java线程的生命周期"><a href="#Java线程的生命周期" class="headerlink" title="Java线程的生命周期"></a>Java线程的生命周期</h3><ol><li>NEW（初始化状态）</li><li>RUNNABLE（可运行状态+运行状态）</li><li>BLOCKED（阻塞状态）</li><li>WAITING（无时限等待）</li><li>TIMED_WAITING（有时限等待）</li><li>TERMINATED（终止状态）</li></ol><p>在操作系统层面，有五种状态，Java 线程中的 BLOCKED、WAITING、TIMED_WAITING 是一种状态，即前面我们提到的休眠状态。也就是说只要 Java 线程处于这三种状态之一，那么这个线程就永远没有 CPU 的使用权。</p><h3 id="linux查看线程命令"><a href="#linux查看线程命令" class="headerlink" title="linux查看线程命令"></a>linux查看线程命令</h3><ul><li><p>ps  - fe 查看所有进程</p></li><li><p>ps  - fT  - p <PID> 查看某个进程（ PID ）的所有线程</p></li><li><p>kill 杀死进程</p></li><li><p>top 按大写  H  切换是否显示线程</p></li><li><p>top  - H  - p <PID> 查看某个进程（ PID ）的所有线程</p></li><li><p>jps 命令查看所有  Java  进程</p></li><li><p>jstack <PID> 查看某个  Java  进程（ PID ）的所有线程状态</p></li><li><p>jconsole 来查看某个  Java  进程中线程的运行情况（图形界面）</p></li></ul><h3 id="Java线程的实现方式"><a href="#Java线程的实现方式" class="headerlink" title="Java线程的实现方式"></a>Java线程的实现方式</h3><ol><li>方式1：使用 Thread类或继承Thread类</li><li>实现 Runnable 接口配合Thread</li><li>使用有返回值的 Callable，借助线程池使用</li><li>使用 lambda</li></ol><p>本质上Java中实现线程只有一种方式，都是通过new Thread()创建线程，调用Thread#start启动线程最终都会调用Thread#run方法</p><h3 id="Thread常用方法"><a href="#Thread常用方法" class="headerlink" title="Thread常用方法"></a>Thread常用方法</h3><p><strong>sleep方法</strong></p><ul><li>调用 sleep 会让当前线程从 Running 进入TIMED_WAITING状态，不会释放对象锁</li><li>其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出InterruptedException，并且会清除中断标志</li><li>睡眠结束后的线程未必会立刻得到执行</li><li>sleep当传入参数为0时，和yield相同</li></ul><p><strong>yield方法</strong></p><ul><li>yield会释放CPU资源，让当前线程从 Running 进入 Runnable状态，让优先级更高（至少是相同）的线程获得执行机会，不会释放对象锁；</li><li>假设当前进程只有main线程，当调用yield之后，main线程会继续运行，因为没有比它优先级更高的线程；</li><li>具体的实现依赖于操作系统的任务调度器</li></ul><h3 id="ThreadLocal的实现原理"><a href="#ThreadLocal的实现原理" class="headerlink" title="ThreadLocal的实现原理"></a>ThreadLocal的实现原理</h3><p>ThreadLocal的实现原理，每一个Thread维护一个ThreadLocalMap，key为使用弱引用的ThreadLocal<br>实例，value为线程变量的副本</p><h3 id="ThreadLocal应用场景"><a href="#ThreadLocal应用场景" class="headerlink" title="ThreadLocal应用场景"></a>ThreadLocal应用场景</h3><ol><li>在进行对象跨层传递的时候，使用ThreadLocal可以避免多次传递，打破层次间的约束。</li><li>线程间数据隔离</li><li>进行事务操作，用于存储线程事务信息。</li><li>数据库连接，Session会话管理。<ul><li>Spring框架在事务开始时会给当前线程绑定一个Jdbc Connection,在整个事务过程都是使用该线程绑定的connection来执行数据库操作，实现了事务的隔离性。Spring框架里面就是用的ThreadLocal来实现这种隔离</li></ul></li></ol><h3 id="ThreadLocal内存泄露原因，如何避免"><a href="#ThreadLocal内存泄露原因，如何避免" class="headerlink" title="ThreadLocal内存泄露原因，如何避免"></a>ThreadLocal内存泄露原因，如何避免</h3><ol><li>强引用：使用最普遍的引用(new)，一个对象具有强引用，不会被垃圾回收器回收。当内存空间不足，<br>Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不回收这种对象。</li><li>弱引用：JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。在java中，用<br>java.lang.ref.WeakReference类来表示。可以在缓存中使用弱引用。</li><li>ThreadLocal正确的使用方法<ul><li>每次使用完ThreadLocal都调用它的remove()方法清除数据</li><li>将ThreadLocal变量定义成private static，这样就一直存在ThreadLocal的强引用，也就能保证任<br>何时候都能通过ThreadLocal的弱引用访问到Entry的value值，进而清除掉 。</li></ul></li></ol><h3 id="synchronized和ReentranLock区别？"><a href="#synchronized和ReentranLock区别？" class="headerlink" title="synchronized和ReentranLock区别？"></a>synchronized和ReentranLock区别？</h3><p>synchronized是jvm层面的关键字，底层是通过monitor对象来完成，monitor对象底层依赖于操作系统的Mutex互斥量，底层调用的是操作系统的Pthread库，是由操作系统来维护的，而操作系统分为用户空间和内核空间的，JVM运行在用户空间，调用底层操作系统cpu会进行一轮状态切换，这个状态切换是比较重型操作，wait/notify等方法也依赖monitor对象只有在同步块或方法中才能调wait/notify等方法。</p><p>Lock是具体类（java.util.concurrent.Locks.Lock)是api层面的锁，是从jdk1.5开始引入的，那个时候synchronized性能还比较差，ReentranLock的出现是为了解决当时性能差的问题</p><ul><li><p>使用方法：synchronized不需要手动释放锁，ReentranLock则需要用户手动释放锁(需要lock()和unlock()配合try/finally使用)</p></li><li><p>等待是否可中断：synchronized不可中断，除非抛出异常或者执行完成，ReentranLock可中断</p></li></ul><ol><li>设置超时方法tryLock(long timeout, timeUnit unit)</li><li>lockInterruptibly()放代码块忠，调用interrupt()方法可中断</li></ol><ul><li><p>加锁是否公平：synchronized非公平锁；ReentranLock 两者都可以，默认非公平锁，构造方法传入true为公平锁，false为非公平锁</p></li><li><p>锁绑定多个条件Condition：synchronized 没有；ReentranLock  用来实现分组唤醒需要唤醒的线程，可以精确唤醒，不像synchronized要么随机唤醒一个线程，要么全部唤醒</p></li></ul><h3 id="线程池参数有，核心线程配置，原因？"><a href="#线程池参数有，核心线程配置，原因？" class="headerlink" title="线程池参数有，核心线程配置，原因？"></a>线程池参数有，核心线程配置，原因？</h3><ol><li>corePoolSize：线程池中的核心线程数</li><li>maximumPoolSize：线程池中允许的最大线程数。如果当前阻塞队列满了，且继续提交任务，则创建新的线程执行任务</li><li>keepAliveTime：核心线程外的线程存活超时时间</li><li>unit：时间单位</li><li>workQueue：用来保存等待被执行的任务的阻塞队列，且任务必须实现Runable接口</li><li>threadFactory：用来创建新线程</li><li>线程池的饱和策略：( AbortPolicy：直接抛出异常，默认策略；CallerRunsPolicy：用调用者所在的线程来执行任务；DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；DiscardPolicy：直接丢弃任务)</li></ol><p><strong>CPU密集型（CPU-bound）</strong></p><p>CPU密集型也叫计算密集型，在多重程序系统中，大部份时间用来做计算、逻辑判断等CPU动作的程序称之CPU bound。例如一个计算圆周率至小数点一千位以下的程序，在执行的过程当中绝大部份时间用在三角函数和开根号的计算，便是属于CPU bound的程序。</p><p><font color=red face="黑体">线程数 = CPU核数+1 (现代CPU支持超线程)</font> </p><p><strong>IO密集型（I/O bound）</strong></p><p>IO密集型指的是系统的CPU性能相对硬盘、内存要好很多，此时，系统运作，大部分的状况是CPU在等I/O (硬盘/内存) 的读/写操作</p><p> <font color=red face="黑体">线程数 = （（线程等待时间+线程CPU时间）/线程CPU时间 ）* CPU数目</font> </p><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="Set-List-Map有什么区别"><a href="#Set-List-Map有什么区别" class="headerlink" title="Set,List,Map有什么区别"></a>Set,List,Map有什么区别</h3><p><img src="https://raw.githubusercontent.com/lizejiao/img_bed/master/images/20211012160343.png"></p><ul><li>结构特点<ol><li>List 和 Set 是存储单列数据的集合， Map 是存储键和值这样的双列数据的集合;</li><li>List中存储的数据是有顺序，并且允许重复; Map 中存储的数据是没有顺序的，其键是不能重复的，它的值是可以有重复的， Set 中存储的数据是无序的，且不允许有重复，但元素在集合中的位置由元素的hashcode决定，位置是固定的(Set集合根据 hashcode 来进行数据的存储，所以位置是固定的，但是位置不是用户可以控制的，所以对于用户来说 set 中的元素还是无序的);</li></ol></li></ul><h3 id="HashMap和HashTable有什么区别？"><a href="#HashMap和HashTable有什么区别？" class="headerlink" title="HashMap和HashTable有什么区别？"></a>HashMap和HashTable有什么区别？</h3><p>区别：</p><ol><li>HashMap方法没有synchronized修饰，线程非安全，HashTable线程安全；</li><li>HashMap允许key和value为null，而HashTable不允许</li></ol><h3 id="HashMap底层实现"><a href="#HashMap底层实现" class="headerlink" title="HashMap底层实现"></a>HashMap底层实现</h3><ol><li>jdk1.7底层采用的是数组+链表实现；jdk1.8底层采用数组+链表+红黑树实现，相对于1.7提升了查询的性能</li><li>链表过度到红黑树的阈值为8，红黑树退化为链表的阈值是6，原因在源码中332行给了明确解释(Poisson distribution)泊松分布，这是数学里面类似于正态分布的一个问题，这是统计学里面的一些东西</li><li>HashMap初始化的数组长度为16(算法导论中的除法散列法讲到 K取模m得到一个对应的位置，根据具体位置插入一个数据值，假如长度是16，长度范围就是0<del>15，取模之后我的余数为0</del>15之间，而算法导论中指出，一个不太接近2的整数幂的素数（质数：只能被1和它本身整出的数），常常是m的最好选择。但是hashMap中未采用素数，而是采用2的n次方(合数)作为数组长度)，原因为：1、更便于位置计算；2、方便做数据迁移。</li><li>为了保证存入的数据均匀的散列分布在数组中，需要设计良好的hash散列算法(hashMap中采用扰动函数来做的：移位和异或相关操作ConcurrentHashMap源码中684行spread方法，即：让int的高16位异或它本身)，尽可能的避免hash冲突(概率问题)，具体落到数组哪个节点并非是通过取模运算得出，而是通过与上数组长度-1即可(只需要int类型数32位的后四位参与运算)，即可得到0~15之间的数，因为取模运算效率远低于位运算，所以这也是hashMap要求底层数组长度必须为2的n次方的原因之一（ConcurrentHashMap源码中514行规定）。</li></ol><h3 id="HashMap-put流程"><a href="#HashMap-put流程" class="headerlink" title="HashMap put流程"></a>HashMap put流程</h3><ol><li>HashMap/ConcurrentHashMap 并不是通过构造函数创建默认空间的，而是通过put数据的时候获取到对应的数据空间的，如果数组长度是0，则通过CAS操作后初始化数组，如果有线程正在做初始化数组操作，其他线程则让出时间片</li><li></li></ol><h3 id="HashMap扩容流程"><a href="#HashMap扩容流程" class="headerlink" title="HashMap扩容流程"></a>HashMap扩容流程</h3><ol><li>hashMap规定了当我的数组快放满的时候就要开始扩容了，什么时候算是快放满？HashMap是通过扩容因子来规定的</li><li>HashMap规定扩容因子是0.75，如果默认长度是16，也就是说当HashMap底层数组的容量达到12的时候进行扩容操作。0.75则是根据统计学得来的。<code>private static final float LOAD_FACTOR = 0.75f;</code></li><li>扩容首先要创建新的数组（原来大小左移1位）ConcurrentHaspMap源码2367行开始扩容操作</li><li>转移旧数据到新的数组中去（怎么计算扩容后数据下标位置？）原来：h&amp;(n-1)计算下标位置，扩容后 h$(31)，原来占用4个二进制位，扩容后占用5个二进制位，所以只需要看第五位即可，如果第五位是0，扩容后的的下标跟原位置一样，如果是1，新下标位置在原数组的位置的基础上加上原来数组长度即可，这也是数组长度采用2的N次方扩容的第二个原因</li><li>假设原来长度是128，扩容后是256，整体扩容方式是通过多线程方式运行的，但是要保证数据不能乱，将原来数组分段，规定每个线程最少负责16个桶的迁移工作，8个线程可以并行执行，如果小于16个桶，直接单线程执行</li></ol><h3 id="为什么选择用红黑树"><a href="#为什么选择用红黑树" class="headerlink" title="为什么选择用红黑树"></a>为什么选择用红黑树</h3><p>二叉树在极端情况下会退化为链表，查询时间复杂度跟链表相似，而AVL树，SB树，红黑树，都属于平衡二叉树，尽量保持左子树和右子树的高度差不要相差太大，而这三种树的差别就在于左树和右树的高度规则不同。</p><ul><li>AVL树：严格意义平衡树，的要求左子树和右子树的高度差不能超过1，损失了部分插入性能，带来了高效的查询</li><li>SB树：</li><li>红黑树：要求最长子树不能超过最短子树的2倍即可，损失了部分查询性能，使得查询效率高于链表的同时，相比于其他树提升了插入性能，尽量做到了插入和查询的一个平衡点，而HashMap则是查多，插入少(这里的插入指的是产生Hash冲突下的插入)，所以红黑树更适合HashMap来做底层的存储结构。</li></ul><h3 id="ConcurrentHaspMap"><a href="#ConcurrentHaspMap" class="headerlink" title="ConcurrentHaspMap"></a>ConcurrentHaspMap</h3><ol><li>ConcurrentHaspMap是线程安全的HashMap，它底层采用大量的CAS操作</li></ol><h2 id="spring"><a href="#spring" class="headerlink" title="spring"></a>spring</h2><p>spring是一个框架，更像是一个生态环境，在我们的开发流程中，所有的框架基本上都依赖于spring，spring起到了一个IOC容器的作用，用来承载我们整体的bean对象，它帮我们处理了bean对象从创建到销毁的整个生命周期的管理，我们在使用spring的时候，可以使用配置文件，也可以使用注解的方式进行相关开发。spring框架的工作主要流程是，当我们程序开始启动之后，spring把注解或者配置文件定义好的bean对象转化成为BeanDefinitionran，然后通BeanFactoryPostProcessor完成整个的BeanDefinitionran的解析和加载过程，然后根据BeanDefinitionran通过反射的方式创建bean对象，然后进行对象初始化，包括：aware接口相关操作，BeanPostProcessor操作，Init-methord操作完成整个bean的创建过程，之后我们就可以使用了。</p><h3 id="Bean的初始化过程"><a href="#Bean的初始化过程" class="headerlink" title="Bean的初始化过程"></a>Bean的初始化过程</h3><img src="https://raw.githubusercontent.com/lizejiao/img_bed/master/images/20210920235247.png"  /><h3 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h3><p><img src="https://raw.githubusercontent.com/lizejiao/img_bed/master/images/20210921185234.png"></p><h3 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h3><h3 id="AOP的顺序"><a href="#AOP的顺序" class="headerlink" title="AOP的顺序"></a>AOP的顺序</h3><p>  spring4和spring5是不一样的</p><h3 id="springMVC处理请求流程"><a href="#springMVC处理请求流程" class="headerlink" title="springMVC处理请求流程"></a>springMVC处理请求流程</h3><p><img src="https://raw.githubusercontent.com/lizejiao/img_bed/master/images/20211012154755.png"></p><h3 id="spring事务的传播机制"><a href="#spring事务的传播机制" class="headerlink" title="spring事务的传播机制"></a>spring事务的传播机制</h3><ol><li>TransactionDefinition.PROPAGATION_<strong>REQUIRED</strong>：支持当前事务，如果没有事务会创建一个新的事务</li><li>TransactionDefinition.PROPAGATION_<strong>SUPPORTS</strong>：支持当前事务，如果没有事务的话以非事务方式执行</li><li>TransactionDefinition.PROPAGATION_<strong>MANDATORY</strong>：支持当前事务，如果没有事务抛出异常</li><li>TransactionDefinition.PROPAGATION_<strong>REQUIRES_NEW</strong>：创建一个新的事务并挂起当前事务</li><li>TransactionDefinition.PROPAGATION_<strong>NOT_SUPPORTED</strong>：以非事务方式执行，如果当前存在事务则将当前事务挂起</li><li>TransactionDefinition.PROPAGATION_<strong>NEVER</strong>：以非事务方式进行，如果存在事务则抛出异常</li><li>TransactionDefinition.PROPAGATION_<strong>NESTED</strong>：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则进行与PROPAGATION_REQUIRED类似的操作。</li></ol><h2 id="RPC框架"><a href="#RPC框架" class="headerlink" title="RPC框架"></a>RPC框架</h2><h3 id="你知道的json序列化方式？"><a href="#你知道的json序列化方式？" class="headerlink" title="你知道的json序列化方式？"></a>你知道的json序列化方式？</h3><ol><li>谷歌的Gson</li><li>json-smart：号称是速度最快的JSON解析器</li><li>Common Lang3(3.1)的SerializationUtils</li><li>阿里巴巴的 FastJson、以及 Jackson</li></ol><h3 id="两个系统之间怎么交互的？"><a href="#两个系统之间怎么交互的？" class="headerlink" title="两个系统之间怎么交互的？"></a>两个系统之间怎么交互的？</h3><ol><li> 套接字（socket）：这是一种更为一般得进程间通信机制，它可用于网络中不同机器之间的进程间通信，应用非常广泛。</li><li> 可以通过RPC框架（dubbo、feign等）进行远程调用</li><li> 也可以引入消息队列等消息中间件作为系统之间信息交互的桥梁</li><li> 共享内存（shared memory）：可以说这是最有用的进程间通信方式。它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更</li></ol><h3 id="dubbo的序列化？"><a href="#dubbo的序列化？" class="headerlink" title="dubbo的序列化？"></a>dubbo的序列化？</h3><p>dubbo 支持 hession、Java 二进制序列化、json、SOAP 文本序列化多种序列化协议。 hessian 是其默认的序列化协议</p><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="网络七层模型"><a href="#网络七层模型" class="headerlink" title="网络七层模型"></a>网络七层模型</h3><ul><li>第一层：物理层</li><li>第二层：数据链路层 802.2、802.3ATM、HDLC、FRAME RELAY </li><li>第三层：网络层 IP、IPX、ARP、APPLETALK、ICMP </li><li>第四层：传输层 TCP、UDP、SPX </li><li>第五层：会话层 <strong>RPC</strong>、SQL、NFS 、X WINDOWS、ASP</li><li>第六层：表示层 ASCLL、PICT、TIFF、JPEG、 MIDI、MPEG </li><li>第七层：应用层 HTTP,FTP,SNMP等</li></ul><img src="https://raw.githubusercontent.com/lizejiao/img_bed/master/images/net7.png" style="zoom: 90%;" /><ol><li>物理层：物理层负责最后将信息编码成电流脉冲或其它信号用于网上传输；</li><li>数据链路层：数据链路层通过物理网络链路􏰁供数据传输。不同的数据链路层定义了不同的网络和协 议特征,其中包括物理编址、网络拓扑结构、错误校验、数据帧序列以及流控。可以简单的理解为：规定了0和1的分包形式，确定了网络数据包的形式；</li><li>网络层：网络层负责在源和终点之间建立连接。可以理解为，此处需要确定计算机的位置，怎么确定？IPv4，IPv6！</li><li>传输层：传输层向高层提供可靠的端到端的网络数据流服务。可以理解为：每一个应用程序都会在网卡注册一个端口号，该层就是端口与端口的通信！常用的（TCP／IP）协议；</li><li>会话层：会话层建立、管理和终止表示层与实体之间的通信会话；建立一个连接（自动的手机信息、自动的网络寻址）;</li><li>表示层：表示层提供多种功能用于应用层数据编码和转化,以确保以一个系统应用层发送的信息 可以被另一个系统应用层识别;可以理解为：解决不同系统之间的通信，eg：Linux下的QQ和Windows下的QQ可以通信；</li><li>应用层：OSI 的应用层协议包括文件的传输、访问及管理协议(FTAM) ,以及文件虚拟终端协议(VIP)和公用管理系统信息(CMIP)等;</li></ol><h3 id="http1-0和http1-1区别"><a href="#http1-0和http1-1区别" class="headerlink" title="http1.0和http1.1区别"></a>http1.0和http1.1区别</h3><p>HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。 主要区别主要体现在：</p><ol><li><strong>缓存处理</strong>，在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</li><li><strong>带宽优化及网络连接的使用</strong>，HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li><li><strong>错误通知的管理</strong>，在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</li><li><strong>Host头处理</strong>，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。</li><li><strong>长连接</strong>，HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。</li></ol><h3 id="HTTPS与HTTP的一些区别"><a href="#HTTPS与HTTP的一些区别" class="headerlink" title="HTTPS与HTTP的一些区别"></a>HTTPS与HTTP的一些区别</h3><ul><li>HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。</li><li>HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。</li><li>HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li><li>HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。</li></ul><h3 id="http三次握手四次挥手"><a href="#http三次握手四次挥手" class="headerlink" title="http三次握手四次挥手"></a>http三次握手四次挥手</h3><p>其实这么说是不太准确的，应该说是tcp协议建立连接要3次握手，断开连接要4次挥手，而http是基于tcp协议的，所以通常我们也这么说，tcp可以提供全双工的数据流传输服务</p><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><ol><li>TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了LISTEN（监听）状态；</li><li>TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这是报文首部中的同部位SYN=1，同时选择一个初始序列号 seq=x ，此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。</li><li>TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号是ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时，TCP服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号。</li><li>TCP客户进程收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，自己的序列号seq=x+1，此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。</li><li>当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。</li></ol><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><h3 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h3><ul><li>提供者(Provider)启动时，会向注册中心写入自己的元数据信息(调用方式)。</li><li>消费者(Consumer)启动时，也会在注册中心写入自己的元数据信息，并且订阅服务提供者，路由和配置元数据的信息。</li><li>服务治理中心(duubo-admin)启动时，会同时订阅所有消费者，提供者，路由和配置元数据的信息。</li><li>当提供者离开或者新提供者加入时，注册中心发现变化会通知消费者和服务治理中心。</li></ul><h2 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h2><h3 id="NIO三大核心组件"><a href="#NIO三大核心组件" class="headerlink" title="NIO三大核心组件"></a>NIO三大核心组件</h3><p> <strong>Channel(通道)， Buffer(缓冲区)，Selector(多路复用器)</strong></p><ol><li>channel 类似于流，每个 channel 对应一个 buffer缓冲区，buffer 底层就是个数组</li><li>channel 会注册到 selector 上，由 selector 根据 channel 读写事件的发生将其交由某个空闲的线程处理</li><li>NIO 的 Buffer 和 channel 都是既可以读也可以写</li></ol><h3 id="Netty线程模型"><a href="#Netty线程模型" class="headerlink" title="Netty线程模型"></a>Netty线程模型</h3><p>Netty通过Reactor模型基于多路复用器接收并处理用户请求，内部实现boss和work两个线程池，其中boss的线程负责处理请求的accept事件，当接收到accept事件的请求时，把对应的socket封装到一个NioSocketChannel中，并交给work线程池，其中work线程池负责请求的read和write事件，交由对应的Handler处理。</p><img src="https://raw.githubusercontent.com/lizejiao/img_bed/master/images/Netty.png" style="zoom: 60%;" /><img src="https://raw.githubusercontent.com/lizejiao/img_bed/master/images/Netty2.png" style="zoom: 80%;"/> <ol><li>Netty 抽象出两组线程池BossGroup和WorkerGroup，BossGroup专门负责接收客户端的连接, WorkerGroup专门负责网络的读写</li><li>BossGroup和WorkerGroup类型都是NioEventLoopGroup</li><li>NioEventLoopGroup 相当于一个事件循环<strong>线程组</strong>, 这个组中含有多个事件循环线程 ， 每一个事件循环线程是NioEventLoop</li><li>每个NioEventLoop都有一个selector , 用于监听注册在其上的socketChannel的网络通讯</li><li> 每个BossNioEventLoop线程内部循环执行的步骤有 3 步</li><li>处理accept事件 , 与client 建立连接 , 生成 NioSocketChannel </li><li>将NioSocketChannel注册到某个worker  NIOEventLoop上的selector</li><li>处理任务队列的任务 ， 即runAllTasks</li><li>每个workerNIOEventLoop线程循环执行的步骤<ol><li>轮询注册到自己selector上的所有NioSocketChannel 的read, write事件</li><li>处理 I/O 事件， 即read , write 事件， 在对应NioSocketChannel 处理业务</li><li>runAllTasks处理任务队列TaskQueue的任务 ，一些耗时的业务处理一般可以放入TaskQueue中慢慢处理，这样不影响数据在 pipeline 中的流动处理</li></ol></li></ol><h3 id="Netty模块组件"><a href="#Netty模块组件" class="headerlink" title="Netty模块组件"></a>Netty模块组件</h3><ul><li><p><strong>Bootstrap、ServerBootstrap</strong>：Bootstrap 意思是引导，一个 Netty 应用通常由一个 Bootstrap 开始，主要作用是配置整个 Netty 程序，串联各个组件，Netty 中 Bootstrap 类是客户端程序的启动引导类，ServerBootstrap 是服务端启动引导类。</p></li><li><p><strong>Future、ChannelFuture</strong>：正如前面介绍，在 Netty 中所有的 IO 操作都是异步的，不能立刻得知消息是否被正确处理。但是可以过一会等它执行完成或者直接注册一个监听，具体的实现就是通过 Future 和 ChannelFutures，他们可以注册一个监听，当操作执行成功或失败时监听会自动触发注册的监听事件。</p></li><li><p><strong>Channel</strong>：Netty 网络通信的组件，能够用于执行网络 I/O 操作。Channel 为用户提供：</p><ol><li><p>当前网络连接的通道的状态（例如是否打开？是否已连接？）</p></li><li><p>网络连接的配置参数 （例如接收缓冲区大小）</p></li><li><p>提供异步的网络 I/O 操作(如建立连接，读写，绑定端口)，异步调用意味着任何 I/O 调用都将立即返回，并且不保证在调用结束时所请求的 I/O 操作已完成。</p></li><li><p>调用立即返回一个 ChannelFuture 实例，通过注册监听器到 ChannelFuture 上，可以 I/O 操作成功、失败或取消时回调通知调用方。</p></li><li><p>支持关联 I/O 操作与对应的处理程序。</p></li><li><p>不同协议、不同的阻塞类型的连接都有不同的 Channel 类型与之对应。</p></li><li><pre><code>NioSocketChannel，异步的客户端 TCP Socket 连接。NioServerSocketChannel，异步的服务器端 TCP Socket 连接。NioDatagramChannel，异步的 UDP 连接。NioSctpChannel，异步的客户端 Sctp 连接。NioSctpServerChannel，异步的 Sctp 服务器端连接。这些通道涵盖了 UDP 和 TCP 网络 IO 以及文件 IO。</code></pre></li></ol></li><li><p><strong>Selector</strong>：Netty 基于 Selector 对象实现 I/O 多路复用，通过 Selector 一个线程可以监听多个连接的 Channel 事件。当向一个 Selector 中注册 Channel 后，Selector 内部的机制就可以自动不断地查询(Select) 这些注册的 Channel 是否有已就绪的 I/O 事件（例如可读，可写，网络连接完成等），这样程序就可以很简单地使用一个线程高效地管理多个 Channel 。</p></li><li><p><strong>NioEventLoop</strong>：NioEventLoop 中维护了一个线程和任务队列，支持异步提交执行任务，线程启动时会调用 NioEventLoop 的 run 方法，执行 I/O 任务和非 I/O 任务：I/O 任务，即 selectionKey 中 ready 的事件，如 accept、connect、read、write 等，由 processSelectedKeys 方法触发。非 IO 任务，添加到 taskQueue 中的任务，如 register0、bind0 等任务，由 runAllTasks 方法触发。</p></li><li><p><strong>NioEventLoopGroup</strong>：NioEventLoopGroup，主要管理 eventLoop 的生命周期，可以理解为一个线程池，内部维护了一组线程，每个线程(NioEventLoop)负责处理多个 Channel 上的事件，而一个 Channel 只对应于一个线程。</p></li><li><p><strong>ChannelHandler</strong>：ChannelHandler 是一个接口，处理 I/O 事件或拦截 I/O 操作，并将其转发到其 ChannelPipeline(业务处理链)中的下一个处理程序。</p></li><li><p><strong>ChannelHandlerContext</strong>：保存 Channel 相关的所有上下文信息，同时关联一个 ChannelHandler 对象。</p></li><li><p><strong>ChannelPipline</strong>：保存 ChannelHandler 的 List，用于处理或拦截 Channel 的入站事件和出站操作。ChannelPipeline 实现了一种高级形式的拦截过滤器模式，使用户可以完全控制事件的处理方式，以及 Channel 中各个的 ChannelHandler 如何相互交互。在 Netty 中每个 Channel 都有且仅有一个 ChannelPipeline 与之对应，它们的组成关系如下：</p></li></ul><img src="https://raw.githubusercontent.com/lizejiao/img_bed/master/images/ChannelPipline.png" style="zoom: 60%;"/> <p>一个 Channel 包含了一个 ChannelPipeline，而 ChannelPipeline 中又维护了一个由 ChannelHandlerContext 组成的双向链表，并且每个 ChannelHandlerContext 中又关联着一个 ChannelHandler。read事件(入站事件)和write事件(出站事件)在一个双向链表中，入站事件会从链表 head 往后传递到最后一个入站的 handler，出站事件会从链表 tail 往前传递到最前一个出站的 handler，两种类型的 handler 互不干扰。</p><h3 id="Netty粘包拆包"><a href="#Netty粘包拆包" class="headerlink" title="Netty粘包拆包"></a>Netty粘包拆包</h3><p>TCP是一个流协议，就是没有界限的一长串二进制数据。TCP作为传输层协议并不不了解上层业务数据的具体含义，它会根据TCP缓冲区的实际情况进行数据包的划分，所以在业务上认为是一个完整的包，可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这就是所谓的TCP粘包和拆包问题。面向流的通信是无消息保护边界的。</p><p><strong>解决方案</strong></p><ol><li><p>消息定长度，传输的数据大小固定长度，例如每段的长度固定为100字节，如果不够空位补空格</p></li><li><p>在数据包尾部添加特殊分隔符，比如下划线，中划线等，这种方法简单易行，但选择分隔符的时候一定要注意每条数据的内部一定不能出现分隔符。</p></li><li><p>发送长度：发送每条数据的时候，将数据的长度一并发送，比如可以选择每条数据的前4位是数据的长度，应用层处理时可以根据长度来判断每条数据的开始和结束。</p><p>Netty提供了多个解码器，可以进行分包的操作，如下：</p><ol><li>LineBasedFrameDecoder （回车换行分包）</li><li>DelimiterBasedFrameDecoder（特殊分隔符分包）</li><li>FixedLengthFrameDecoder（固定长度报文来分包）</li></ol></li></ol><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="ACID理论"><a href="#ACID理论" class="headerlink" title="ACID理论"></a>ACID理论</h3><p>​        事务处理几乎是每一个信息系统中都会涉及到的问题，它存在的意义就是保证系统中的数据是正确的，不同数据间不会产生矛盾，也就是保证数据状态的一致性（Consistency），理论上，要达成这个目标需要三方面的共同努力：</p><ol><li>原子性（Atomic）：在同一项业务处理过程中，事务保证了多个对数据的修改，要么同时成功，要么一起被撤销。原子性是由undolog日志来保证的，它记录了需要回滚的日志信息，事务回滚时，撤销已经执行成功的sql。</li><li>隔离性（Isolation）：在不同的业务处理过程中，事务保证了各自业务正在读、写的数据互相独立，不会彼此影响。隔离性是由MVCC来保证的。</li><li>持久性（Durability）：事务应当保证所有被成功提交的数据修改都能够正确地被持久化，不丢失数据。持久性由redolog来保证的，mysql修改数据的时候会在redolog中记录一份日志数据，就算数据没有保存成功，只要日志保存成功了，数据仍然不会丢失。</li></ol><p>以上就是事务的“ACID”的概念提法。我自己对这种已经形成习惯的“ACID”的提法是不太认同的，因为这四种特性并不正交，<strong>A、I、D 是手段，C 是目的</strong>，完全是为了拼凑个单词缩写才弄到一块去，误导的弊端已经超过了易于传播的好处。</p><h3 id="Mysql索引结构"><a href="#Mysql索引结构" class="headerlink" title="Mysql索引结构"></a>Mysql索引结构</h3><p>mysql的索引结构有：二叉树、红黑树、hash表、BTree、B+Tree</p><ul><li>二叉树</li></ul><img src="https://raw.githubusercontent.com/lizejiao/img_bed/master/images/clipboard.png" style="zoom: 33%;" /> <ul><li>Hash表</li><li>B+Tree</li></ul><h3 id="InnoDB和MyISAM区别"><a href="#InnoDB和MyISAM区别" class="headerlink" title="InnoDB和MyISAM区别"></a>InnoDB和MyISAM区别</h3><table><thead><tr><th>区别</th><th>InnoDB</th><th>MyISAM</th></tr></thead><tbody><tr><td>事务</td><td>支持</td><td>不支持</td></tr><tr><td>外键</td><td>支持</td><td>不支持</td></tr><tr><td>索引</td><td>聚簇索引和非聚簇索引</td><td>非聚簇索引</td></tr><tr><td>行锁</td><td>支持</td><td>不支持</td></tr><tr><td>表锁</td><td>支持</td><td>支持</td></tr><tr><td>存储文件</td><td>frm(表结构)，ibd(数据和索引)</td><td>frm，myi(索引文件)，myd(数据文件)</td></tr><tr><td>具体行数</td><td>全表扫描统计行数</td><td>通过变量保存行数</td></tr></tbody></table><ul><li>MyISAM不支持事务，在执行查询语句SELECT前，会自动给涉及的所有表加读锁,在执行update、insert、delete操作会自动给涉及的表加写锁。</li><li>InnoDB在执行查询语句SELECT时(非串行隔离级别)，(因为有mvcc机制)不会加锁。但是update、insert、delete操作会加行锁。简而言之，就是<strong>读锁会阻塞写，但是不会阻塞读。而写锁则会把读和写都阻塞</strong>。</li></ul><h3 id="B树和B-数的区别"><a href="#B树和B-数的区别" class="headerlink" title="B树和B+数的区别"></a>B树和B+数的区别</h3><p><strong>B-Tree</strong></p><img src="https://raw.githubusercontent.com/lizejiao/img_bed/master/images/BTree.png" style="zoom: 50%;" /><p><strong>B+Tree(B-Tree变种)</strong></p><img src="https://raw.githubusercontent.com/lizejiao/img_bed/master/images/B%2BTree.png" style="zoom:50%;" /><ol><li>B+Tree非叶子节点不存储data，只存储冗余索引，叶子节点包含所有索引字段  。优点：可以放更多的索引，BTree非叶子节点会存储索引和数据</li><li>B+Tree叶子节点用指针连接。优点：提高区间访问的性能（范围查找），BTree叶子节点指针为空</li></ol><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><table><thead><tr><th align="left">事务隔离级别</th><th align="left">脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td align="left">读未提交（read-uncomm</td><td align="left"></td><td></td><td></td></tr><tr><td align="left">读已提交（read-committed）</td><td align="left">否</td><td>是</td><td>是</td></tr><tr><td align="left">可重复读（repeatable-read）  <font color=red face="黑体">mysql默认</font></td><td align="left">否</td><td>否</td><td>是</td></tr><tr><td align="left">串行化（serializable）</td><td align="left">否</td><td>否</td><td>否</td></tr></tbody></table><ul><li>Mysql在可重复度隔离级别下通过MVCC保证事务隔离性</li><li>幻读是指当一个事务A读取某一个范围的数据时，另一个事务B在这个范围插入行，A事务再次读取这个范围数据时，会产生幻读</li></ul><h3 id="Mysql幻读是怎么解决的"><a href="#Mysql幻读是怎么解决的" class="headerlink" title="Mysql幻读是怎么解决的"></a>Mysql幻读是怎么解决的</h3><p>首先要确认一下幻读是怎么产生的，先弄清两个概念，那就是当前读和快照读</p><ul><li>当前读</li></ul><p>像select lock in share mode(共享锁)，select for update，update，insert，delete（排他锁）这些操作都是一种当前读，为什么叫当前读？就是他读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取记录进行加锁</p><ul><li>快照读</li></ul><p>​    像不加锁的select操作就是快照读，也就是不加锁的非阻塞读；快照读的前提是隔离级别不是串行化，串行级别的快照读会退化成当前读，快照读的实现是基于多版本并发控制，也就是MVCC，可以认为MVCC是行锁的一个变种，但是很多情况下避免加锁操作，快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本</p><p><font color=red face="黑体">如果只有快照读是不会产生幻读问题，只有快照读和当前读一起使用的时候才会产生幻读。</font></p><p>Mysql在可重复度隔离级别下可以通过MVCC和临键锁（记录锁+间隙锁）解决幻读问题。</p><h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><p>对于mvcc的理解，可以从数据库三种并发场景来说</p><ol><li>第一种是读和读的并发：就是两个线程A和B同时进行读操作，这种情况下呢，不会产生任何的并发问题</li><li>第二种是读写并发：就是说两个线程A和B在同一时刻分别进行读写操作，这种情况下可能会对数据库的数据造成一些问题，第一、事务隔离性问题；第二、会造成脏读，幻读，不可重复读的问题</li><li>第三种是写和写的并发：就是两个线程A和B同时进行写操作，这种情况下可能会存在数据更新的丢失问题</li><li>MVCC就是为了解决事务操作中并发安全问题的，无锁并发控制技术，全称就是：多版本并发控制，他是通过数据库记录中的隐式字段Undo日志和ReadView来实现的，MVCC主要解决三个问题：第一、通过MVCC可以解决读写并发阻塞问题，从而提高数据库的并发处理能力；第二、MVCC采用的是乐观锁的方式实现，降低了死锁的概率；第三、解决了一致性读的问题，也就是事务启动的时候，根据某个条件去读取到的数据，知道事务结束的时候再去执行相同条件，还是读到同一份数据，不会发生变化变化，而我们在使用MVCC的时候，一般是根据业务场景来选择组合搭配，乐观锁或者悲观锁，MVCC用来解决读写冲突，而乐观锁悲观锁用来解决写和写的冲突，从而最大程度去提高数据库的并发性能。</li></ol><h3 id="什么场景会引发幻读"><a href="#什么场景会引发幻读" class="headerlink" title="什么场景会引发幻读"></a>什么场景会引发幻读</h3><p>幻读是指在同一个事务中，存在前后两次查询同一个范围的数据，但是第二次查询却看到了第一次查询没看到的行，一般情况下特指事务执行中新增的其他行。</p><h3 id="sql在mysql的执行过程"><a href="#sql在mysql的执行过程" class="headerlink" title="sql在mysql的执行过程"></a>sql在mysql的执行过程</h3><img src="https://raw.githubusercontent.com/lizejiao/img_bed/master/images/20211116173949.png"/> <h3 id="事务怎么保证一致性"><a href="#事务怎么保证一致性" class="headerlink" title="事务怎么保证一致性"></a>事务怎么保证一致性</h3><p>redo log是InnoDB存储引擎层的日志，又称重做日志文件，用于记录事务操作的变化，记录的是数据修改之后的值，不管事务是否提交都会记录下来。如数据库掉电，InnoDB存储引擎会使用redo log恢复到掉电前的时刻，以此来保证数据的完整性。在一条更新语句进行执行的时候，InnoDB引擎会把更新记录写到redo log日志中，然后更新内存，此时算是语句执行完了，然后在空闲的时候或者是按照设定的更新策略将redo log中的内容更新到磁盘中，这里涉及到<code>WAL</code>即<code>Write Ahead logging</code>技术，他的关键点是先写日志，再写磁盘。</p><h3 id="binlog-、undo-、redo"><a href="#binlog-、undo-、redo" class="headerlink" title="binlog 、undo 、redo"></a>binlog 、undo 、redo</h3><ol><li>redo log通常是物理日志，记录的是数据页的物理修改，而不是某一行或某几行修改成怎样怎样，它用来恢复提交后的物理数据页(恢复数据页，且只能恢复到最后一次提交的位置)。</li><li>undo用来回滚行记录到某个版本。undo log一般是逻辑日志，根据每行记录进行记录。</li><li>二进制日志（binlog）</li></ol><h3 id="聚簇和非聚簇索引"><a href="#聚簇和非聚簇索引" class="headerlink" title="聚簇和非聚簇索引"></a>聚簇和非聚簇索引</h3><ul><li><p>聚簇索引也好、非聚簇索引也好，都是索引的一个基本分类，他们最本质的点在于存储引擎，如果我们用InnoDB存储引擎，他的存储文件是.frm和.ibd文件，这意味着InnoDB里面存放数据文件和索引文件是在同一个文件.ibd文件里，所以他的数据和索引是放在一起存储的，这种存储方式称之为聚簇索引。InnerDB在进行数据插入的时候，必须要绑定一个索引列上，默认是主键，如果没有主键，会选择唯一键，如果没有唯一键，会生成6字节的rowid，跟数据绑定在一起</p></li><li><p>像MyISAM存储引擎，他存储文件是.frm，.myi(索引文件)，.myd(数据文件)文件，他是把索引文件和数据文件分开存储的，这种存储方式称为非聚簇索引，InnoDB既有聚簇索引也有非聚簇索引，MyISAM只有非聚簇索引</p></li></ul><h3 id="数据库慢sql优化"><a href="#数据库慢sql优化" class="headerlink" title="数据库慢sql优化"></a>数据库慢sql优化</h3><ul><li><p>尽量创建联合索引,</p></li><li><p>多表关联查询：所有的join查询，都是通过嵌套循环连接完成的，嵌套循环join有三个变种：</p><ol><li>Simple Nested-Loop Join ：从表中取出匹配所有列，匹配后合并，开销大。select * from t1,t2(笛卡尔积)</li><li>Index Nested-Loop Join ： 索引嵌套连接，由于非驱动表有索引，通过索引减少比较，加速查询，我们再做关联查询的时候必须要求<strong>关联字段有索引</strong>；查询过程：1、根据关联字段索引进行查找，在索引上找到符合的值后再回表查询，只有匹配到索引后才会回表，至于驱动表选择，Mysql优化器一般会选择记录少的作为驱动表，但是当SQL特别复杂的时候不排除会选择错。2、如果非驱动表关联主键，性能会非常高，如果不是主键，关联后返回行数特别多的话，效率也会很低，要多次回表操作。</li><li>Block Nested-Loop Join：当连接条件没有索引的时候会用这种方式关联，比Simple Nested-Loop Join 多了一个中间处理过程，有些情况下，可能join的列就是没有索引，那么MySQL会选择Block Nested-Loop Join算法，其实就是使用Join buffer将驱动表的查询Join相关列都缓存到Join buffer中，然后批量与非驱动表进行比较，降低了非驱动表的访问频次。查看join buffer:<code>show variables like &#39;join_buffer_size;&#39;</code> </li></ol></li></ul><h3 id="索引失效的情况"><a href="#索引失效的情况" class="headerlink" title="索引失效的情况"></a>索引失效的情况</h3><p>谈到索引主要从两方面来分析：IO 和数据结构：不管索引数据还是行数据，都是存在磁盘里面的，我们尽可能少的取出数据</p><ul><li>IO—–&gt;读取次数少、量少——&gt;分块读取——&gt;局部性原理、磁盘预读</li><li>数据结构——&gt;B+树——&gt;二叉树、AVL树、红黑树、B树</li></ul><ol><li>组合索引不遵循最左匹配原则</li><li>组合索引前面索引列使用范围查询(&lt;,&gt;,like),会导致后续索引失效；</li><li>不要在索引上做任何操作（计算，函数，类型转换）</li><li>is null和is not null 无法使用索引</li><li>尽量少使用or操作符，否则连接时索引会失效</li><li>字符串不添加引号会导致索引失效（隐式类型转换）</li><li>两表关联使用的条件字段中字段的长度，编码不一致会导致索引失效</li><li>like语句中，以%开头的模糊查询会导致索引失效</li><li>如果mysql中使用全表扫描比索引快，也会导致索引失效 （force index:强制使用索引）</li></ol><h3 id="如何做分库分表"><a href="#如何做分库分表" class="headerlink" title="如何做分库分表"></a>如何做分库分表</h3><p>​    使用mycat或者shardingsphere中间件做分库分表，选择合适的中间件，水平分库，水平分表，垂直分库，垂直分表，在进行分库分表的时候尽量遵循以下原则</p><ol><li>能不切分尽量不要切分</li><li>如果要切分一定要选择合适的切分规则，提前规划好</li><li>如果切分尽量通过数据冗余或表分组来降低跨库Join的可能</li><li>由于数据库中间件对数据Join实现的优劣难以把握，而且实现高性能难度极大，业务尽量少使用多表Join</li></ol><h3 id="Mysql主从复制"><a href="#Mysql主从复制" class="headerlink" title="Mysql主从复制"></a>Mysql主从复制</h3><ol><li>从库通过手工执行change master to 语句连接主库，提供连接用户信息（userName、passWord、port、ip）二进制日志的起点位置（file名 position号）；start slave</li><li>从库的IO线程和主库的dump线程建立连接</li><li>从库根据change master to 语句提供的file名和position号，IO线程向主库发起binlog请求</li><li>主库dump线程根据从库请求，将本地binlog以events的方式发给从库IO线程</li><li>从库IO线程接受binlog events，并放到本地relay-log中(顺序IO)，传送过来的信息会记录到master.info中</li><li>从库SQL线程应用relay-log,并且把应用过的记录到relay-log.info中，默认情况下，已经应用过的relay会自动被清理purge</li></ol><img src="https://raw.githubusercontent.com/lizejiao/img_bed/master/images/mysql001.png" style="zoom: 80%;" /><h2 id="缓存-Redis-ES"><a href="#缓存-Redis-ES" class="headerlink" title="缓存:Redis/ES"></a>缓存:Redis/ES</h2><h3 id="Redis数据类型"><a href="#Redis数据类型" class="headerlink" title="Redis数据类型"></a>Redis数据类型</h3><img src="https://raw.githubusercontent.com/lizejiao/img_bed/master/images/redisdata.jpg" style="zoom: 67%;" /><ol><li><p><strong>String</strong></p></li><li><p><strong>Hash</strong></p></li><li><p><strong>List</strong>：类似于数组</p></li><li><p><strong>Set</strong>：无序集合 用户列表，求集合的交集，并集等操作</p></li><li><p><strong>ZSet</strong>：有序集合</p><ul><li><p>1）点击新闻：ZINCRBY  hotNews:20190819  1  守护香港</p></li><li><p>2）展示当日排行前十：ZREVRANGE  hotNews:20190819  0  9  WITHSCORES </p></li><li><p>3）七日搜索榜单计算：ZUNIONSTORE  hotNews:20190813-20190819  7  hotNews:20190813  hotNews:20190814… hotNews:20190819</p></li><li><p>4）展示七日排行前十：ZREVRANGE hotNews:20190813-20190819  0  9  WITHSCORES</p></li></ul></li></ol><img src="https://raw.githubusercontent.com/lizejiao/img_bed/master/images/redis-set.png" style="zoom: 80%;" /><h3 id="Redis单线程模型"><a href="#Redis单线程模型" class="headerlink" title="Redis单线程模型"></a>Redis单线程模型</h3><p>Redis基于Reactor模式开发的网络事件处理器，这个文件事件处理器是单线程的，采用IO多路复用机制监听多个Socker，根据Socker上的事件类型选择对应的事件处理器处理这个事件，可以实现高性能的网络通信。文件事件处理器包含4个部分，多个Socker，IO多路复用程序，文件事件分派器和事件处理器(命令请求处理器，命令回复处理器，链接应答处理器)，多个Socket可能并发产生不同操作，每个操作对应不同的文件事件，但是IO多路复用会监听多个Socket，会将Socket放入一个队列，每次从队列中取出一个Socket给时间分派器，时间分派器把Socket给对应的事件处理器。</p><p>单线程快的原因：1.纯内存操作；2.核心是基于非阻塞的IO多路复用机制；3.单线程反而避免多线程的频繁上下文切换</p><h3 id="分布式锁怎么实现的？"><a href="#分布式锁怎么实现的？" class="headerlink" title="分布式锁怎么实现的？"></a>分布式锁怎么实现的？</h3><ol><li>基于数据库实现分布式锁：唯一索引，状态机唯一联合索引</li><li>基于缓存（Redis等）实现分布式锁：SET key value NX PX 30000</li><li>基于Zookeeper实现分布式锁；</li></ol><h3 id="setnx用到的参数"><a href="#setnx用到的参数" class="headerlink" title="setnx用到的参数"></a>setnx用到的参数</h3><p><code>SET key value NX PX 30000</code></p><p>第三个参数：把key、value set到redis中的策略</p><ul><li>  nx ： not exists, 只有key 不存在时才把key value set 到redis</li><li>  xx ： is exists ，只有 key 存在是，才把key value set 到redis</li></ul><p>第四个参数：过期时间单位</p><ul><li>  ex ：seconds 秒</li><li>  px : milliseconds 毫秒</li></ul><p>使用其他值，抛出 异常 ： redis.clients.jedis.exceptions.JedisDataException : ERR syntax error </p><p>第五个参数：有两种可选的值，</p><p>int 和long 的time，都是过期时间 ，expx 参数是px的时候，使用long类型的参数，可以表示更多时间</p><h3 id="缓存穿透，击穿，雪崩"><a href="#缓存穿透，击穿，雪崩" class="headerlink" title="缓存穿透，击穿，雪崩"></a>缓存穿透，击穿，雪崩</h3><ul><li><font color='red'>缓存雪崩</font>：缓存同一时间大面积失效，后面请求都落到数据库上，造成大量请求直接打到数据库。<ol><li>过期时间随机，防止同一时间大量数据过期</li><li>缓存预热：项目启动加载缓存到redis</li><li>互斥锁：修改的时候只允许一个线程修改数据库，其他读写线程等待</li><li>加相应缓存标记，记录缓存是否失效，如果失效，更新缓存(内存消耗大，一般不用)</li></ol></li><li><font color='red'>缓存穿透</font>：指数据库没有数据，导致请求落到数据库上<ol><li>接口层增加校验，对id进行规则拦截</li><li>缓存取不到数据，设置null值到缓存，设置短时间超时，防止网络攻击</li><li>布隆过滤器，所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据就会被这个bitmap拦截</li></ol></li><li><font color='red'>缓存击穿</font>：缓存没有，数据库中有数据（一般是缓存时间到期），并发用户特别多，同时大量请求落到数据库，缓存击穿指并发查询同一条数据，缓存雪崩是不同数据都过期<ol><li>key不过期</li><li>加互斥锁</li></ol></li></ul><h3 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h3><ol><li>RDB快照(snapshot)<ol><li>Redis 将内存数据快照保存在名字为 dump.rdb 的二进制文件中。可以对 Redis 进行设置， 让它在“ N 秒内数据集至少有 M 个改动”这一条件被满足时， 自动保存一次数据；**# save 60 1000    //** (60秒改1000次进行一次RDB持久化)关闭RDB只需要将所有的save保存策略注释掉即可。</li><li>问题：会阻塞客户端命令。</li><li>还可以手动执行命令生成RDB快照，进入redis客户端执行命令<strong>save</strong>或<strong>bgsave</strong>可以生成dump.rdb文件，每次命令执行都会将所有redis内存快照到一个新的rdb文件里，并覆盖原有rdb快照文件。</li><li><strong>bgsave的写时复制(COW)机制</strong>：Redis 借助操作系统提供的写时复制技术（Copy-On-Write, COW），在生成快照的同时，依然可以正常处理写命令。bgsave 子进程是由主线程 fork 生成的，可以共享主线程的所有内存数据。bgsave 子进程运行后，开始读取主线程的内存数据，并把它们写入 RDB 文件。此时，如果主线程对这些数据也都是读操作，那么，主线程和 bgsave 子进程相互不影响。但是，如果主线程要修改一块数据，那么，这块数据就会被复制一份，生成该数据的副本。然后，bgsave 子进程会把这个副本数据写入 RDB 文件，在这个过程中，主线程仍然可以修改原来的数据。</li></ol></li><li>AOF(append-only file)<ol><li>如果 Redis 因为某些原因而造成故障停机， 那么服务器将丢失最近写入、且仍未保存到快照中的那些数据。从 1.1 版本开始， Redis 增加了一种完全耐久的持久化方式： AOF 持久化，将<strong>修改的</strong>每一条指令记录进文件appendonly.aof中(先写入os cache，每隔一段时间fsync到磁盘)</li></ol></li></ol><h3 id="缓存与数据库数据一致性"><a href="#缓存与数据库数据一致性" class="headerlink" title="缓存与数据库数据一致性"></a>缓存与数据库数据一致性</h3><img src="https://raw.githubusercontent.com/lizejiao/img_bed/master/images/redis-db.png" style="zoom:67%;" /><p>解决方案：</p><ol><li>对于并发几率很小的数据(如个人维度的订单数据、用户数据等)，这种几乎不用考虑这个问题，很少会发生缓存不一致，可以给缓存数据加上过期时间，每隔一段时间触发读的主动更新即可。</li><li>就算并发很高，如果业务上能容忍短时间的缓存数据不一致(如商品名称，商品分类菜单等)，缓存加上过期时间依然可以解决大部分业务对于缓存的要求。</li><li>如果不能容忍缓存数据不一致，可以通过加<strong>读写锁</strong>保证并发读写或写写的时候按顺序排好队，<strong>读读的时候相当于无锁</strong>。</li><li>也可以用阿里开源的canal通过监听数据库的binlog日志及时的去修改缓存，但是引入了新的中间件，增加了系统的复杂度。</li></ol><h3 id="ES简介"><a href="#ES简介" class="headerlink" title="ES简介"></a>ES简介</h3><p>ES他是建立在全文搜索引擎库ApacheLucene基础上的一个开源搜索和分析引擎，ES本身具有一个分布式存储，检索速度快的特性，所以我们经常用它去实现全文检索这一类的场景，比如像网站搜索，公司内部用ELK做日志聚集和检索，来去快速查找服务器的日志记录，去定位问题，基本上涉及到TB级别的数据场景，用ES是一个比较好的选择</p><h4 id="ES查询快的原因"><a href="#ES查询快的原因" class="headerlink" title="ES查询快的原因"></a>ES查询快的原因</h4><ol><li>第一、Lucene是擅长管理大量的索引数据的，另一方面他会对数据进行分词以后在保存索引，这样能搞提升数据的检索效率</li><li>第二、ES采用倒排索引，所谓倒排索引，就是通过属性值来确定数据记录的位置的索引，来避免全表扫描这样一个问题，</li><li>第三、ES采用分片存储机制</li><li>第四、ES扩展性好，我们可以水平扩展增加服务器，提升ES处理性能，可以达到百台服务器节点扩展</li><li>第五、ES内部提供了数据汇总和索引生命周期管理的一些功能，可以方便我们更加高效的存储和搜索数据</li></ol><h4 id="使用ES注意事项"><a href="#使用ES注意事项" class="headerlink" title="使用ES注意事项"></a>使用ES注意事项</h4><ol><li>ES里面不建议使用复杂的关联查询，会对性能影响很大</li><li>避免深度分页查询，因为ES分页是支持front和size参数，在查询的时候，每个分片必须构造一个长度为front加size的优先队列，然后回传到网关节点，网关节点再对这些队列进行排序再找到正确的size文档。而当front足够大的时候容易造成OOM以及网络传输性能差的一些问题</li></ol><h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p><img src="https://raw.githubusercontent.com/lizejiao/img_bed/master/images/MQ.png"></p><h4 id="Rabbitmq生产高可用怎么实现的"><a href="#Rabbitmq生产高可用怎么实现的" class="headerlink" title="Rabbitmq生产高可用怎么实现的"></a>Rabbitmq生产高可用怎么实现的</h4><ol><li>生产部署为集群模式：避免单机模式下MQ服务器挂了导致服务不可用，还可以承载更高的并发量，但是集群模式有个问题，就是在哪个节点上创建队列，该队列只会存在该节点上，其他集群节点不会备份该队列，一旦该节点宕机，该队列中的消息就会丢失(亲测设置持久化也丢失)</li><li>使用镜像队列：可以解决集群模式下，每个机器上只有一个队列的问题，让消息在其他节点再备份一份。开启方式：任何节点添加policy策略即可，该集群就具有镜像队列能力，可设置备份的份数和备份队列规则，即使其中一个节点宕机，也会保证整个集群中保存2份</li><li>高可用负载均衡：haproxy+keepalive，nginx，lvs等实现高可用负载均衡</li><li>其他：Federation Exchange联邦交换机插件解决两地接受消息确认消息延迟问题，也可以用Shovel来做数据同步，需要安装插件</li></ol><h3 id="zookeeper"><a href="#zookeeper" class="headerlink" title="zookeeper"></a>zookeeper</h3><h4 id="zookeeper的理解"><a href="#zookeeper的理解" class="headerlink" title="zookeeper的理解"></a>zookeeper的理解</h4><ol><li>集群管理：提供了CP模型来保证集群中每个节点的数据一致性</li><li>分布式锁</li><li>集群选举</li></ol><h4 id="zookeeper选举机制"><a href="#zookeeper选举机制" class="headerlink" title="zookeeper选举机制"></a>zookeeper选举机制</h4><ul><li>LeaderElection  </li><li>AuthFastLeaderElection</li><li>FastLeaderElection （最新默认）</li></ul><p>目前有5台服务器，每台服务器均没有数据，它们的编号分别是1,2,3,4,5,按编号依次启动，它们的选择举过程如下：</p><ul><li>服务器1启动，给自己投票，然后发投票信息，由于其它机器还没有启动所以它收不到反馈信息，服务器1的状态一直属于Looking(选举状态)。</li><li>服务器2启动，给自己投票，同时与之前启动的服务器1交换结果，由于服务器2的编号大所以服务器2胜出，但此时投票数没有大于半数，所以两个服务器的状态依然是LOOKING。</li><li>服务器3启动，给自己投票，同时与之前启动的服务器1,2交换信息，由于服务器3的编号最大所以服务器3胜出，此时投票数正好大于半数，所以服务器3成为领导者，服务器1,2成为小弟。</li><li>服务器4启动，给自己投票，同时与之前启动的服务器1,2,3交换信息，尽管服务器4的编号大，但之前服务器3已经胜出，所以服务器4只能成为小弟。</li><li>服务器5启动，后面的逻辑同服务器4成为小弟。</li></ul><h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><h3 id="全局序号生成规则？"><a href="#全局序号生成规则？" class="headerlink" title="全局序号生成规则？"></a>全局序号生成规则？</h3><ol><li>UUID：没顺序，长度过长，作为主键索引效率低</li><li>数据库自增id：实现简单，保证唯一递增，扩展性差，有单点故障风险</li><li>redis生成id</li><li>雪花算法</li><li>通过一个序列表记录当前序列号，机器每次从序列表中获取一定步长的序列数然后缓存再本地，等用完后再重新从步长表获取</li></ol><h2 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h2><h3 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h3><p>​        CAP 理论又叫 Brewer 理论，这是加州大学伯克利分校的埃里克 · 布鲁尔（Eric Brewer）教授，在 2000 年 7 月“ACM 分布式计算原理研讨会（PODC）”上提出的一个猜想。<a href="chrome-extension://ikhdkkncnoglghljlkmcimlnlhkeamad/pdf-viewer/web/viewer.html?file=https%3A%2F%2Fpeople.eecs.berkeley.edu%2F~brewer%2Fcs262b-2004%2FPODC-keynote.pdf">CAP理论原稿</a>（那时候还只是猜想）然后到了 2002 年，麻省理工学院的赛斯 · 吉尔伯特（Seth Gilbert）和南希 · 林奇（Nancy Lynch）就以严谨的数学推理证明了这个 CAP 猜想。在这之后，CAP 理论就正式成为了分布式计算领域公认的著名定理。这个定理里，描述了一个分布式的系统中，当涉及到共享数据问题时，以下三个特性最多只能满足其中两个：</p><ol><li>一致性（Consistency）：代表在任何时刻、任何分布式节点中，我们所看到的数据都是没有矛盾的。这与 ACID 中的 C 是相同的单词，但它们又有不同的定义（分别指 Replication 的一致性和数据库状态的一致性）。在分布式事务中，ACID 的 C 要以满足 CAP 中的 C 为前提。</li><li>可用性（Availability）：代表系统不间断地提供服务的能力。</li><li>分区容忍性（Partition Tolerance）：代表分布式环境中，当部分节点因网络原因而彼此失联（即与其他节点形成“网络分区”）时，系统仍能正确地提供服务的能力。</li></ol><h3 id="DDD"><a href="#DDD" class="headerlink" title="DDD"></a>DDD</h3><p>ddd不是一种架构风格，而是一种方法论，什么是方法论，每个人按照自己的想法来设计就是一套方法论；ddd是一种业务比较认可，对于微服务拆分的一种方法论。</p><h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><ol><li>最近做的比较熟悉的项目是哪个？画一下项目技术架构图</li><li>写两个类，能够实现堆内存溢出和栈内存溢出</li><li>写一个线程安全的单例。</li><li>两个可变有序链表放到新数组中，有序</li></ol><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA常用快捷键(Mac版)</title>
      <link href="/2022/01/27/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/IDEA%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/2022/01/27/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/IDEA%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="Mac键盘符号和修饰键说明"><a href="#Mac键盘符号和修饰键说明" class="headerlink" title="Mac键盘符号和修饰键说明"></a>Mac键盘符号和修饰键说明</h3><ul><li><p>⌘ Command</p></li><li><p>⇧ Shift</p></li><li><p>⌥ Option</p></li><li><p>⌃ Control</p></li><li><p>↩︎ Return/Enter </p></li><li><p>⌫ Delete</p></li><li><p>⌦ 向前删除键（Fn+Delete）</p></li><li><p>↑ 上箭头</p></li><li><p>↓ 下箭头</p></li><li><p>← 左箭头</p></li><li><p>→ 右箭头</p></li><li><p>⇞ Page Up（Fn+↑）</p></li><li><p>⇟ Page Down（Fn+↓）</p></li><li><p>Home Fn + ←</p></li><li><p>End Fn + →</p></li><li><p>⇥ 右制表符（Tab键）</p></li><li><p>⇤ 左制表符（Shift+Tab）</p></li><li><p>⎋ Escape (Esc)</p></li></ul><h3 id="Editing（编辑）"><a href="#Editing（编辑）" class="headerlink" title="Editing（编辑）"></a>Editing（编辑）</h3><ul><li>⌃Space 基本的代码补全（补全任何类、方法、变量）</li><li>⌃⇧Space 智能代码补全（过滤器方法列表和变量的预期类型）</li><li>⌘⇧↩ 自动结束代码，行末自动添加分号</li><li>⌘P 显示方法的参数信息</li><li>⌃J, Mid. button click 快速查看文档</li><li>⇧F1 查看外部文档（在某些代码上会触发打开浏览器显示相关文档）</li><li>⌘+鼠标放在代码上 显示代码简要信息</li><li>⌘F1 在错误或警告处显示具体描述信息</li><li>⌘N, ⌃↩, ⌃N 生成代码（getter、setter、构造函数、hashCode/equals,toString）</li><li>⌃O 覆盖方法（重写父类方法）</li><li>⌃I 实现方法（实现接口中的方法）</li><li>⌘⌥T 包围代码（使用if..else, try..catch, for, synchronized等包围 选中的代码）</li><li>⌘/ 注释/取消注释与行注释</li><li>⌘⌥/ 注释/取消注释与块注释</li><li>⌥↑ 连续选中代码块fa</li><li>⌥↓ 减少当前选中的代码块</li><li>⌃⇧Q 显示上下文信息</li><li>⌥↩ 显示意向动作和快速修复代码</li><li>⌘⌥L 格式化代码</li><li>⌃⌥O 优化import</li><li>⌃⌥I 自动缩进线</li><li>⇥ / ⇧⇥ 缩进代码 / 反缩进代码</li><li>⌘X 剪切当前行或选定的块到剪贴板</li><li>⌘C 复制当前行或选定的块到剪贴板</li><li>⌘V 从剪贴板粘贴</li><li>⌘⇧V 从最近的缓冲区粘贴</li><li>⌘D 复制当前行或选定的块</li><li>⌘⌫ 删除当前行或选定的块的行</li><li>⌃⇧J 智能的将代码拼接成一行</li><li>⌘↩ 智能的拆分拼接的行</li><li>⇧↩ 开始新的一行</li><li>⌘⇧U 大小写切换</li><li>⌘⇧] / ⌘⇧[ 选择直到代码块结束/开始</li><li>⌥⌦ 删除到单词的末尾（⌦键为Fn+Delete）</li><li>⌥⌫ 删除到单词的开头</li><li>⌘+ / ⌘- 展开 / 折叠代码块</li><li>⌘⇧+ 展开所以代码块</li><li>⌘⇧- 折叠所有代码块</li><li>⌘W 关闭活动的编辑器选项卡</li></ul><h3 id="Search-Replace（查询-替换）"><a href="#Search-Replace（查询-替换）" class="headerlink" title="Search/Replace（查询/替换）"></a>Search/Replace（查询/替换）</h3><ul><li>Double ⇧ 查询任何东西</li><li>⌘F 文件内查找</li><li>⌘G 查找模式下，向下查找</li><li>⌘⇧G 查找模式下，向上查找</li><li>⌘R 文件内替换</li><li>⌘⇧F 全局查找（根据路径）</li><li>⌘⇧R 全局替换（根据路径）</li><li>⌘⇧S 查询结构（Ultimate Edition 版专用，需要在Keymap中设置）</li><li>⌘⇧M 替换结构（Ultimate Edition 版专用，需要在Keymap中设置）</li></ul><h3 id="Usage-Search（使用查询）"><a href="#Usage-Search（使用查询）" class="headerlink" title="Usage Search（使用查询）"></a>Usage Search（使用查询）</h3><ul><li>⌥F7 / ⌘F7 在文件中查找用法 / 在类中查找用法</li><li>⌘⇧F7 在文件中突出显示的用法</li><li>⌘⌥F7 显示用法</li></ul><h3 id="Compile-and-Run（编译和运行）"><a href="#Compile-and-Run（编译和运行）" class="headerlink" title="Compile and Run（编译和运行）"></a>Compile and Run（编译和运行）</h3><ul><li>⌘F9 编译Project</li><li>⌘⇧F9 编译选择的文件、包或模块</li><li>⌃⌥R 弹出 Run 的可选择菜单</li><li>⌃⌥D 弹出 Debug 的可选择菜单</li><li>⌃R 运行</li><li>⌃D 调试</li><li>⌃⇧R, ⌃⇧D 从编辑器运行上下文环境配置</li></ul><h3 id="Debugging（调试）"><a href="#Debugging（调试）" class="headerlink" title="Debugging（调试）"></a>Debugging（调试）</h3><ul><li>F8 进入下一步，如果当前行断点是一个方法，则不进入当前方法体内</li><li>F7 进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该</li><li>方法体还有方法，则不会进入该内嵌的方法中</li><li>⇧F7 智能步入，断点所在行上有多个方法调用，会弹出进入哪个方法</li><li>⇧F8 跳出</li><li>⌥F9 运行到光标处，如果光标前有其他断点会进入到该断点</li><li>⌥F8 计算表达式（可以更改变量值使其生效）</li><li>⌘⌥R 恢复程序运行，如果该断点下面代码还有断点则停在下一个断点上</li><li>⌘F8 切换断点（若光标当前行有断点则取消断点，没有则加上断点）</li><li>⌘⇧F8 查看断点信息</li></ul><h3 id="Navigation（导航）"><a href="#Navigation（导航）" class="headerlink" title="Navigation（导航）"></a>Navigation（导航）</h3><ul><li>⌘O 查找类文件</li><li>⌘⇧O 查找所有类型文件、打开文件、打开目录，打开目录需要在输入的内容前面或后面加一个反斜杠/</li><li>⌘⌥O 前往指定的变量 / 方法</li><li>⌃← / ⌃→ 左右切换打开的编辑tab页</li><li>F12 返回到前一个工具窗口</li><li>⎋ 从工具窗口进入代码文件窗口</li><li>⇧⎋ 隐藏当前或最后一个活动的窗口，且光标进入代码文件窗口</li><li>⌘⇧F4 关闭活动run/messages/find/… tab</li><li>⌘L 在当前文件跳转到某一行的指定处</li><li>⌘E 显示最近打开的文件记录列表</li><li>⌘⌥← / ⌘⌥→ 退回 / 前进到上一个操作的地方</li><li>⌘⇧⌫ 跳转到最后一个编辑的地方</li><li>⌥F1 显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择(如在 代码编辑窗口可以选择显示该文件的Finder)</li><li>⌘B / ⌘ 鼠标点击 进入光标所在的方法/变量的接口或是定义处</li><li>⌘⌥B 跳转到实现处，在某个调用的方法名上使用会跳到具体的实现处，可以跳过接口</li><li>⌥ Space, ⌘Y 快速打开光标所在方法、类的定义</li><li>⌃⇧B 跳转到类型声明处</li><li>⌘U 前往当前光标所在方法的父类的方法 / 接口定义</li><li>⌃↓ / ⌃↑ 当前光标跳转到当前文件的前一个/后一个方法名位置</li><li>⌘] / ⌘[ 移动光标到当前所在代码的花括号开始/结束位置</li><li>⌘F12 弹出当前文件结构层，可以在弹出的层上直接输入进行筛选（可用于搜索类中的方法）</li><li>⌃H 显示当前类的层次结构</li><li>⌘⇧H 显示方法层次结构</li><li>⌃⌥H 显示调用层次结构</li><li>F2 / ⇧F2 跳转到下一个/上一个突出错误或警告的位置</li><li>F4 / ⌘↓ 编辑/查看代码源</li><li>⌥ Home 显示到当前文件的导航条</li><li>F3选中文件/文件夹/代码行，添加/取消书签</li><li>⌥F3 选中文件/文件夹/代码行，使用助记符添加/取消书签</li><li>⌃0…⌃9 定位到对应数值的书签位置</li><li>⌘F3 显示所有书签</li></ul><h3 id="Refactoring（重构）"><a href="#Refactoring（重构）" class="headerlink" title="Refactoring（重构）"></a>Refactoring（重构）</h3><ul><li>F5 复制文件到指定目录</li><li>F6 移动文件到指定目录</li><li>⌘⌫ 在文件上为安全删除文件，弹出确认框</li><li>⇧F6 重命名文件</li><li>⌘F6 更改签名</li><li>⌘⌥N 一致性</li><li>⌘⌥M 将选中的代码提取为方法</li><li>⌘⌥V 提取变量</li><li>⌘⌥F 提取字段</li><li>⌘⌥C 提取常量</li><li>⌘⌥P 提取参数</li></ul><h3 id="VCS-Local-History（版本控制-本地历史记录）"><a href="#VCS-Local-History（版本控制-本地历史记录）" class="headerlink" title="VCS/Local History（版本控制/本地历史记录）"></a>VCS/Local History（版本控制/本地历史记录）</h3><ul><li><p>⌘K 提交代码到版本控制器</p></li><li><p>⌘T 从版本控制器更新代码</p></li><li><p>⌥⇧C 查看最近的变更记录</p></li><li><p>⌃C 快速弹出版本控制器操作面板</p></li><li><p><strong>Live Templates（动态代码模板）</strong></p></li><li><p>⌘⌥J 弹出模板选择窗口，将选定的代码使用动态模板包住</p></li><li><p>⌘J 插入自定义动态代码模板</p></li></ul><h3 id="General（通用）"><a href="#General（通用）" class="headerlink" title="General（通用）"></a>General（通用）</h3><ul><li>⌘1…⌘9 打开相应编号的工具窗口</li><li>⌘S 保存所有</li><li>⌘⌥Y 同步、刷新</li><li>⌃⌘F 切换全屏模式</li><li>⌘⇧F12 切换最大化编辑器</li><li>⌥⇧F 添加到收藏夹</li><li>⌥⇧I 检查当前文件与当前的配置文件</li><li>`§⌃, ⌃``快速切换当前的scheme（切换主题、代码样式等）</li><li>⌘, 打开IDEA系统设置</li><li>⌘; 打开项目结构对话框</li><li>⇧⌘A 查找动作（可设置相关选项）</li><li>⌃⇥ 编辑窗口标签和工具窗口之间切换（如果在切换的过程加按上delete，则是关闭对应选中的窗口）</li></ul><h3 id="Other（一些官方文档上没有体现的快捷键）"><a href="#Other（一些官方文档上没有体现的快捷键）" class="headerlink" title="Other（一些官方文档上没有体现的快捷键）"></a>Other（一些官方文档上没有体现的快捷键）</h3><ul><li>⌘⇧8 竖编辑模式</li></ul><h4 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h4><ul><li>⌘O 查找类文件 Ctrl + N</li><li>⌘⌥O 前往指定的变量 / 方法 Ctrl + Shift + Alt + N</li><li>⌃← / ⌃→ 左右切换打开的编辑tab页 Alt← / Alt→</li><li>⎋ 从工具窗口进入代码文件窗口 ESC</li><li>⌘L 在当前文件跳转到某一行的指定处 Ctrl + G</li><li>⌘E 显示最近打开的文件记录列表 Ctrl + E</li><li>⌘⌥← / ⌘⌥→ 退回 / 前进到上一个操作的地方 Ctrl + Alt + ← Ctrl + Alt + →</li><li>⌘⇧⌫ 跳转到最后一个编辑的地方</li><li>⌃H 显示当前类的层次结构 Ctrl + H</li><li>⌘⇧H 显示方法层次结构</li><li>⌃⌥H 显示调用层次结构</li><li>F4 / ⌘↓ 编辑/查看代码源</li><li>⌘⌥U 显示类UML图</li><li>⌃J 查看注释</li></ul><h4 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h4><ul><li>⌥⌦ 删除到单词的末尾（⌦键为Fn+Delete）</li><li>⌥⌫ 删除到单词的开头</li><li>⌘+ / ⌘- 展开 / 折叠代码块</li><li>⌘F1 在错误或警告处显示具体描述信息</li><li>⌘⌥L 格式化代码</li><li>⌃⌥O 优化import</li><li>⇧↩ 开始新的一行</li><li>⌘⇧↩ 自动结束代码，行末自动添加分号</li><li>⌃I 实现方法（实现接口中的方法）</li><li>⇧F6 重命名文件或者变量</li><li>⌘N, ⌃↩, ⌃N 生成代码（getter、setter、构造函数、hashCode/equals,toString）</li><li>⌘P 显示方法的参数信息</li></ul><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><ul><li>Double⇧ 查找任何东西</li><li>⌘⇧F 全局查找（根据路径）</li><li>⌘F 文件内查找</li><li>⌘G 查找模式下，向下查找</li><li>⌘⇧G 查找模式下，向上查找</li><li>⌘⌥B 跳转到接口的实现</li><li>⌘U 查看接口定义</li><li>⌘⌥← / ⌘⌥→ 退回 / 前进到上一个操作的地方</li><li>⌘B / ⌘ 鼠标点击 进入光标所在的方法/变量的接口或是定义处</li><li>⌃⇧B 跳转到类型声明处</li><li>⌥ Space, ⌘Y 快速打开光标所在方法、类的定义</li><li>⌘O 查找类文件</li><li>⌘⇧O 查找所有类型文件、打开文件、打开目录，打开目录需要在输入的内容前面或后面加一个反斜杠/</li><li>F12 返回到前一个工具窗口</li><li>⎋ 从工具窗口进入代码文件窗口</li><li>⇧⎋ 隐藏当前或最后一个活动的窗口，且光标进入代码文件窗口</li><li>F3选中文件/文件夹/代码行，添加/取消书签</li><li>⌥F3 选中文件/文件夹/代码行，使用助记符添加/取消书签</li><li>⌃0…⌃9 定位到对应数值的书签位置</li><li>⌘F3 显示所有书签</li><li>⌥F1 显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择(如在代码编辑窗口可以选择显示该文件的Finder)</li><li>⌘F12 弹出当前文件结构层，可以在弹出的层上直接输入进行筛选（可用于搜索类中的方法）</li></ul><h4 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h4><ul><li>⌃⌘F 切换全屏模式</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git笔记-常用命令以及日常操作技巧汇总</title>
      <link href="/2022/01/27/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/git%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/01/27/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/git%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="1、为Git配置代理（解决国内连接git慢问题）"><a href="#1、为Git配置代理（解决国内连接git慢问题）" class="headerlink" title="1、为Git配置代理（解决国内连接git慢问题）"></a>1、为Git配置代理（解决国内连接git慢问题）</h3><p>相关文章：<a href="https://blog.csdn.net/a1527238987/article/details/80237076">解决git无法clone提示443以及配置git代理方法</a> </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 添加当前仓库配置：</span></span><br><span class="line">git config --local http.proxy &quot;127.0.0.1:1087&quot; </span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除当前仓库配置：</span></span><br><span class="line">git config --unset --local http.proxy</span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加全局配置：</span></span><br><span class="line">git config --global http.proxy &quot;127.0.0.1:1087&quot; </span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除全局配置：</span></span><br><span class="line">git config --unset --global http.proxy</span><br></pre></td></tr></table></figure><span id="more"></span><p>注：添加相关配置也可以到本地仓库对应的目录，修改.git文件夹里面的config文件，如下图，我的本地的1087端口是我的科学上网地址<img src="https://gitee.com/lizejiao/img-go/raw/master/images/git-img1.jpg" style="zoom:33%;" /> </p><p>config 配置有system级别 global（用户级别） 和local（当前仓库）三个 设置先从system-》global-》local  底层配置会覆盖顶层配置 分别使用–system/global/local 可以定位到配置文件</p><ul><li><strong>查看系统config</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --system --list</span><br></pre></td></tr></table></figure><ul><li><strong>查看当前用户（global）配置</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global --list</span><br></pre></td></tr></table></figure><ul><li><strong>查看当前仓库配置信息</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --local --list</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为MacOS打造自己炫酷终端-Iterm2+oh-my-zsh</title>
      <link href="/2022/01/27/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/%E4%B8%BAMacOS%E6%89%93%E9%80%A0%E8%87%AA%E5%B7%B1%E7%82%AB%E9%85%B7%E7%BB%88%E7%AB%AF-/"/>
      <url>/2022/01/27/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/%E4%B8%BAMacOS%E6%89%93%E9%80%A0%E8%87%AA%E5%B7%B1%E7%82%AB%E9%85%B7%E7%BB%88%E7%AB%AF-/</url>
      
        <content type="html"><![CDATA[<h3 id="1、iTerm2"><a href="#1、iTerm2" class="headerlink" title="1、iTerm2"></a>1、iTerm2</h3><ul><li><a href="https://iterm2.com/"><strong>iTerm2</strong></a> 是一款完全免费，专为 Mac OS 用户打造多命令行应用。</li><li>安装完成后，在/bin目录下会多出一个zsh的文件。</li><li>Mac系统默认使用dash作为终端，可以使用命令修改默认使用zsh：chsh -s /bin/zsh</li><li>如果想修改回默认dash，同样使用chsh命令即可：chsh -s /bin/bash</li><li>Zsh 是一款强大的虚拟终端，既是一个系统的虚拟终端，也可以作为一个脚本语言的交互解析器。<span id="more"></span></li></ul><h4 id="1-1、iterm2-安装"><a href="#1-1、iterm2-安装" class="headerlink" title="1.1、iterm2 安装"></a>1.1、iterm2 安装</h4><p><a href="https://iterm2.com/downloads.html">下载地址</a></p><h4 id="1-2、iTerm操作快捷键"><a href="#1-2、iTerm操作快捷键" class="headerlink" title="1.2、iTerm操作快捷键"></a>1.2、iTerm操作快捷键</h4><ul><li><p>command + t：新建窗口 </p></li><li><p>command + d：垂直分屏，</p></li><li><p>command + shift + d：水平分屏。</p></li><li><p>command + ] 和command + [ 在最近使用的分屏直接切换.</p></li><li><p>command + alt + 方向键：切换到指定位置的分屏。</p></li><li><p>command + 数字：切换标签页。</p></li><li><p>command + 方向键：按方向切换标签页。</p></li><li><p>shift + command + s：保存当前窗口快照。</p></li><li><p>command + alt + b：快照回放。很有意思的功能，你可以对你的操作根据时间轴进行回放。可以拖动下方的时间轴，也可以按左右方向键</p></li></ul><h4 id="1-3、创建一键登录服务器"><a href="#1-3、创建一键登录服务器" class="headerlink" title="1.3、创建一键登录服务器"></a>1.3、创建一键登录服务器</h4><h5 id="1-3-1、第一步：新建配置文件，内容："><a href="#1-3-1、第一步：新建配置文件，内容：" class="headerlink" title="1.3.1、第一步：新建配置文件，内容："></a>1.3.1、第一步：新建配置文件，内容：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">set user 用户名</span><br><span class="line">set host IP地址</span><br><span class="line">set password 密码</span><br><span class="line">spawn ssh $user@$host</span><br><span class="line">expect &quot;*assword:*&quot;</span><br><span class="line">send &quot;$password\r&quot;</span><br><span class="line">interact</span><br><span class="line">expect eof</span><br></pre></td></tr></table></figure><h5 id="1-3-2、第二步：iTerm2配置添加"><a href="#1-3-2、第二步：iTerm2配置添加" class="headerlink" title="1.3.2、第二步：iTerm2配置添加"></a>1.3.2、第二步：iTerm2配置添加</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect ~/.ssh/SIT02-10.231.143.184</span><br></pre></td></tr></table></figure><h3 id="2、Oh-My-Zsh"><a href="#2、Oh-My-Zsh" class="headerlink" title="2、Oh My Zsh"></a>2、Oh My Zsh</h3><p><a href="https://ohmyz.sh/">Oh My Zsh 官网</a></p><p>Oh My Zsh 是一款社区驱动的命令行工具，它基于 zsh 命令行，提供了主题配置，插件机制，已经内置的便捷操作。给我们一种全新的方式使用命令行。</p><h4 id="2-1、oh-my-zsh-安装"><a href="#2-1、oh-my-zsh-安装" class="headerlink" title="2.1、oh my zsh 安装"></a>2.1、oh my zsh 安装</h4><h5 id="2-1-1、方式1"><a href="#2-1-1、方式1" class="headerlink" title="2.1.1、方式1"></a>2.1.1、方式1</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</span><br></pre></td></tr></table></figure><h5 id="2-1-2、方式2"><a href="#2-1-2、方式2" class="headerlink" title="2.1.2、方式2"></a>2.1.2、方式2</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`sh -c &quot;$(wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot;`</span><br></pre></td></tr></table></figure><h5 id="2-1-3、方式3（国内推荐使用）"><a href="#2-1-3、方式3（国内推荐使用）" class="headerlink" title="2.1.3、方式3（国内推荐使用）"></a>2.1.3、方式3（国内推荐使用）</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c &quot;$(curl -fsSL https://gitee.com/pocmon/ohmyzsh/raw/master/tools/install.sh)&quot;</span><br></pre></td></tr></table></figure><h4 id="2-2、卸载oh-my-zsh"><a href="#2-2、卸载oh-my-zsh" class="headerlink" title="2.2、卸载oh my zsh"></a>2.2、卸载oh my zsh</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uninstall_on_my_zsh</span><br></pre></td></tr></table></figure><h4 id="2-3、更换主题"><a href="#2-3、更换主题" class="headerlink" title="2.3、更换主题"></a>2.3、更换主题</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vi ~/.zshrc</span><br><span class="line">ZSH_THEME=&quot;macovsky-ruby&quot;    &quot;steeef&quot;</span><br></pre></td></tr></table></figure><h4 id="2-4、安装语法高亮插件"><a href="#2-4、安装语法高亮插件" class="headerlink" title="2.4、安装语法高亮插件"></a>2.4、安装语法高亮插件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进入文件夹</span></span><br><span class="line">cd ~/.oh-my-zsh/custom/plugins</span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载插件</span></span><br><span class="line">git clone https://github.com/zsh-users/zsh-syntax-highlighting.git</span><br></pre></td></tr></table></figure><h4 id="2-5、自动补全插件"><a href="#2-5、自动补全插件" class="headerlink" title="2.5、自动补全插件"></a>2.5、自动补全插件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/zsh-users/zsh-autosuggestions.git</span><br></pre></td></tr></table></figure><h5 id="2-5-1、启用插件"><a href="#2-5-1、启用插件" class="headerlink" title="2.5.1、启用插件"></a>2.5.1、启用插件</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vi ~/.zshrc</span><br><span class="line">plugins=( git</span><br><span class="line">  zsh-autosuggestions</span><br><span class="line">  zsh-syntax-highlighting )</span><br><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>军事级别安全强度，免费密码管理工具KeePass，永远滴神</title>
      <link href="/2022/01/27/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/%E5%85%8D%E8%B4%B9%E5%AF%86%E7%A0%81%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7KeePass%E6%B0%B8%E8%BF%9C%E7%9A%84%E7%A5%9E/"/>
      <url>/2022/01/27/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/%E5%85%8D%E8%B4%B9%E5%AF%86%E7%A0%81%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7KeePass%E6%B0%B8%E8%BF%9C%E7%9A%84%E7%A5%9E/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>​    <strong>欢迎大家收看本篇文章对应B站视频解说</strong>：👉 <a href="https://www.bilibili.com/video/BV1oU4y1j7vE/">点此跳转B站视频解说教程</a>  👈</p><p>​    大家好，我是喜欢科技，喜欢分享，喜欢软件，喜欢折腾，有洁癖又有强迫症的科技农名工—李苟蛋，今天我来给大家分享一款密码管理软件：KeePass。你是否有过这种经历：平均每半个月或者一个月，我们再登录某些网站或者登录某些账号的时候，发现我们的密码记不住了，用常用的密码试过几次之后，发现还是不对，干脆直接点击忘记密码，用手机验证码或者邮箱验证码找回密码更改成为我们常用的密码，如果这个网站或者这个账号我们好久没登录过，绑定的手机号还是我之前用过的手机号，可能就得通过申诉提供各种资料找回密码，那等待你的将是噩梦级别的操作，如果这个账号不太重要，我不要了也就算了，如果这个账号很重要，那此时此刻你的内心应该已经万马(羊驼)崩腾了。有些人可能喜欢把密码记录在一个特定的笔记本上面，但是如果这个笔记本丢了….丢在家里找不到还好说，万一丢在外面，那你担心的应该不是你有很多网站登录不上了，而是你的密码很可能被别人知道了；还有人喜欢把密码记录在电脑的本地记事本，或者手机的记事本里面，但是这只存在于你电脑本地或者手机本地，万一电脑重装系统，或者换手机……又是个难题，此时此刻聪明的你可能会想，那我把密码放在云笔记里面，我把这个笔记在加个打开密码，那不就好了吗？没错，我在认识KeePass之前，我就是这么做的，但是你放在云笔记里面，在加个笔记的开启密码，这种情况，你的密码就依赖了云笔记服务商的服务器，而且你把密码都放到人家的服务器上，你觉得这是安全的吗？难道你真的认为你加了一个开启密码，就没有人能看到了吗？你的开启密码的加密算法可都是人家云笔记运营商给你提供的…..</p><p>​    现在我就来给大家隆重介绍一下今天的主角，KeePass，并详细说明它是如何解决我们上述的这些问题的。目前主流的密码管理工具主要有：<strong>KeePass</strong>（免费 开源 兼容性强），<strong>LastPass</strong>（最大的优势是跨浏览器平台，收费），<strong>1Password</strong>（跨平台管理 用户认可度高），<strong>Enpass</strong>（支持平台多 20条密码免费）。可以看出，除了KeePass，其他都是收费的，所以我们毫无悬念的选择了它，KeePass从2003年至今具有近20年的时间，而且开源免费，开源的好处就是民间大神都可以看他的源代码，只要发现安全漏洞就可以去提交评论做修复，所以安全级别是可以放心的，如果你担心有安全问题想阅读源码也可以去<a href="https://sourceforge.net/p/keepass/code/HEAD/tree/">官方查看</a>。 接下来就让我介绍一下如何用KeePass搭建一个可以实现云同步的密码管理工具吧。</p><h3 id="KeePass下载及使用"><a href="#KeePass下载及使用" class="headerlink" title="KeePass下载及使用"></a>KeePass下载及使用</h3><h4 id="Keepa介绍"><a href="#Keepa介绍" class="headerlink" title="Keepa介绍"></a>Keepa介绍</h4><p>​    KeePass不会上传你的账号密码，你的账号密码保存在你本地(数据库)，你只需要创建一个开启这个数据库的钥匙，这个钥匙非常重要，它是你能否打开软件的关键，这个钥匙可以是一串密码，也可以是一个文件，文件可以是任何文件，一部电影，一个word文档，一个txt文本，一首歌等，都可以当做开启数据库的密钥文件，或者是密码加文件的组合的方式来设置你的开启钥匙，还可以是一个实体密钥(类似于U盾)，本人推荐使用密码加文件的方式作为数据库的开启钥匙，这样，开启密码我们就不用设置的太复杂，也不用担心开启密码泄露导致我们的数据库文件被别人拿到之后被别人打开，别人能同时拿到密码和文件简直太难了。</p><h4 id="PC端客户端KeePassXC"><a href="#PC端客户端KeePassXC" class="headerlink" title="PC端客户端KeePassXC"></a>PC端客户端KeePassXC</h4><p>​    <a href="https://keepass.info/">KeePass官网</a>，提供了KeePass软件的下载，官方只提供了PC端下载，不过还好，很多民间大神也做了很多支持KeePass的客户端供我们使用，官方也有推荐列表。电脑端（windows和Mac平台），我推荐使用<a href="https://keepassxc.org/">KeePassXC</a>，这也是支持KeePass的由非官方开发的一款软件，KeePass官方推荐列表里面有，之所以推荐它，是因为他界面美观，还有对应的浏览器插件，可以实现密码自动填充。安卓端我推荐使用<a href="https://play.google.com/store/apps/details?id=keepass2android.keepass2android">KeePass2Android</a>，这款软件下载需要上谷歌商店，可能得需要科学上网，这里我给大家提供了蓝奏云下载，方便大家下载安装，由于本人没有苹果手机，所以IPhone用户就需要小伙伴自己去官方推荐的软件里面寻找适合苹果手机的客户端了(#^.^#)~</p><p><img src="/images/keepass/20210828231940.png" style="zoom: 80%;" /> <img src="/images/keepass/20210828232127.png" style="zoom: 80%;" /> </p><img src="/images/keepass/20210828232715.png" style="zoom:80%;" /> <h4 id="KeePassXC使用介绍"><a href="#KeePassXC使用介绍" class="headerlink" title="KeePassXC使用介绍"></a>KeePassXC使用介绍</h4><p>下图为我的KeePass的客户端安装配置之后的效果，怎么样，还不错吧~</p><img src="/images/keepass/20210828233458.png" style="zoom: 67%;" /><p><a href="https://keepassxc.org/">下载</a>安装KeePass之后，我们需要设置一下我们数据库存放的本地位置，然后设置数据库开启密码，开启密钥文件，这里我推荐手动创建一个文件，后缀名随意，然后用记事本打开，在里面输入一些文章，例如你喜欢的诗词之类的，字书不要太多，尽量控制在1千字以内就行，避免文件过大，然后吧这个密钥文件好好保存起来，我建议用你常用的邮箱给自己发个邮件然后以附件的方式保存在你的邮件里面，这样他就永远不会丢了，或者放到你的云盘，NAS上面，不要把它和数据库放在一起！！！如果是Mac本支持指纹识别，输入一次密码和密钥文件之后，下次就可以通过指纹打开你的数据库了，但是这不代表你的密码和密钥文件就没用了，指纹打开数据库的原理其实就是通过指纹映射到你的密码和密钥文件，所以说，数据库开启密码和密钥文件很重要，这个一定不能丢~</p><p><img src="/images/keepass/20210828235058.png"></p><p>进入之后，我们就可以添加分类，然后添加账号密码等等，具体的使用方法我会出视频讲解，欢迎朋友来B站关注我。</p><h4 id="浏览器插件使用-谷歌为例"><a href="#浏览器插件使用-谷歌为例" class="headerlink" title="浏览器插件使用(谷歌为例)"></a>浏览器插件使用(谷歌为例)</h4><h5 id="本地软件开启相应功能"><a href="#本地软件开启相应功能" class="headerlink" title="本地软件开启相应功能"></a>本地软件开启相应功能</h5><p>​    在KeePassXC打开设置-浏览器集成-启用浏览器集成-然后为你用的浏览器开启集成（见下图），这里墙裂建议使用谷歌浏览器，这是浏览器中的神。当然，想成为神，需要科学上网安装必要的插件才能够给谷歌浏览器注入神之灵魂，不要下载下来之后连个插件都没装就说浏览器不行，行不行得看用的人会不会用。总之，科技农民工里面应该没有几个人不用谷歌吧~</p><p><img src="/images/keepass/20210829000333.png"></p><h5 id="浏览器插件下载使用"><a href="#浏览器插件下载使用" class="headerlink" title="浏览器插件下载使用"></a>浏览器插件下载使用</h5><p>​    打开<a href="https://chrome.google.com/webstore/search/KeePassXC?utm_source=chrome-ntp-icon">谷歌应用商店</a>（注：这里可能需要科学上网），找到KeePassXC这个插件，安装之…. </p><p><img src="/images/keepass/20210829000839.png"></p><p>安装之后用浏览器插件链接本地KeePassXC软件，链接之后，就可以实现网站账号密码自动填充了，需要注意的是，自动填充的时候，一定要是你本地数据库打开的情况下，这样你就可以吧浏览器的记住密码功能关闭了，不过这个自动填充功能并不一定所有网站都可以，大概百分之80的网站都没问题，还有就是想要能关联到填充项目，需要你在你添加密码的时候，把对应的URL填写成为网站的登录地址或者网站的官网。</p><p><img src="/images/keepass/20210829001359.png"></p><h3 id="实现数据库云同步"><a href="#实现数据库云同步" class="headerlink" title="实现数据库云同步"></a>实现数据库云同步</h3><p>我们的数据库只存在于我们本地肯定是不行的，这跟我直接在本地搞一个记事本保存密码也差不了多少，重装系统之后，数据库丢了，就直接回到解放前了，这里我建议使用两种工具实现数据库云同步功能，第一款是微软出品的OneDrive，这款云盘可以实现云盘映射到本地指定路径，路径中的文件发生改变，会自动同步到云端，这样我们添加或者修改了账号密码之后，数据库都会自动同步到微软的OneDrive云盘，这样我们就实现了电脑端的数据库云同步，手机端Keepass2Android，也是支持读取OneDrive云盘文件的功能的；第二款同步工具是坚果云，原理和OneDrive一样，不过坚果云要实现手机同步，需要通过WebDav功能实现，坚果云是支持云文件设置成为WebDav服务的，而且坚果云号称是国内最安全的云盘，军工级的加密方案，你的数据库放在坚果云是安全的，就算有人能拿到你的数据库，没有密码和密钥文件，也是打不开的…</p><p><img src="/images/keepass/20210829002414.png"></p><h3 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h3><p>​    无论使用哪种同步方案，这种同步的思路明白了，也可以试试其他的KeePass 的客户端软件，文章中介绍的都是本人认为最好的方案，也是爱折腾的我在工作之余肝了好几个晚上定下的最终方案，也请大家多多关注我的个人博客和B站，有什么问题可以加我QQ或者B站留言私信给我…谢谢大家！</p>]]></content>
      
      
      <categories>
          
          <category> 软件分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>吐血整理IDEA必备插件(๑•̀ㅂ•́)و✧，让撸码效率提升1000%</title>
      <link href="/2022/01/27/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/%E5%90%90%E8%A1%80%E6%95%B4%E7%90%86IDEA%E5%BF%85%E5%A4%87%E6%8F%92%E4%BB%B6/"/>
      <url>/2022/01/27/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/%E5%90%90%E8%A1%80%E6%95%B4%E7%90%86IDEA%E5%BF%85%E5%A4%87%E6%8F%92%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>俗话说：“工欲善其事，必先利其器”，好的开发工具能让我们的工作效率翻倍，而好的开发工具加上优秀的插件，能让我们的工作效率提升十倍（<del>(@^_^@)</del>我要打十个），这也是我们区别于其他程序猿的必备工具，下面就是我从十余年工作中总结出来的好用的idea插件（好像工作的前五年我用的都是eclipse，哈哈(╯&gt;д&lt;)╯⁽˙³˙⁾，这不重要！）。插件主要分为：代码生成类，日常开发类，主题美化类，以下插件大都可以通过 IDEA 自带的插件管理中心安装，如果搜不到可以去 <a href="https://plugins.jetbrains.com/">IDEA 插件官网</a>下载本地导入。星号代表我个人的推荐指数 。 </p><h2 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h2><h3 id="Lombok"><a href="#Lombok" class="headerlink" title="Lombok"></a>Lombok</h3><ul><li><p>推荐指数：★★★★★</p></li><li><p>自动生成get、set方法</p></li></ul><h3 id="EasyCode"><a href="#EasyCode" class="headerlink" title="EasyCode"></a>EasyCode</h3><ul><li><p>推荐指数：★★</p></li><li><p>数据库逆向工程</p></li></ul><h3 id="GsonFormat"><a href="#GsonFormat" class="headerlink" title="GsonFormat"></a>GsonFormat</h3><ul><li><p>推荐指数：★★★★</p></li><li><p>通过json生成实体类</p></li></ul><h3 id="Codota"><a href="#Codota" class="headerlink" title="Codota"></a>Codota</h3><ul><li><p>推荐指数：★★★★★</p></li><li><p>代码提示</p></li></ul><p>该插件的强大之处在于：</p><ol><li>支持智能代码自动提示，该功能可以增强 IDEA 的代码提示功能；</li><li>支持 JDK 和知名第三方库的函数的使用方法搜索，可以看到其他知名开源项目对该函数的用法。</li></ol><p>当我们第一次使用某个类，对某个函数不够熟悉时，可以通过该插件搜索相关用法，快速模仿学习，使用方法：右键要搜索的类，选择 <em>Get relevant exanples</em> </p><h3 id="GenerateAllSetter"><a href="#GenerateAllSetter" class="headerlink" title="GenerateAllSetter"></a>GenerateAllSetter</h3><ul><li><p>推荐指数：★★★★★</p></li><li><p>变量自动生成set方法</p></li></ul><p><a href="https://github.com/gejun123456/intellij-generateAllSetMethod">插件官网地址</a> 。我们定义好从 A 类转换到 B 类的函数转换函数后，使用这两个插件可以自动调用 Getter 和 Setter 函数实行自动转换。实际开发中还有一个非常常见的场景：我们创建一个对象后，想依次调用 Setter 函数对属性赋值，如果属性较多很容易遗漏或者重复。可以使用GenerateAllSetter 提供的功能，自动调用所有 Setter 函数（可填充默认值），然后自己再跟进实际需求设置属性值。</p><h3 id="ignore"><a href="#ignore" class="headerlink" title=".ignore"></a>.ignore</h3><ul><li><p>推荐指数：★★★★</p></li><li><p>git提交时过滤掉不需要提交的文件，很方便，有些本地文件是不需要提交到Git上的，插件：ProjectView涵盖了此功能</p></li></ul><h3 id="CamelCase"><a href="#CamelCase" class="headerlink" title="CamelCase"></a>CamelCase</h3><ul><li><p>推荐指数：★★★★</p></li><li><p>将不是驼峰格式的名称，快速转成驼峰格式，安装好后，选中要修改的名称，按快捷键shift+alt+u。</p></li></ul><h2 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h2><h3 id="Alibaba-Java-Coding-Guidelines"><a href="#Alibaba-Java-Coding-Guidelines" class="headerlink" title="Alibaba Java Coding Guidelines"></a>Alibaba Java Coding Guidelines</h3><ul><li><p>推荐指数：★★★</p></li><li><p>插件功能：代码规范插件</p></li></ul><h3 id="jclasslib-bytecode-viewer"><a href="#jclasslib-bytecode-viewer" class="headerlink" title="jclasslib bytecode viewer"></a>jclasslib bytecode viewer</h3><ul><li><p>推荐指数：★★★</p></li><li><p>插件功能：可视化的字节码查看插件</p></li></ul><p><strong>使用方法</strong>：</p><ol><li>在 IDEA 打开想研究的类；</li><li>编译该类或者直接编译整个项目（ 如果想研究的类在 jar 包中，此步可略过）；</li><li>打开“view” 菜单，选择“Show Bytecode With jclasslib” 选项；</li><li>选择上述菜单项后 IDEA 中会弹出 jclasslib 工具窗口。</li></ol><p>那么有自带的强大的反汇编工具 javap 还有必要用这个插件吗？</p><p>这个插件的<strong>强大之处</strong>在于：</p><ol><li>不需要敲命令，简单直接，在右侧方便和源代码进行对比学习；</li><li>字节码命令支持超链接，<strong>点击其中的虚拟机指令即可跳转到 jvms 相关章节</strong>，超级方便。</li></ol><p>该插件对我们学习虚拟机指令有极大的帮助。</p><h3 id="FindBugs"><a href="#FindBugs" class="headerlink" title="FindBugs"></a>FindBugs</h3><ul><li>推荐指数：★★</li><li>插件功能：查找代码bug</li></ul><p>程序员总是想尽可能地避免写 BUG， FindBugs 作为静态代码检查插件，可以检查你代码中的隐患，并给出原因。</p><h3 id="SonarLine"><a href="#SonarLine" class="headerlink" title="SonarLine"></a>SonarLine</h3><ul><li><p>推荐指数：★★</p></li><li><p>插件功能：代码质量管理工具</p></li></ul><h2 id="日常开发"><a href="#日常开发" class="headerlink" title="日常开发"></a>日常开发</h2><h3 id="Translation"><a href="#Translation" class="headerlink" title="Translation"></a>Translation</h3><ul><li><p>推荐指数：★★★★</p></li><li><p>插件功能：翻译</p></li></ul><h3 id="Jrebel"><a href="#Jrebel" class="headerlink" title="Jrebel"></a>Jrebel</h3><ul><li><p>推荐指数：★★★</p></li><li><p>插件功能：热部署</p></li></ul><h3 id="Key-Promoter-X"><a href="#Key-Promoter-X" class="headerlink" title="Key Promoter X"></a>Key Promoter X</h3><ul><li><p>推荐指数：★★</p></li><li><p>插件功能：快捷键提示</p></li></ul><h3 id="MyBatis-Log-Plugin"><a href="#MyBatis-Log-Plugin" class="headerlink" title="MyBatis Log Plugin"></a>MyBatis Log Plugin</h3><ul><li><p>推荐指数：★★★★★</p></li><li><p>插件功能：打印sql</p></li></ul><h3 id="MyBatisX"><a href="#MyBatisX" class="headerlink" title="MyBatisX"></a>MyBatisX</h3><ul><li><p>推荐指数：★★★★★</p></li><li><p>插件功能：Mapper跳转Dao</p></li></ul><h3 id="Maven-Search"><a href="#Maven-Search" class="headerlink" title="Maven Search"></a>Maven Search</h3><ul><li><p>推荐指数：★★★★</p></li><li><p>插件功能：查询maven</p></li></ul><h3 id="Maven-Helper"><a href="#Maven-Helper" class="headerlink" title="Maven Helper"></a>Maven Helper</h3><ul><li><p>推荐指数：★★★★★</p></li><li><p>插件功能：依赖关系图</p></li></ul><p>安装后 IDEA 中打开 pom.xml 文件时，就会多出一个 “Dependency Analyzer” 选项卡。</p><h3 id="SequenceDiagram"><a href="#SequenceDiagram" class="headerlink" title="SequenceDiagram"></a>SequenceDiagram</h3><ul><li><p>推荐指数：★★★★</p></li><li><p>插件功能：时序图</p></li></ul><p>SequenceDiagram 可以根据代码调用链路自动生成时序图，超级赞，超级推荐！这对研究源码，梳理工作中的业务代码有极大的帮助，堪称神器。安装完成后，在某个类的某个函数中，右键 –&gt; Sequence Diagaram 即可调出。</p><h2 id="主题美化"><a href="#主题美化" class="headerlink" title="主题美化"></a>主题美化</h2><h3 id="Active-power-mode"><a href="#Active-power-mode" class="headerlink" title="Active power mode"></a>Active power mode</h3><ul><li><p>推荐指数：★★</p></li><li><p>插件功能：打字特效</p></li></ul><h3 id="Rainbow-Branckets"><a href="#Rainbow-Branckets" class="headerlink" title="Rainbow Branckets"></a>Rainbow Branckets</h3><ul><li><p>推荐指数：★★★</p></li><li><p>插件功能：彩虹扩号</p></li></ul><p><a href="https://github.com/izhangzhihao/intellij-rainbow-brackets">插件github地址</a> 。由于很多人没有养成好的编码风格，没有随手 format 代码的习惯，甚至有些同事会写代码超过几百行，阅读起来将非常痛苦。痛苦的原因之一就是找到上下文，由于括号太多，不确定当前代码行是否属于某个代码块，此时这个插件就会帮上大忙。双击顶部的类名可以跳转到对应类的源码中，双击调用的函数名可以直接调入某个函数的源码，总之非常强大。</p><h3 id="CodeGlance"><a href="#CodeGlance" class="headerlink" title="CodeGlance"></a>CodeGlance</h3><ul><li><p>推荐指数：★★★</p></li><li><p>插件功能：代码迷你小地图</p></li></ul><p>类似于sublime的右侧代码小地图，CodeGlance2为原版加强</p><h3 id="Xcode-Drak-theme"><a href="#Xcode-Drak-theme" class="headerlink" title="Xcode Drak theme"></a>Xcode Drak theme</h3><ul><li><p>推荐指数：★</p></li><li><p>插件功能：主题</p></li></ul><h3 id="Material-Theme-UI"><a href="#Material-Theme-UI" class="headerlink" title="Material Theme UI"></a>Material Theme UI</h3><ul><li><p>推荐指数：★</p></li><li><p>插件功能：多种主题</p></li></ul><p>对于很多人而言，写代码时略显枯燥的，如果能够安装自己喜欢的主题将为开发工作带来些许乐趣。IDEA 支持各种主题插件，其中最出名的当属 Material Theme UI。安装后，可以从该插件内置的各种风格个选择自己最喜欢的一种。</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>企业开发规范和技巧</title>
      <link href="/2022/01/27/%E5%BC%80%E5%8F%91%E5%B7%A5%E4%BD%9C/%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83%E5%92%8C%E6%8A%80%E5%B7%A7/"/>
      <url>/2022/01/27/%E5%BC%80%E5%8F%91%E5%B7%A5%E4%BD%9C/%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83%E5%92%8C%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="开发规范"><a href="#开发规范" class="headerlink" title="开发规范"></a>开发规范</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>​        没有看过<a href="https://developer.aliyun.com/topic/java20?utm_content=g_1000163107">阿里开发规范</a>的同学可以先阅读一遍规范里面的内容，《Java 开发手册》是阿里巴巴集团技术团队的集体智慧结晶和经验总结，经历了多次大规模一 线实战的检验及不断完善，公开到业界后，众多社区开发者踊跃参与，共同打磨完善，系统化地整理 成册。为提高软件的最终交付质量，五花八门的错误码人为地 增加排查问题的难度;数据库的表结构和索引设计缺陷带来的系统架构缺陷或性能风险;工程结构混 乱导致后续项目维护艰难;没有鉴权的漏洞代码易被黑客攻击等等，制定一套开发规范出来还是很有必要的，对于增强代码的可读性，提高项目的维护成本，提高问题的排查速度，都会有重要的作用。</p><h3 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h3>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring技术笔记</title>
      <link href="/2022/01/27/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Spring/"/>
      <url>/2022/01/27/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Spring/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring底层核心原理解析"><a href="#Spring底层核心原理解析" class="headerlink" title="Spring底层核心原理解析"></a>Spring底层核心原理解析</h2><h3 id="下载Spring源码"><a href="#下载Spring源码" class="headerlink" title="下载Spring源码"></a>下载Spring源码</h3><p>git clone的地址为：<a href="https://gitee.com/archguide/spring-framework-5.3.10.git">https://gitee.com/archguide/spring-framework-5.3.10.git</a></p><h3 id="Bean的创建过程"><a href="#Bean的创建过程" class="headerlink" title="Bean的创建过程"></a>Bean的创建过程</h3><p><strong>那么Spring到底是如何来创建一个Bean的呢，这个就是Bean创建的生命周期，大致过程如下：</strong></p><ol><li>利用该类的构造方法来实例化得到一个对象（但是如何一个类中有多个构造方法，Spring则会进行选择，这个叫做推断构造方法）</li><li>得到一个对象后，Spring会判断该对象中是否存在被@Autowired注解了的属性，把这些属性找出来并由Spring进行赋值（依赖注入）</li><li>依赖注入后，Spring会判断该对象是否实现了BeanNameAware接口、BeanClassLoaderAware接口、BeanFactoryAware接口，如果实现了，就表示当前对象必须实现该接口中所定义的setBeanName()、setBeanClassLoader()、setBeanFactory()方法，那Spring就会调用这些方法并传入相应的参数（Aware回调）</li><li>Aware回调后，Spring会判断该对象中是否存在某个方法被@PostConstruct注解了，如果存在，Spring会调用当前对象的此方法（初始化前）</li><li>紧接着，Spring会判断该对象是否实现了InitializingBean接口，如果实现了，就表示当前对象必须实现该接口中的afterPropertiesSet()方法，那Spring就会调用当前对象中的afterPropertiesSet()方法（初始化）</li><li>最后，Spring会判断当前对象需不需要进行AOP，如果不需要那么Bean就创建完了，如果需要进行AOP，则会进行动态代理并生成一个代理对象做为Bean（初始化后）</li></ol><p><strong>通过最后一步，我们可以发现，当Spring根据UserService类来创建一个Bean时：</strong></p><ol><li>如果不用进行AOP，那么Bean就是UserService类的构造方法所得到的对象。</li><li>如果需要进行AOP，那么Bean就是UserService的代理类所实例化得到的对象，而不是UserService本身所得到的对象。</li></ol><p><strong>Bean对象创建出来后：</strong></p><ol><li>如果当前Bean是单例Bean，那么会把该Bean对象存入一个Map&lt;String,Object&gt;，Map的key为beanName，value为Bean对象。这样下次getBean时就可以直接从Map中拿到对应的Bean对象了。（实际上，在Spring源码中，这个Map就是单例池）</li><li>如果当前Bean是原型Bean，那么后续没有其他动作，不会存入一个Map，下次getBean时会再次执行上述创建过程，得到一个新的Bean对象。</li></ol><h3 id="推断构造方法"><a href="#推断构造方法" class="headerlink" title="推断构造方法"></a>推断构造方法</h3><p>Spring在基于某个类生成Bean的过程中，需要利用该类的构造方法来实例化得到一个对象，但是如果一个类存在多个构造方法，Spring会使用哪个呢？ Spring的判断逻辑如下：</p><ol><li>如果一个类只存在一个构造方法，不管该构造方法是无参构造方法，还是有参构造方法，Spring都会用这个构造方法</li><li>如果一个类存在多个构造方法<br>a. 这些构造方法中，存在一个无参的构造方法，那么Spring就会用这个无参的构造方法<br>b. 这些构造方法中，不存在一个无参的构造方法，那么Spring就会报错</li></ol><p><strong>Spring的设计思想是这样的：</strong></p><ol><li><p>如果一个类只有一个构造方法，那么没得选择，只能用这个构造方法</p></li><li><p>如果一个类存在多个构造方法，Spring不知道如何选择，就会看是否有无参的构造方法，因为无参构造方法本身表示了一种默认的意义</p></li><li><p>不过如果某个构造方法上加了@Autowired注解，那就表示程序员告诉Spring就用这个加了注解的方法，那Spring就会用这个加了@Autowired注解构造方法了</p></li></ol><p>需要重视的是，如果Spring选择了一个有参的构造方法，Spring在调用这个有参构造方法时，需要传入参数，那这个参数是怎么来的呢？ Spring会根据入参的类型和入参的名字去Spring中找Bean对象（以单例Bean为例，Spring会从单例池那个Map中去找）：</p><ol><li>先根据入参类型找，如果只找到一个，那就直接用来作为入参</li><li>如果根据类型找到多个，则再根据入参名字来确定唯一一个</li><li>最终如果没有找到，则会报错，无法创建当前Bean对象</li></ol><p>确定用哪个构造方法，确定入参的Bean对象，这个过程就叫做推断构造方法。 </p><h3 id="AOP大致流程"><a href="#AOP大致流程" class="headerlink" title="AOP大致流程"></a>AOP大致流程</h3><p>AOP就是进行动态代理，在创建一个Bean的过程中，Spring在最后一步会去判断当前正在创建的这个Bean是不是需要进行AOP，如果需要则会进行动态代理。 如何判断当前Bean对象需不需要进行AOP:</p><ol><li>找出所有的切面Bean</li><li>遍历切面中的每个方法，看是否写了@Before、@After等注解</li><li>如果写了，则判断所对应的Pointcut是否和当前Bean对象的类是否匹配</li><li>如果匹配则表示当前Bean对象有匹配的的Pointcut，表示需要进行AOP</li></ol><p><strong>利用cglib进行AOP的大致流程：</strong></p><ol><li>生成代理类UserServiceProxy，代理类继承UserService</li><li>代理类中重写了父类的方法，比如UserService中的test()方法</li><li>代理类中还会有一个target属性，该属性的值为被代理对象（也就是通过UserService类推断构造方法实例化出来的对象，进行了依赖注入、初始化等步骤的对象）</li><li>代理类中的test()方法被执行时的逻辑如下：<br>a. 执行切面逻辑（@Before）<br>b. 调用target.test()</li></ol><p>当我们从Spring容器得到UserService的Bean对象时，拿到的就是UserServiceProxy所生成的对象，也就是代理对象。<br>UserService代理对象.test()—&gt;执行切面逻辑—&gt;target.test()，注意target对象不是代理对象，而是被代理对象。 </p><h3 id="Spring事务"><a href="#Spring事务" class="headerlink" title="Spring事务"></a>Spring事务</h3><p>当我们在某个方法上加了@Transactional注解后，就表示该方法在调用时会开启Spring事务，而这个方法所在的类所对应的Bean对象会是该类的代理对象。 Spring事务的代理对象执行某个方法时的步骤：</p><ol><li>判断当前执行的方法是否存在@Transactional注解</li><li>如果存在，则利用事务管理器（TransactionMananger）新建一个数据库连接</li><li>修改数据库连接的autocommit为false</li><li>执行target.test()，执行程序员所写的业务逻辑代码，也就是执行sql</li><li>执行完了之后如果没有出现异常，则提交，否则回滚</li></ol><p>Spring事务是否会失效的判断标准：某个加了@Transactional注解的方法被调用时，要判断到底是不是直接被代理对象调用的，如果是则事务会生效，如果不是则失效。</p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker操作笔记-从小白到入门</title>
      <link href="/2022/01/27/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/Docker%E6%93%8D%E4%BD%9C%E7%AC%94%E8%AE%B0-%E4%BB%8E%E5%B0%8F%E7%99%BD%E5%88%B0%E5%85%A5%E9%97%A8/"/>
      <url>/2022/01/27/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/Docker%E6%93%8D%E4%BD%9C%E7%AC%94%E8%AE%B0-%E4%BB%8E%E5%B0%8F%E7%99%BD%E5%88%B0%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="1、Docker安装"><a href="#1、Docker安装" class="headerlink" title="1、Docker安装"></a>1、Docker安装</h3><p>centos  为例：查看版本：<code>cat /etc/redhat-release</code> <a href="https://docs.docker.com/install/linux/docker-ce/centos/">参考网址</a> </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.先安装gcc：yum -y install gcc  </span><br><span class="line">2.查看版本：gcc -v</span><br></pre></td></tr></table></figure><p><strong>安装需要的软件包</strong> <span id="more"></span></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure><h4 id="1-1、阿里加速："><a href="#1-1、阿里加速：" class="headerlink" title="1.1、阿里加速："></a>1.1、阿里加速：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><ul><li><strong>查看配置：</strong> <code>vi /etc/yum.repos.d/docker-ce.repo</code></li><li><strong>更新软件包：</strong> <code>yum makecache fast</code></li><li><strong>安装docker：</strong>  <code>yum install docker-ce docker-ce-cli containerd.io</code></li><li><strong>配置文件位置：</strong> <code>/etc/sysconfig/docker</code></li><li><strong>启动docker：</strong> <code>systemctl start docker</code></li><li><strong>设置开机启动：</strong> <code>systemctl enable docker</code></li><li><strong>查看docker启动进程：</strong> <code>ps -ef|grep docker</code></li><li><strong>查看docker版本：</strong> <code>docker version  docker info</code>   </li></ul><h4 id="1-2、下载镜像"><a href="#1-2、下载镜像" class="headerlink" title="1.2、下载镜像"></a>1.2、下载镜像</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysql:5.7  </span><br><span class="line">docker pull rabbitmq:management （带管理台的MQ）</span><br><span class="line">docker pull zookeeper:latest  </span><br><span class="line">docker pull redis:rc-buster</span><br></pre></td></tr></table></figure><ol><li><a href="https://hub.docker.com/search?q=&type=image">镜像搜索地址</a></li><li><a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors">镜像加速地址</a></li></ol><hr><h4 id="1-3、权限问题解决"><a href="#1-3、权限问题解决" class="headerlink" title="1.3、权限问题解决"></a>1.3、权限问题解决</h4><p>docker守护进程启动的时候，会默认赋予名字为docker的用户组读写Unix socket的权限，因此只要创建docker用户组，并将当前用户加入到docker用户组中，那么当前用户就有权限访问Unix socket了，进而也就可以执行docker相关命令</p><ol><li>添加docker用户组 <code>sudo groupadd docker</code> </li><li>将登陆用户加入到docker用户组中  <code>sudo gpasswd -a  $USER  docker</code></li><li>更新用户组 <code>newgrp docker</code></li><li>测试docker命令是否可以使用sudo正常使用 <code>docker ps</code> </li></ol><hr><h3 id="2、镜像操作"><a href="#2、镜像操作" class="headerlink" title="2、镜像操作"></a>2、镜像操作</h3><ul><li>查看镜像：<code>docker images</code>    </li><li>展示所有所有镜像（包含中间镜像层）：<code>docker images -a</code></li><li>查询镜像：<code>docker search 镜像名字</code></li><li>删除镜像：<code>docker rmi 镜像id</code></li></ul><h3 id="3、容器操作"><a href="#3、容器操作" class="headerlink" title="3、容器操作"></a>3、容器操作</h3><ul><li><strong>启动mysql：</strong> <code>docker run -p 3306:3306 --name mysql01 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7</code></li><li><strong>启动rabitmq：</strong> <code>docker run -d -p 5672:5672 -p 15672:15672 --name myrabitmq 镜像id</code> </li><li><strong>启动redis：</strong> <code>docker run -d -p 6379:6379 --name myredis 镜像id</code>   </li><li><strong>启动zookeeper：</strong> <code>docker run --name zk01 -p 2181:2181 --restart always -d 镜像id</code> </li><li><strong>启动nacos：</strong> <code>docker run --name nacos-2.0.1 -e MODE=standalone -p 8849:8848 -d nacos/nacos-server:2.0.1</code></li><li><strong>启动kibana：</strong> <code>docker run -d --name kibana7.7.1 --net mynet   -p 5601:5601 kibana:7.7.1</code></li></ul><p><strong>Kibana 在Doker中启动相关配置</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it kibana7.7.1 bash</span><br><span class="line">cd config </span><br><span class="line">vi kibana.yml</span><br></pre></td></tr></table></figure><ul><li><strong>查看日志：</strong> docker logs -f -t –tail 100 kibana7.7.1</li><li><strong>更新启动参数：</strong> docker update –restart=always xxx  </li><li><strong>查看所有容器：</strong> <code>docker ps -a</code></li><li><strong>查看启动容器：</strong> <code>docker ps</code>    </li><li><strong>启动已停止的容器：</strong> <code>docker start 容器id或名字</code></li><li><strong>关闭容器 ：</strong> <code>docker stop 容器id</code>    </li><li><strong>取消容器开机启动：</strong> <code>docker update --restart=no 容器ID</code></li><li><strong>强制关闭：</strong>  <code>docker kill 容器id</code>   </li><li><strong>删除已停止容器 ：</strong> <code>docker rm 容器id</code>    </li><li><strong>删除没有停止容器：</strong>  <code>docker rm -f 容器id</code>  </li><li><strong>进入容器内部：</strong> <code>docker exec -it 程序id /bin/bash</code>    </li><li><strong>exit 关闭容器退出(自测不会退出)：</strong>    <code>ctrl+p+q</code></li><li><strong>查看日志：</strong> <code>docker logs -f (追加) -t (加入时间戳) --tail 3 (显示最后3行) 容器id</code>  </li><li><strong>查看容器结构细节：</strong> <code>docker inspect 容器id</code>  </li><li><strong>拷贝容器中的文件：</strong> <code>docker cp 容器id:文件路径 要拷贝到的路径</code></li><li><strong>提交自己的docker镜像：</strong> <code>docker commit -a=&quot;lgd&quot; -m=&quot;mysql-lgd&quot; 243baa0ea2a7 ligoudan/lgd-mysql:1.0</code>  </li></ul>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ消息中间件技术笔记</title>
      <link href="/2022/01/27/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/RabbitMQ/"/>
      <url>/2022/01/27/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/RabbitMQ/</url>
      
        <content type="html"><![CDATA[<h2 id="MQ相关概念"><a href="#MQ相关概念" class="headerlink" title="MQ相关概念"></a>MQ相关概念</h2><h3 id="什么是MQ"><a href="#什么是MQ" class="headerlink" title="什么是MQ"></a>什么是MQ</h3><p>MQ(message queue)，从字面意思上看，本质是个队列，FIFO 先入先出，只不过队列中存放的内容是message 而已，还是一种跨进程的通信机制，用于上下游传递消息。在互联网架构中，MQ 是一种非常常见的上下游“逻辑解耦+物理解耦”的消息通信服务。使用了 MQ之后，消息发送上游只需要依赖 MQ，不用依赖其他服务。</p><h3 id="为什么要用MQ"><a href="#为什么要用MQ" class="headerlink" title="为什么要用MQ"></a>为什么要用MQ</h3><ol><li><p>流量消峰</p><p>举个例子，如果订单系统最多能处理一万次订单，这个处理能力应付正常时段的下单时绰绰有余，正常时段我们下单一秒后就能返回结果。但是在高峰期，如果有两万次下单操作系统是处理不了的，只能限制订单超过一万后不允许用户下单。使用消息队列做缓冲，我们可以取消这个限制，把一秒内下的订单分散成一段时间来处理，这时有些用户可能在下单十几秒后才能收到下单成功的操作，但是比不能下单的体验要好。</p><p><img src="/images/studyNote/rabbitMQ/20210903_142709.png"></p></li><li><p>应用解耦</p><p>以电商应用为例，应用中有订单系统、库存系统、物流系统、支付系统。用户创建订单后，如果耦合调用库存系统、物流系统、支付系统，任何一个子系统出了故障，都会造成下单操作异常。当转变成基于消息队列的方式后，系统间调用的问题会减少很多，比如物流系统因为发生故障，需要几分钟来修复。在这几分钟的时间里，物流系统要处理的内存被缓存在消息队列中，用户的下单操作可以正常完成。当物流系统恢复后，继续处理订单信息即可，中单用户感受不到物流系统的故障，提升系统的可用性。</p><p><img src="/images/studyNote/rabbitMQ/20210903_142118.png"></p><p><img src="/images/studyNote/rabbitMQ/20210903_142315.png"></p></li><li><p>异步提速</p><p>有些服务间调用是异步的，例如 A 调用 B，B 需要花费很长时间执行，但是 A 需要知道 B 什么时候可以执行完，以前一般有两种方式，A 过一段时间去调用 B 的查询 api 查询。或者 A 提供一个 callback api，B 执行完之后调用 api 通知 A 服务。这两种方式都不是很优雅，使用消息总线，可以很方便解决这个问题，A 调用 B 服务后，只需要监听 B 处理完成的消息，当 B 处理完成后，会发送一条消息给 MQ，MQ 会将此消息转发给 A 服务。这样 A 服务既不用循环调用 B 的查询 api，也不用提供 callback api。同样 B 服务也不用做这些操作。A 服务还能及时的得到异步处理成功的消息。</p><p><img src="/images/studyNote/rabbitMQ/20210903_142435.png"></p><p><img src="/images/studyNote/rabbitMQ/20210903_142525.png"></p></li></ol><h3 id="MQ的分类"><a href="#MQ的分类" class="headerlink" title="MQ的分类"></a>MQ的分类</h3><p><img src="/images/studyNote/rabbitMQ/20210903_142909.png"></p><h4 id="ActiveMQ"><a href="#ActiveMQ" class="headerlink" title="ActiveMQ"></a>ActiveMQ</h4><p><strong>优点：</strong>单机吞吐量万级，时效性 ms 级，可用性高，基于主从架构实现高可用性，消息可靠性较低的概率丢失数据。</p><p><strong>缺点：</strong>官方社区现在对 ActiveMQ 5.x 维护越来越少，高吞吐量场景较少使用。</p><h4 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h4><p>大数据的杀手锏，谈到大数据领域内的消息传输，则绕不开 Kafka，这款为大数据而生的消息中间件，以其<strong>百万级 TPS 的吞吐量</strong>名声大噪，迅速成为大数据领域的宠儿，在数据采集、传输、存储的过程中发挥着举足轻重的作用。目前已经被 LinkedIn，Uber, Twitter, Netflix 等大公司所采纳。</p><p><strong>优点：</strong>性能卓越，单机写入 TPS 约在<strong>百万条/秒</strong>，最大的优点，就是吞吐量高。时效性 ms 级可用性非常高，kafka 是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用,消费者采用 Pull 方式获取消息, 消息有序, 通过控制能够保证所有消息被消费且仅被消费一次;有优秀的第三方Kafka Web 管理界面 Kafka-Manager；在日志领域比较成熟，被多家公司和多个开源项目使用；功能支持：功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用。</p><p><strong>缺点：</strong>Kafka 单机超过 64 个队列/分区，Load 会发生明显的飙高现象，队列越多，load 越高，发送消息响应时间变长，使用短轮询方式，实时性取决于轮询间隔时间，消费失败不支持重试；支持消息顺序，但是一台代理宕机后，就会产生消息乱序，社区更新较慢。</p><h4 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h4><p>RocketMQ 出自阿里巴巴的开源产品，用 Java 语言实现，在设计时参考了 Kafka，并做出了自己的一些改进。被阿里巴巴广泛应用在订单，交易，充值，流计算，消息推送，日志流式处理，binglog 分发等场景。</p><p><strong>优点：</strong>单机吞吐量十万级,可用性非常高，分布式架构,消息可以做到 0 丢失,MQ 功能较为完善，还是分布式的，扩展性好,支持 10 亿级别的消息堆积，不会因为堆积导致性能下降,源码是 java 我们可以自己阅读源码，定制自己公司的 MQ。</p><p><strong>缺点：</strong>支持的客户端语言不多，目前是 java 及 c++，其中 c++不成熟；社区活跃度一般,没有在 MQ核心中去实现 JMS 等接口,有些系统要迁移需要修改大量代码。</p><h4 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h4><p>2007 年发布，是一个在 AMQP(高级消息队列协议)基础上完成的，可复用的企业消息系统，是当前最主流的消息中间件之一。</p><p><strong>优点：</strong>由于 erlang 语言的高并发特性，性能较好；吞吐量到万级，MQ 功能比较完备,健壮、稳定、易用、跨平台、支持多种语言 如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持 AJAX 文档齐全；开源提供的管理界面非常棒，用起来很好用,社区活跃度高；更新频率相当高。</p><p><strong>缺点：</strong>商业版需要收费,学习成本较高。</p><h3 id="MQ的选择"><a href="#MQ的选择" class="headerlink" title="MQ的选择"></a>MQ的选择</h3><h4 id="Kafka-1"><a href="#Kafka-1" class="headerlink" title="Kafka"></a>Kafka</h4><p>Kafka 主要特点是基于 Pull 的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于日志收集和传输，适合产生大量数据的互联网服务的数据收集业务。大型公司建议可以选用，如果有日志采集功能，肯定是首选 kafka 了。</p><h4 id="RocketMQ-1"><a href="#RocketMQ-1" class="headerlink" title="RocketMQ"></a>RocketMQ</h4><p>天生为金融互联网领域而生，对于可靠性要求很高的场景，尤其是电商里面的订单扣款，以及业务削峰，在大量交易涌入时，后端可能无法及时处理的情况。RoketMQ 在稳定性上可能更值得信赖，这些业务场景在阿里双 11 已经经历了多次考验，如果你的业务有上述并发场景，建议可以选择 RocketMQ。</p><h4 id="RabbitMQ-1"><a href="#RabbitMQ-1" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h4><p>结合 erlang 语言本身的并发优势，性能好时效性微秒级，社区活跃度也比较高，管理界面用起来十分方便，如果你的数据量没有那么大，中小型公司优先选择功能比较完备的 RabbitMQ。</p><h2 id="RabbitMQ简介"><a href="#RabbitMQ简介" class="headerlink" title="RabbitMQ简介"></a>RabbitMQ简介</h2><p>2007年，Rabbit 技术公司基于 AMQP 标准开发的 RabbitMQ 1.0 发布。RabbitMQ 采用 Erlang 语言开发。Erlang 语言由 Ericson 设计，专门为开发高并发和分布式系统的一种语言，在电信领域使用广泛。</p><h3 id="RabbitMQ四大核心概念"><a href="#RabbitMQ四大核心概念" class="headerlink" title="RabbitMQ四大核心概念"></a>RabbitMQ四大核心概念</h3><ul><li><p>生产者<br>产生数据发送消息的程序是生产者</p></li><li><p>交换机<br>交换机是 RabbitMQ 非常重要的一个部件，一方面它接收来自生产者的消息，另一方面它将消息推送到队列中。交换机必须确切知道如何处理它接收到的消息，是将这些消息推送到特定队列还是推送到多个队列，亦或者是把消息丢弃，这个得有交换机类型决定。</p></li><li><p>队列</p><p>队列是 RabbitMQ 内部使用的一种数据结构，尽管消息流经 RabbitMQ 和应用程序，但它们只能存储在队列中。队列仅受主机的内存和磁盘限制的约束，本质上是一个大的消息缓冲区。许多生产者可以将消息发送到一个队列，许多消费者可以尝试从一个队列接收数据。这就是我们使用队列的方式。</p></li><li><p>消费者</p><p>消费与接收具有相似的含义。消费者大多时候是一个等待接收消息的程序。请注意生产者，消费者和消息中间件很多时候并不在同一机器上。同一个应用程序既可以是生产者又是可以是消费者。</p></li></ul><p><img src="/images/studyNote/rabbitMQ/20210903_143731.png"></p><h3 id="RabbitMQ的工作模式"><a href="#RabbitMQ的工作模式" class="headerlink" title="RabbitMQ的工作模式"></a>RabbitMQ的工作模式</h3><p><img src="/images/studyNote/rabbitMQ/20210902_222744.png"></p><ol><li><strong>简单模式</strong> HelloWorld： 一个生产者、一个消费者，不需要设置交换机（使用默认的交换机）。</li><li><strong>工作队列模式</strong> Work Queue：   一个生产者、多个消费者（竞争关系），不需要设置交换机（使用默认的交换机）。</li><li><strong>发布订阅模式</strong> Publish/subscribe：需要设置类型为 fanout 的交换机，并且交换机和队列进行绑定，当发送消息到交换机后，交换机会将消息发送到绑定的队列。</li><li><strong>路由模式</strong> Routing：   需要设置类型为 direct 的交换机，交换机和队列进行绑定，并且指定 routing key，当发送消息到交换机后，交换机会根据 routing key 将消息发送到对应的队列。</li><li><strong>通配符模式</strong> Topic：需要设置类型为 topic 的交换机，交换机和队列进行绑定，并且指定通配符方式的 routing key，当发送消息到交换机后，交换机会根据 routing key 将消息发送到对应的队列。</li></ol><h3 id="RabbitMQ工作原理"><a href="#RabbitMQ工作原理" class="headerlink" title="RabbitMQ工作原理"></a>RabbitMQ工作原理</h3><p><img src="/images/studyNote/rabbitMQ/20210902_222911.png"></p><p><strong>Broker：</strong>接收和分发消息的应用，RabbitMQ Server 就是 Message Broker</p><p><strong>Virtual host：</strong>出于多租户和安全因素设计的，把 AMQP 的基本组件划分到一个虚拟的分组中，类似于网络中的 namespace 概念。当多个不同的用户使用同一个 RabbitMQ server 提供的服务时，可以划分出多个 vhost，每个用户在自己的 vhost 创建 exchange／queue 等</p><p><strong>Connection：</strong>publisher／consumer 和 broker 之间的 TCP 连接</p><p><strong>Channel：</strong>如果每一次访问 RabbitMQ 都建立一个 Connection，在消息量大的时候建立 TCPConnection 的开销将是巨大的，效率也较低。Channel 是在 connection 内部建立的逻辑连接，如果应用程序支持多线程，通常每个 thread 创建单独的 channel 进行通讯，AMQP method 包含了 channel id 帮助客户端和 message broker 识别 channel，所以 channel 之间是完全隔离的。 l Channel  作为轻量级的Connection 极大减少了操作系统建立 TCP connection 的开销</p><p><strong>Exchange ：</strong> message 到达 broker 的第一站，根据分发规则，匹配查询表中的 routing key，分发消息到 queue 中去。常用的类型有：direct (point-to-point), topic (publish-subscribe) and fanout(multicast)</p><p><strong>Queue ：</strong> 消息最终被送到这里等待 consumer 取走</p><p><strong>Binding ：</strong> exchange 和 queue 之间的虚拟连接，binding 中可以包含 routing key，Binding 信息被保存到 exchange 中的查询表中，用于 message 的分发依据</p><h3 id="RabbitMQ安装"><a href="#RabbitMQ安装" class="headerlink" title="RabbitMQ安装"></a>RabbitMQ安装</h3><p>略….推荐使用Docker安装学习，参考文章：Docker操作笔记-从小白到入门</p><p>RabbitMQ在安装好后，可以访问<a href="http://ip地址:15672/">http://ip地址:15672</a> ;其自带了guest/guest的 用户名和密码。</p><h4 id="角色说明"><a href="#角色说明" class="headerlink" title="角色说明"></a>角色说明</h4><ul><li>超级管理员(administrator)：可登陆管理控制台，可查看所有的信息，并且可以对用户，策略(policy)进行操 作。</li><li>监控者(monitoring)：可登陆管理控制台，同时可以查看rabbitmq节点的相关信息(进程数，内存使用 情况，磁盘使用情况等)。</li><li>策略制定者(policymaker)：可登陆管理控制台, 同时可以对policy进行管理。但无法查看节点的相关信息(上 图红框标识的部分)。</li><li>普通管理者(management)：仅可登陆管理控制台，无法看到节点信息，也无法对策略进行管理。</li><li>其他：无法登陆管理控制台，通常就是普通的生产者和消费者。</li></ul><h2 id="消息应答及持久化"><a href="#消息应答及持久化" class="headerlink" title="消息应答及持久化"></a>消息应答及持久化</h2><h3 id="消息应答机制"><a href="#消息应答机制" class="headerlink" title="消息应答机制"></a>消息应答机制</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>消费者完成一个任务可能需要一段时间，如果其中一个消费者处理一个长的任务并仅只完成了部分突然它挂掉了，会发生什么情况。RabbitMQ 一旦向消费者传递了一条消息，便立即将该消息标记为删除。在这种情况下，突然有个消费者挂掉了，我们将丢失正在处理的消息。以及后续发送给该消费这的消息，因为它无法接收到。为了保证消息在发送过程中不丢失，rabbitmq 引入消息应答机制，消息应答就是: <strong>消费者在接收到消息并且处理该消息之后</strong>，告诉rabbitmq  它已经处理了，rabbitmq  可以把该消息删除了。</p><h4 id="自动应答"><a href="#自动应答" class="headerlink" title="自动应答"></a>自动应答</h4><p>消息发送后立即被认为已经传送成功，这种模式需要在<strong>高吞吐量和数据传输安全性方面做权衡</strong>,因为这种模式如果消息在接收到之前，消费者那边出现连接或者 channel 关闭，那么消息就丢失了,当然另一方面这种模式消费者那边可以传递过载的消息，<strong>没有对传递的消息数量进行限制</strong>，当然这样有可能使得消费者这边由于接收太多还来不及处理的消息，导致这些消息的积压，最终使得内存耗尽，最终这些消费者线程被操作系统杀死， 所以<strong>这种模式仅适用在消费者可以高效并以某种速率能够处理这些消息的情况下使用</strong>。</p><p>总结：尽量少用自动应答，自动应答是在接收到消息的一刹那就进行了应答，如果后续对消息进行了处理出现错误，不能重新从队列中获取消息处理。</p><h4 id="手动应答"><a href="#手动应答" class="headerlink" title="手动应答"></a>手动应答</h4><h5 id="消息应答的方法"><a href="#消息应答的方法" class="headerlink" title="消息应答的方法"></a>消息应答的方法</h5><ul><li>Channel.basicAck(用于肯定确认)：RabbitMQ 已知道该消息并且成功的处理消息，可以将其丢弃了</li><li>Channel.basicNack(用于否定确认)</li><li>Channel.basicReject(用于否定确认)：与 Channel.basicNack 相比少一个参数(是否批量处理)，不处理该消息了直接拒绝，可以将其丢弃了</li></ul><p>手动应答的好处是可以批量应答并且减少网络拥堵</p><p><img src="/images/studyNote/rabbitMQ/20210902_225727.png"></p><p>multiple 的 true 和 false 代表不同意思</p><ul><li>true 代表批量应答 channel 上未应答的消息，比如说 channel 上有传送 tag 的消息 5,6,7,8 当前 tag 是 8 那么此时5-8 的这些还未应答的消息都会被确认收到消息应答</li><li>false 同上面相比只会应答 tag=8 的消息 5,6,7 这三个消息依然不会被确认收到消息应答</li></ul><p><img src="/images/studyNote/rabbitMQ/20210902_225929.png"></p><h3 id="消息自动重新入队"><a href="#消息自动重新入队" class="headerlink" title="消息自动重新入队"></a>消息自动重新入队</h3><p>如果消费者由于某些原因失去连接(其通道已关闭，连接已关闭或 TCP 连接丢失)，导致消息未发送 ACK 确认，<font color=red face="黑体">RabbitMQ 将了解到消息未完全处理，并将对其重新排队。</font>如果此时其他消费者可以处理，它将很快将其重新分发给另一个消费者。这样，即使某个消费者偶尔死亡，也可以确保不会丢失任何消息。</p><p><img src="/images/studyNote/rabbitMQ/20210902_230720.png"></p><h3 id="消息手动应答代码编写"><a href="#消息手动应答代码编写" class="headerlink" title="消息手动应答代码编写"></a>消息手动应答代码编写</h3><p>默认消息采用的是自动应答，所以我们要想实现消息消费过程中不丢失，需要把自动应答改为手动应答，消费者在上面代码的基础上增加下面画红色部分代码。</p><p><img src="/images/studyNote/rabbitMQ/20210903_093454.png"></p><h4 id="消息生产者"><a href="#消息生产者" class="headerlink" title="消息生产者"></a>消息生产者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 队列名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TASK_QUEUE_NAME = <span class="string">&quot;ack_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line">        <span class="comment">// 声明队列：队列名称，是否持久化，是否共享，自动删除，参数</span></span><br><span class="line">        channel.queueDeclare(TASK_QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">            String message = scanner.next();</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, TASK_QUEUE_NAME, <span class="keyword">null</span>,</span><br><span class="line">                    message.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">            log.info(<span class="string">&quot;生产者发送消息：&#123;&#125;&quot;</span>, message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>RabbitMQ 连接工具类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMqUtils</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 得到一个连接的 channel</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Channel <span class="title">getChannel</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个连接工厂</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;guest&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;guest&quot;</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;demo&quot;</span>);</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="keyword">return</span> channel;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Work01</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ACK_QUEUE_NAME = <span class="string">&quot;ack_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line">        System.out.println(<span class="string">&quot;Work01  等待接收消息处理时间较短&quot;</span>);</span><br><span class="line">        <span class="comment">// 消息消费的时候如何处理消息</span></span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            String message = <span class="keyword">new</span> String(delivery.getBody());</span><br><span class="line">            <span class="comment">// 业务处理耗时1秒</span></span><br><span class="line">            SleepUtils.sleep(<span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot; 接收到消息:&quot;</span> + message);</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 采用手动应答</span></span><br><span class="line"><span class="comment">             * 1. 消息标记 tag</span></span><br><span class="line"><span class="comment">             * 2. 是否批量应答未应答消息：不批量信道中的消息</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// ***采用手动应答</span></span><br><span class="line">        <span class="keyword">boolean</span> autoAck = <span class="keyword">false</span>;</span><br><span class="line">        channel.basicConsume(ACK_QUEUE_NAME, autoAck, deliverCallback, (consumerTag) -&gt; &#123;</span><br><span class="line">            System.out.println(consumerTag + <span class="string">&quot; 消费者取消消费接口回调逻辑&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>睡眠工具</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepUtils</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">int</span> second)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000L</span> * second);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RabbitMQ-持久化"><a href="#RabbitMQ-持久化" class="headerlink" title="RabbitMQ 持久化"></a><strong>RabbitMQ</strong> 持久化</h3><h4 id="持久化概念"><a href="#持久化概念" class="headerlink" title="持久化概念"></a>持久化概念</h4><p>刚刚我们已经看到了如何处理任务不丢失的情况，但是如何<strong>保障当 RabbitMQ 服务停掉以后消息生产者发送过来的消息不丢失</strong>。默认情况下 RabbitMQ 退出或由于某种原因崩溃时，它忽视队列和消息，除非告知它不要这样做。确保消息不会丢失需要做两件事：我们需要将<strong>队列和消息</strong>都标记为持久化。</p><h4 id="队列实现持久化"><a href="#队列实现持久化" class="headerlink" title="队列实现持久化"></a>队列实现持久化</h4><p>之前我们创建的队列都是非持久化的，rabbitmq 如果重启的化，该队列就会被删除掉，如果 要队列实现持久化 需要在声明队列的时候把 durable 参数设置为持久化</p><p><img src="/images/studyNote/rabbitMQ/20210903_104223.png"></p><p>但是需要注意的就是如果之前声明的队列不是持久化的，需要把原先队列先删除，或者重新创建一个持久化的队列，不然就会出现错误。</p><p><img src="/images/studyNote/rabbitMQ/20210903_104728.png"></p><p>以下为控制台中持久化与非持久化队列的 UI 显示区：</p><p><img src="/images/studyNote/rabbitMQ/20210903_104945.png"> 这个时候即使重启 rabbitmq 队列也依然存在。</p><h4 id="消息实现持久化"><a href="#消息实现持久化" class="headerlink" title="消息实现持久化"></a>消息实现持久化</h4><p>要想让消息实现持久化需要在消息生产者修改代码，MessageProperties.PERSISTENT_TEXT_PLAIN 添加这个属性，如下图</p><p><img src="/images/studyNote/rabbitMQ/20210903_105242.png"></p><p>将消息标记为持久化并不能完全保证不会丢失消息。尽管它告诉 RabbitMQ 将消息保存到磁盘，但是 这里依然存在当消息刚准备存储在磁盘的时候 但是还没有存储完，消息还在缓存的一个间隔点。此时并没 有真正写入磁盘。持久性保证并不强，但是对于我们的简单任务队列而言，这已经绰绰有余了。如果需要 更强有力的持久化策略，参考后边课件发布确认章节。</p><h3 id="不公平分发"><a href="#不公平分发" class="headerlink" title="不公平分发"></a>不公平分发</h3><p>在最开始的时候我们学习到 RabbitMQ 分发消息采用的轮训分发，但是在某种场景下这种策略并不是很好，比方说有两个消费者在处理任务，其中有个消费者 1 处理任务的速度非常快，而另外一个消费者 2 处理速度却很慢，这个时候我们还是采用轮训分发的化就会到这处理速度快的这个消费者很大一部分时间处于空闲状态，而处理慢的那个消费者一直在干活，这种分配方式在这种情况下其实就不太好，但是<br>RabbitMQ 并不知道这种情况它依然很公平的进行分发。</p><p><font color=red>注：</font>为了避免这种情况，我们可以设置参数 channel.basicQos(1)，不公平分发由消费方设置，<font color=red >生产环境应该设置为不公平分发。</font> </p><p><img src="/images/studyNote/rabbitMQ/20210907_03532.png"></p><p><img src="/images/studyNote/rabbitMQ/20210907_03616.png"></p><p><img src="/images/studyNote/rabbitMQ/20210907_04707.png"></p><p>意思就是如果这个任务我还没有处理完或者我还没有应答你，你先别分配给我，我目前只能处理一个任务，然后 rabbitmq 就会把该任务分配给没有那么忙的那个空闲消费者，当然如果所有的消费者都没有完成手上任务，队列还在不停的添加新任务，队列有可能就会遇到队列被撑满的情况，这个时候就只能添加新的 worker 或者改变其他存储任务的策略。</p><h2 id="发布确认"><a href="#发布确认" class="headerlink" title="发布确认"></a>发布确认</h2><h3 id="发布确认原理"><a href="#发布确认原理" class="headerlink" title="发布确认原理"></a>发布确认原理</h3><p>生产者将信道设置成 confirm 模式，一旦信道进入confirm 模式，所有在该信道上面发布的消息都将会被指派一个唯一的ID(从1开始)，一旦消息被投递到所有匹配的队列之后，broker 就会发送一个确认给生产者(包含消息的唯一ID)，这就使得生产者知道消息已经正确到达目的队列了，如果消息和队列是可持久化的，那么确认消息会在将消息写入磁盘之后发出，broker回传 给生产者的确认消息中 delivery-tag 域包含了确认消息的序列号，此外broker也可以设置basic.ack的multiple域，表示到这个序列号之前的所有消息都已经得到了处理。confirm 模式最大的好处在于他是异步的，一旦发布一条消息，生产者应用程序就可以在等信道返回确认的同时继续发送下一条消息，当消息最终得到确认之后，生产者应用便可以通过回调方法来处理该确认消息，如果 RabbitMQ因为自身内部错误导致消息丢失，就会发送一条nack消 息，生产者应用程序同样可以在回调方法中处理该nack消息。</p><h3 id="发布确认的策略"><a href="#发布确认的策略" class="headerlink" title="发布确认的策略"></a>发布确认的策略</h3><h4 id="开启发布确认的方法"><a href="#开启发布确认的方法" class="headerlink" title="开启发布确认的方法"></a>开启发布确认的方法</h4><p>发布确认默认是没有开启的，如果要开启需要调用方法 confirmSelect，每当你要想使用发布确认，都需要在 channel 上调用该方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Channel channel = connection.createchannel();</span><br><span class="line">channel.confirmselect();</span><br></pre></td></tr></table></figure><h4 id="第一种：单个确认发布"><a href="#第一种：单个确认发布" class="headerlink" title="第一种：单个确认发布"></a>第一种：单个确认发布</h4><p>这是一种简单的确认方式，它是一种<strong>同步确认发布的方式</strong>，也就是发布一个消息之后只有它 被确认发布，后续的消息才能继续发布,waitForConfirmsOrDie(long)这个方法只有在消息被确认 的时候才返回，如果在指定时间范围内这个消息没有被确认那么它将抛出异常。这种确认方式有一个最大的缺点就是:<strong>发布速度特别的慢</strong>，因为如果没有确认发布的消息就会 阻塞所有后续消息的发布，这种方式最多提供每秒不超过数百条发布消息的吞吐量。当然对于某 些应用程序来说这可能已经足够了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发布单条消息1000条耗时测试： 722ms</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">publishMessageOne</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (Channel channel = RabbitMqUtils.getChannel()) &#123;</span><br><span class="line">        String queueName = UUID.randomUUID().toString();</span><br><span class="line">        channel.queueDeclare(queueName, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 开启发布确认</span></span><br><span class="line">        channel.confirmSelect();</span><br><span class="line">        <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MESSAGE_COUNT; i++) &#123;</span><br><span class="line">            String message = i + <span class="string">&quot;&quot;</span>;</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">            <span class="comment">// 发送之后马上进行发布确认，服务端返回 false 或超时时间内未返回，生产者可以消息重发</span></span><br><span class="line">            <span class="keyword">boolean</span> flag = channel.waitForConfirms();</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot; 消息发送成功&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot; 发布&quot;</span> + MESSAGE_COUNT + <span class="string">&quot; 个单独确认消息, 耗时&quot;</span> + (end - begin) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="第二种：批量确认发布"><a href="#第二种：批量确认发布" class="headerlink" title="第二种：批量确认发布"></a>第二种：批量确认发布</h4><p>上面那种方式非常慢，与单个等待确认消息相比，先发布一批消息然后一起确认可以极大地 提高吞吐量，当然这种方式的缺点就是:当发生故障导致发布出现问题时，不知道是哪个消息出现 问题了，我们必须将整个批处理保存在内存中，以记录重要的信息而后重新发布消息。当然这种 方案仍然是同步的，也一样阻塞消息的发布。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 批量发布确认 发布1000个消息，耗时141ms</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">publishMessageBatch</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (Channel channel = RabbitMqUtils.getChannel()) &#123;</span><br><span class="line">        String queueName = UUID.randomUUID().toString();</span><br><span class="line">        channel.queueDeclare(queueName, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 开启发布确认</span></span><br><span class="line">        channel.confirmSelect();</span><br><span class="line">        <span class="comment">// 批量确认消息大小</span></span><br><span class="line">        <span class="keyword">int</span> batchSize = <span class="number">100</span>;</span><br><span class="line">        <span class="comment">// 未确认消息个数</span></span><br><span class="line">        <span class="keyword">int</span> outstandingMessageCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MESSAGE_COUNT; i++) &#123;</span><br><span class="line">            String message = i + <span class="string">&quot;&quot;</span>;</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">            outstandingMessageCount++;</span><br><span class="line">            <span class="comment">// 100条确认一次</span></span><br><span class="line">            <span class="keyword">if</span> (outstandingMessageCount == batchSize) &#123;</span><br><span class="line">                channel.waitForConfirms();</span><br><span class="line">                outstandingMessageCount = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 为了确保还有剩余没有确认消息 再次确认</span></span><br><span class="line">        <span class="keyword">if</span> (outstandingMessageCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            channel.waitForConfirms();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot; 发布&quot;</span> + MESSAGE_COUNT + <span class="string">&quot; 个批量确认消息, 耗时&quot;</span> + (end - begin) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="第三种：异步确认发布"><a href="#第三种：异步确认发布" class="headerlink" title="第三种：异步确认发布"></a>第三种：异步确认发布</h4><p>异步确认虽然编程逻辑比上两个要复杂，但是性价比最高，无论是可靠性还是效率都没得说， 他是利用回调函数来达到消息可靠性传递的，这个中间件也是通过函数回调来保证是否投递成功， 下面就让我们来详细讲解异步确认是怎么实现的。</p><p><img src="/images/studyNote/rabbitMQ/20210907_11902.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异步发布确认  发布1000个消息，耗时62ms</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">publishMessageAsync</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (Channel channel = RabbitMqUtils.getChannel()) &#123;</span><br><span class="line">        String queueName = UUID.randomUUID().toString();</span><br><span class="line">        channel.queueDeclare(queueName, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 开启发布确认</span></span><br><span class="line">        channel.confirmSelect();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">             *  线程安全有序的一个哈希表，适用于高并发的情况</span></span><br><span class="line"><span class="comment">             * 1. 轻松的将序号与消息进行关联</span></span><br><span class="line"><span class="comment">             * 2. 轻松批量删除条目 只要给到序列号</span></span><br><span class="line"><span class="comment">             * 3. 支持并发访问</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        ConcurrentSkipListMap&lt;Long,  String&gt; outstandingConfirms  =  <span class="keyword">new</span></span><br><span class="line">            ConcurrentSkipListMap&lt;&gt;();</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">             *  确认收到消息的一个回调</span></span><br><span class="line"><span class="comment">             * 1. 消息序列号</span></span><br><span class="line"><span class="comment">             * 2.true 可以确认小于等于当前序列号的消息</span></span><br><span class="line"><span class="comment">             * false 确认当前序列号消息</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        ConfirmCallback ackCallback = (sequenceNumber, multiple) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (multiple) &#123;</span><br><span class="line">                <span class="comment">// 返回的是小于等于当前序列号的未确认消息 是一个 map</span></span><br><span class="line">                ConcurrentNavigableMap&lt;Long,  String&gt; confirmed  =</span><br><span class="line">                    outstandingConfirms.headMap(sequenceNumber, <span class="keyword">true</span>);</span><br><span class="line">                <span class="comment">// 清除该部分未确认消息</span></span><br><span class="line">                confirmed.clear();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 只清除当前序列号的消息</span></span><br><span class="line">                outstandingConfirms.remove(sequenceNumber);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        ConfirmCallback nackCallback = (sequenceNumber, multiple) -&gt; &#123;</span><br><span class="line">            String message = outstandingConfirms.get(sequenceNumber);</span><br><span class="line">            System.out.println(<span class="string">&quot; 发布的消息&quot;</span>+message+<span class="string">&quot; 未被确认，序列号&quot;</span>+sequenceNumber);</span><br><span class="line">        &#125;;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">             *  添加一个异步确认的监听器</span></span><br><span class="line"><span class="comment">             * 1. 确认收到消息的回调</span></span><br><span class="line"><span class="comment">             * 2. 未收到消息的回调</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        channel.addConfirmListener(ackCallback, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MESSAGE_COUNT; i++) &#123;</span><br><span class="line">            String message = <span class="string">&quot; 消息&quot;</span> + i;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * channel.getNextPublishSeqNo() 获取下一个消息的序列号</span></span><br><span class="line"><span class="comment">                 *  通过序列号与消息体进行一个关联</span></span><br><span class="line"><span class="comment">                 *  全部都是未确认的消息体</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">            outstandingConfirms.put(channel.getNextPublishSeqNo(), message);</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot; 发布&quot;</span> + MESSAGE_COUNT + <span class="string">&quot; 个异步确认消息, 耗时&quot;</span> + (end - begin) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="如何处理异步未确认消息"><a href="#如何处理异步未确认消息" class="headerlink" title="如何处理异步未确认消息"></a>如何处理异步未确认消息</h4><p>好的解决的解决方案就是把未确认的消息放到一个基于内存的能被发布线程访问的队列， 比如说用 ConcurrentLinkedQueue 这个队列在 confirm callbacks 与发布线程之间进行消息的传 递。</p><h4 id="3种发布确认速度对比"><a href="#3种发布确认速度对比" class="headerlink" title="3种发布确认速度对比"></a>3种发布确认速度对比</h4><ul><li>单独发布消息：同步等待确认，简单，但吞吐量非常有限。</li><li>批量发布消息：批量同步等待确认，简单，合理的吞吐量，一旦出现问题但很难推断出是那条消息出现了问题。</li><li>异步处理：最佳性能和资源使用，在出现错误的情况下可以很好地控制，但是实现起来稍微难些。</li></ul><h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><p>在上一节中，我们创建了一个工作队列。我们假设的是工作队列背后，每个任务都恰好交付给一个消 费者(工作进程)。在这一部分中，我们将做一些完全不同的事情-我们将消息传达给多个消费者。这种模式 称为 ”发布/订阅”，为了说明这种模式，我们将构建一个简单的日志系统。它将由两个程序组成:第一个程序将发出日志消 息，第二个程序是消费者。其中我们会启动两个消费者，其中一个消费者接收到消息后把日志存储在磁盘，另外一个消费者接收到消息后把消息打印在屏幕上，事实上第一个程序发出的日志消息将广播给所有消费者。</p><h3 id="Exchanges概念"><a href="#Exchanges概念" class="headerlink" title="Exchanges概念"></a>Exchanges概念</h3><p>RabbitMQ 消息传递模型的核心思想是: <strong>生产者生产的消息从不会直接发送到队列</strong>。实际上，通常生产者甚至都不知道这些消息传递传递到了哪些队列中。相反，**生产者只能将消息发送到交换机(exchange)**，交换机工作的内容非常简单，一方面它接收来 自生产者的消息，另一方面将它们推入队列。交换机必须确切知道如何处理收到的消息。是应该把这些消 息放到特定队列还是说把他们到许多队列中还是说应该丢弃它们。这就的由交换机的类型来决定。</p><h3 id="Exchanges-的类型"><a href="#Exchanges-的类型" class="headerlink" title="Exchanges 的类型"></a>Exchanges 的类型</h3><ul><li>直接(direct) — 路由类型</li><li>主题(topic) — 通配符匹配模式</li><li>标题(headers) — 已经不用了</li><li>扇出(fanout) — 发布订阅类型</li></ul><h3 id="无名-exchange"><a href="#无名-exchange" class="headerlink" title="无名 exchange"></a>无名 exchange</h3><p>第一个参数是交换机的名称。空字符串表示默认或无名称交换机：消息能路由发送到队列中其实是由 routingKey(bindingkey)绑定 key 指定的。</p><p><img src="/images/studyNote/rabbitMQ/20210903_140200.png"></p><h3 id="临时队列"><a href="#临时队列" class="headerlink" title="临时队列"></a>临时队列</h3><p>每当我们连接到 Rabbit 时，我们都需要一个全新的空队列，为此我们可以创建一个具有<strong>随机名称的队列</strong>，或者能让服务器为我们选择一个随机队列名称那就更好了。其次<strong>一旦我们断开了消费者的连接，队列将被自动删除。</strong>创建临时队列的方式如下:<br><code>String queueName = channel.queueDeclare().getQueue();</code></p><h3 id="绑定-bindings"><a href="#绑定-bindings" class="headerlink" title="绑定(bindings)"></a>绑定(bindings)</h3><p>什么是 bingding 呢，binding 其实是 exchange 和 queue 之间的桥梁，它告诉我们 exchange 和那个队 列进行了绑定关系。比如说下面这张图告诉我们的就是 X 与 Q1 和 Q2 进行了绑定</p><p><img src="/images/studyNote/rabbitMQ/20210903_140800.png"></p><h3 id="Fanout-发布订阅交换机"><a href="#Fanout-发布订阅交换机" class="headerlink" title="Fanout(发布订阅交换机)"></a>Fanout(发布订阅交换机)</h3><p>Fanout 这种类型非常简单。正如从名称中猜到的那样，它是将接收到的所有消息<strong>广播</strong>到它知道的 所有队列中。系统中默认有些 exchange 类型</p><p><img src="/images/studyNote/rabbitMQ/20210903_141025.png"></p><h4 id="Fanout-实战"><a href="#Fanout-实战" class="headerlink" title="Fanout  实战"></a>Fanout  实战</h4><p><img src="/images/studyNote/rabbitMQ/20210910_230006.png"></p><p>Logs 和临时队列的绑定关系如下图</p><p><img src="/images/studyNote/rabbitMQ/20210910_230126.png"></p><h5 id="发布订阅发布者"><a href="#发布订阅发布者" class="headerlink" title="发布订阅发布者"></a>发布订阅发布者</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmitLog</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">&quot;logs&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (Channel channel = RabbitMqUtils.getChannel()) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             *  声明一个 exchange</span></span><br><span class="line"><span class="comment">             * 1.exchange 的名称</span></span><br><span class="line"><span class="comment">             * 2.exchange 的类型</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;fanout&quot;</span>);</span><br><span class="line">            Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">            System.out.println(<span class="string">&quot; 请输入信息&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (sc.hasNext()) &#123;</span><br><span class="line">                String message = sc.nextLine();</span><br><span class="line">                channel.basicPublish(EXCHANGE_NAME, <span class="string">&quot;&quot;</span>, <span class="keyword">null</span>, message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                System.out.println(<span class="string">&quot; 生产者发出消息&quot;</span> + message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="发布订阅接收者1"><a href="#发布订阅接收者1" class="headerlink" title="发布订阅接收者1"></a>发布订阅接收者1</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveLogs01</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">&quot;logs&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;fanout&quot;</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  生成一个临时的队列 队列的名称是随机的</span></span><br><span class="line"><span class="comment">         *  当消费者断开和该队列的连接时 队列自动删除</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        String queueName = channel.queueDeclare().getQueue();</span><br><span class="line">        <span class="comment">// 把该临时队列绑定我们的 exchange  其中 routingkey( 也称之为 binding key) 为空字符串</span></span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;01等待接收消息, 把接收到的消息打印在屏幕.....&quot;</span>);</span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            String message = <span class="keyword">new</span> String(delivery.getBody(), StandardCharsets.UTF_8);</span><br><span class="line">            System.out.println(<span class="string">&quot;01控制台打印接收到的消息&quot;</span> + message);</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="发布订阅接收者2"><a href="#发布订阅接收者2" class="headerlink" title="发布订阅接收者2"></a>发布订阅接收者2</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveLogs02</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">&quot;logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;fanout&quot;</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  生成一个临时的队列 队列的名称是随机的</span></span><br><span class="line"><span class="comment">         *  当消费者断开和该队列的连接时 队列自动删除</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        String queueName = channel.queueDeclare().getQueue();</span><br><span class="line">        <span class="comment">// 把该临时队列绑定我们的 exchange  其中 routingkey( 也称之为 binding key) 为空字符串</span></span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;02等待接收消息, 把接收到的消息打印在屏幕.....&quot;</span>);</span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            String message = <span class="keyword">new</span> String(delivery.getBody(), StandardCharsets.UTF_8);</span><br><span class="line">            System.out.println(<span class="string">&quot;02控制台打印接收到的消息&quot;</span> + message);</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Direct-exchange-直接交换机"><a href="#Direct-exchange-直接交换机" class="headerlink" title="Direct exchange(直接交换机)"></a>Direct exchange(直接交换机)</h3><p>上一节中，我们构建了一个简单的日志记录系统。我们能够向许多接收者广播日志消息。在本节我们将向其中添加一些特别的功能-比方说我们只让某个消费者订阅发布的部分消息。例如我们只把严重错误消息定向存储到日志文件(以节省磁盘空间)，同时仍然能够在控制台上打印所有日志消息。我们再次来回顾一下什么是 bindings，绑定是交换机和队列之间的桥梁关系。也可以这么理解：队列只对它绑定的交换机的消息感兴趣。绑定用参数：routingKey 来表示也可称该参数为 binding key，创建绑定我们用代码:<code>channel.queueBind(queueName, EXCHANGE_NAME, &quot;routingKey&quot;);</code><strong>绑定之后的意义由其交换类型决定。</strong></p><p><img src="/images/studyNote/rabbitMQ/20210910_232643.png"></p><p><img src="/images/studyNote/rabbitMQ/20210910_232754.png"></p><h4 id="直接交换机发布者"><a href="#直接交换机发布者" class="headerlink" title="直接交换机发布者"></a>直接交换机发布者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmitLogDirect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">&quot;direct_logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (Channel channel = RabbitMqUtils.getChannel()) &#123;</span><br><span class="line">            channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class="line">            <span class="comment">// 创建多个 bindingKey</span></span><br><span class="line">            Map&lt;String, String&gt; bindingKeyMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            bindingKeyMap.put(<span class="string">&quot;info&quot;</span>, <span class="string">&quot; 普通 info  信息&quot;</span>);</span><br><span class="line">            bindingKeyMap.put(<span class="string">&quot;warning&quot;</span>, <span class="string">&quot; 警告 warning  信息&quot;</span>);</span><br><span class="line">            bindingKeyMap.put(<span class="string">&quot;error&quot;</span>, <span class="string">&quot; 错误 error  信息&quot;</span>);</span><br><span class="line">            <span class="comment">//debug 没有消费这接收这个消息 所有就丢失了</span></span><br><span class="line">            bindingKeyMap.put(<span class="string">&quot;debug&quot;</span>, <span class="string">&quot; 调试 debug  信息&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; bindingKeyEntry : bindingKeyMap.entrySet()) &#123;</span><br><span class="line">                String bindingKey = bindingKeyEntry.getKey();</span><br><span class="line">                String message = bindingKeyEntry.getValue();</span><br><span class="line">                channel.basicPublish(EXCHANGE_NAME, bindingKey, <span class="keyword">null</span>, message.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">                System.out.println(<span class="string">&quot; 生产者发出消息:&quot;</span> + message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="直接交换机消费者1"><a href="#直接交换机消费者1" class="headerlink" title="直接交换机消费者1"></a>直接交换机消费者1</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveLogsDirect01</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">&quot;direct_logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class="line">        String queueName = <span class="string">&quot;disk&quot;</span>;</span><br><span class="line">        channel.queueDeclare(queueName, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;error&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot; 等待接收消息.....&quot;</span>);</span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            String message = <span class="keyword">new</span> String(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            message = <span class="string">&quot; 接收绑定键:&quot;</span> + delivery.getEnvelope().getRoutingKey() + <span class="string">&quot;, 消息:&quot;</span> + message;</span><br><span class="line">            <span class="comment">// 写磁盘忽略</span></span><br><span class="line">            System.out.println(<span class="string">&quot; 错误日志已经接收&quot;</span> + message);</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="直接交换机消费者2"><a href="#直接交换机消费者2" class="headerlink" title="直接交换机消费者2"></a>直接交换机消费者2</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveLogsDirect02</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">&quot;direct_logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class="line">        String queueName = <span class="string">&quot;console&quot;</span>;</span><br><span class="line">        channel.queueDeclare(queueName, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;info&quot;</span>);</span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;warning&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot; 等待接收消息.....&quot;</span>);</span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            String message = <span class="keyword">new</span> String(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;  接 收 绑 定 键 :&quot;</span> + delivery.getEnvelope().getRoutingKey() + <span class="string">&quot;, 消息:&quot;</span> + message);</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Topics-主题交换机"><a href="#Topics-主题交换机" class="headerlink" title="Topics(主题交换机)"></a>Topics(主题交换机)</h3><p>在上一个小节中，我们改进了日志记录系统。我们没有使用只能进行随意广播的 fanout 交换机，而是使用了 direct 交换机，从而有能实现有选择性地接收日志。尽管使用 direct 交换机改进了我们的系统，但是它仍然存在局限性-比方说我们想接收的日志类型有info.base 和 info.advantage，某个队列只想 info.base 的消息，那这个时候 direct 就办不到了。这个时候就只能使用 topic 类型。</p><h4 id="Topic-要求"><a href="#Topic-要求" class="headerlink" title="Topic 要求"></a>Topic 要求</h4><p>发送到类型是 topic 交换机的消息的 routing_key 不能随意写，必须满足一定的要求，它必须是一个单词列表，以点号分隔开。这些单词可以是任意单词，比如说：”stock.usd.nyse”, “nyse.vmw”,”quick.orange.rabbit”.这种类型的。当然这个单词列表最多不能超过 255 个字节。在这个规则列表中，其中有两个替换符是大家需要注意的</p><ul><li>*(星号)可以代替一个单词</li><li>#(井号)可以替代零个或多个单词</li></ul><h4 id="Topic-匹配案例"><a href="#Topic-匹配案例" class="headerlink" title="Topic  匹配案例"></a>Topic  匹配案例</h4><p>下图绑定关系如下：<br>    Q1–&gt;绑定的是：中间带 orange 带 3 个单词的字符串(<em>.orange.</em>)<br>    Q2–&gt;绑定的是：最后一个单词是 rabbit 的 3 个单词(<em>.</em>.rabbit) 第一个单词是 lazy 的多个单词(lazy.#)</p><p><img src="/images/studyNote/rabbitMQ/20210910_235635.png"></p><p>上图是一个队列绑定关系图，我们来看看他们之间数据接收情况是怎么样的<br>quick.orange.rabbit      ————        被队列 Q1Q2 接收到<br>lazy.orange.elephant   ————           被队列 Q1Q2 接收到<br>quick.orange.fox          ————         被队列 Q1 接收到<br>lazy.brown.fox          ————          被队列 Q2 接收到<br>lazy.pink.rabbit            ————          虽然满足两个绑定但只被队列 Q2 接收一次<br>quick.brown.fox          ————          不匹配任何绑定不会被任何队列接收到会被丢弃<br>quick.orange.male.rabbit ————   是四个单词不匹配任何绑定会被丢弃<br>lazy.orange.male.rabbit  ————    是四个单词但匹配 Q2</p><p>当队列绑定关系是下列这种情况时需要引起注意  <strong>当一个队列绑定键是#,那么这个队列将接收所有数据</strong>，就有点像 fanout 了，如果队列绑定键当中没有#和*出现，那么该队列绑定类型就是 direct 了。</p><h2 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h2><h3 id="死信的概念"><a href="#死信的概念" class="headerlink" title="死信的概念"></a>死信的概念</h3><p>先从概念解释上搞清楚这个定义，死信，顾名思义就是无法被消费的消息，字面意思可以这样理 解，一般来说，producer 将消息投递到 broker 或者直接到 queue 里了，consumer 从 queue 取出消息 进行消费，但某些时候由于特定的原因导致 queue 中的某些消息无法被消费，这样的消息如果没有 后续的处理，就变成了死信，有死信自然就有了死信队列。</p><p>应用场景:为了保证订单业务的消息数据不丢失，需要使用到 RabbitMQ 的死信队列机制，当消息 消费发生异常时，将消息投入死信队列中.还有比如说: 用户在商城下单成功并点击去支付后在指定时 间未支付时自动失效</p><h4 id="死信的来源"><a href="#死信的来源" class="headerlink" title="死信的来源"></a>死信的来源</h4><ol><li>消息 TTL 过期</li><li>队列达到最大长度(队列满了，无法再添加数据到 mq 中)</li><li>消息被拒绝(basic.reject 或 basic.nack)并且 requeue=false.</li></ol><h4 id="代码架构图"><a href="#代码架构图" class="headerlink" title="代码架构图"></a>代码架构图</h4><p><img src="/images/studyNote/rabbitMQ/20210911_01243.png"></p><h4 id="消息TTL过期代码"><a href="#消息TTL过期代码" class="headerlink" title="消息TTL过期代码"></a>消息TTL过期代码</h4><h5 id="死信生产者"><a href="#死信生产者" class="headerlink" title="死信生产者"></a>死信生产者</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String NORMAL_EXCHANGE = <span class="string">&quot;normal_exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (Channel channel = RabbitMqUtils.getChannel()) &#123;</span><br><span class="line">            channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line">            <span class="comment">// 设置消息的 TTL 时间</span></span><br><span class="line">            AMQP.BasicProperties properties = <span class="keyword">new</span></span><br><span class="line">                    AMQP.BasicProperties().builder().expiration(<span class="string">&quot;10000&quot;</span>).build();</span><br><span class="line">            <span class="comment">// 该信息是用作演示队列个数限制</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">                String message = <span class="string">&quot;info&quot;</span> + i;</span><br><span class="line">                channel.basicPublish(NORMAL_EXCHANGE, <span class="string">&quot;zhangsan&quot;</span>, properties, message.getBytes());</span><br><span class="line">                System.out.println(<span class="string">&quot; 生产者发送消息:&quot;</span> + message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="死信消费者C1"><a href="#死信消费者C1" class="headerlink" title="死信消费者C1"></a>死信消费者C1</h5><p>消费者 C1 ( 启动之后关闭该消费者 模拟其接收不到消息)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer01</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 普通交换机名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String NORMAL_EXCHANGE = <span class="string">&quot;normal_exchange&quot;</span>;</span><br><span class="line">    <span class="comment">// 死信交换机名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEAD_EXCHANGE = <span class="string">&quot;dead_exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line">        <span class="comment">// 声明死信和普通交换机 类型为 direct</span></span><br><span class="line">        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line">        channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line">        <span class="comment">// 声明死信队列</span></span><br><span class="line">        String deadQueue = <span class="string">&quot;dead-queue&quot;</span>;</span><br><span class="line">        channel.queueDeclare(deadQueue, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 死信队列绑定死信交换机与 routingkey</span></span><br><span class="line">        channel.queueBind(deadQueue, DEAD_EXCHANGE, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        <span class="comment">// 正常队列绑定死信队列信息</span></span><br><span class="line">        Map&lt;String, Object&gt; params = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// 正常队列设置死信交换机 参数 key 是固定值</span></span><br><span class="line">        params.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, DEAD_EXCHANGE);</span><br><span class="line">        <span class="comment">// 正常队列设置死信 routing-key  参数 key 是固定值</span></span><br><span class="line">        params.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        String normalQueue = <span class="string">&quot;normal-queue&quot;</span>;</span><br><span class="line">        channel.queueDeclare(normalQueue, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, params);</span><br><span class="line">        channel.queueBind(normalQueue, NORMAL_EXCHANGE, <span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot; 等待接收消息.....&quot;</span>);</span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            String message = <span class="keyword">new</span> String(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Consumer01  接收到消息&quot;</span> + message);</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(normalQueue, <span class="keyword">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="死信队列消费者"><a href="#死信队列消费者" class="headerlink" title="死信队列消费者"></a>死信队列消费者</h5><p>消费者 C2  ( 以上步骤完成后 启动 C2  消费者它消费死信队列里面的消息)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer02</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEAD_EXCHANGE = <span class="string">&quot;dead_exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line">        channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line">        String deadQueue = <span class="string">&quot;dead-queue&quot;</span>;</span><br><span class="line">        channel.queueDeclare(deadQueue, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        channel.queueBind(deadQueue, DEAD_EXCHANGE, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot; 等待接收死信队列消息.....&quot;</span>);</span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            String message = <span class="keyword">new</span> String(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Consumer02  接收死信队列的消息&quot;</span> + message);</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(deadQueue, <span class="keyword">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/studyNote/rabbitMQ/20210911_02525.png"></p><h3 id="队列达到最大长度"><a href="#队列达到最大长度" class="headerlink" title="队列达到最大长度"></a>队列达到最大长度</h3><h4 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h4><p>消息生产者代码去掉 TTL 属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TooLongProducer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String NORMAL_EXCHANGE = <span class="string">&quot;normal_exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (Channel channel = RabbitMqUtils.getChannel()) &#123;</span><br><span class="line">            channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line">            <span class="comment">// 该信息是用作演示队列个数限制</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">                String message = <span class="string">&quot;info&quot;</span> + i;</span><br><span class="line">                channel.basicPublish(NORMAL_EXCHANGE, <span class="string">&quot;zhangsan&quot;</span>, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">                System.out.println(<span class="string">&quot; 生产者发送消息:&quot;</span> + message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="消费者-1"><a href="#消费者-1" class="headerlink" title="消费者"></a>消费者</h4><p>C1 消费者修改以下代码 ( 启动之后关闭该消费者 模拟其接收不到消息)</p><p><img src="/images/studyNote/rabbitMQ/20210911_03017.png"></p><p><font color=red >注意此时需要把原先队列删除 因为参数改变了</font>  ,C2 消费者代码不变( 启动 C2 消费者)</p><p><img src="/images/studyNote/rabbitMQ/20210911_03245.png"></p><h3 id="消息被拒进入死信"><a href="#消息被拒进入死信" class="headerlink" title="消息被拒进入死信"></a>消息被拒进入死信</h3><p>代码略</p><h2 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h2><p>延时队列,队列内部是有序的，最重要的特性就体现在它的延时属性上，延时队列中的元素是希望在指定时间到了以后或之前取出和处理，简单来说，延时队列就是用来存放需要在指定时间被处理的元素的队列。</p><h3 id="延迟队列使用场景"><a href="#延迟队列使用场景" class="headerlink" title="延迟队列使用场景"></a>延迟队列使用场景</h3><ol><li>订单在十分钟之内未支付则自动取消</li><li>新创建的店铺，如果在十天内都没有上传过商品，则自动发送消息提醒。</li><li>用户注册成功后，如果三天内没有登陆则进行短信提醒。</li><li>用户发起退款，如果三天内没有得到处理则通知相关运营人员。</li><li>预定会议后，需要在预定的时间点前十分钟通知各个与会人员参加会议</li></ol><h3 id="RabbitMQ-中的-TTL"><a href="#RabbitMQ-中的-TTL" class="headerlink" title="RabbitMQ  中的 TTL"></a>RabbitMQ  中的 TTL</h3><p>TTL 是什么呢？TTL 是 RabbitMQ 中一个消息或者队列的属性，表明一条消息或者该队列中的所有消息的最大存活时间，单位是毫秒。换句话说，如果一条消息设置了 TTL 属性或者进入了设置 TTL 属性的队列，那么这条消息如果在 TTL 设置的时间内没有被消费，则会成为”死信”。如果同时配置了队列的 TTL 和消息的TTL，那么较小的那个值将会被使用，有两种方式设置 TTL。</p><h4 id="消息设置-TTL"><a href="#消息设置-TTL" class="headerlink" title="消息设置 TTL"></a>消息设置 TTL</h4><p>另一种方式便是针对每条消息设置 TTL</p><p><img src="/images/studyNote/rabbitMQ/20210911_03858.png"></p><h4 id="队列设置-TTL"><a href="#队列设置-TTL" class="headerlink" title="队列设置 TTL"></a>队列设置 TTL</h4><p>第一种是在创建队列的时候设置队列的“x-message-ttl”属性</p><p><img src="/images/studyNote/rabbitMQ/20210911_04019.png"></p><h4 id="两者的区别"><a href="#两者的区别" class="headerlink" title="两者的区别"></a>两者的区别</h4><p>如果设置了队列的 TTL 属性，那么一旦消息过期，就会被队列丢弃(如果配置了死信队列被丢到死信队列中)，而第二种方式，消息即使过期，也不一定会被马上丢弃，因为消息是否过期是在即将投递到消费者之前判定的，如果当前队列有严重的消息积压情况，则已过期的消息也许还能存活较长时间；另外，还需要注意的一点是，如果不设置 TTL，表示消息永远不会过期，如果将 TTL 设置为 0，则表示除非此时可以直接投递该消息到消费者，否则该消息将会被丢弃。</p><p>前一小节我们介绍了死信队列，刚刚又介绍了 TTL，至此利用 RabbitMQ 实现延时队列的两大要素已经集齐，接下来只需要将它们进行融合，再加入一点点调味料，延时队列就可以新鲜出炉了。想想看，延时队列，不就是想要消息延迟多久被处理吗，<strong>TTL 则刚好能让消息在延迟多久之后成为死信</strong>，另一方面，成为死信的消息都会被投递到死信队列里，这样只需要消费者一直消费死信队列里的消息就完事了，因为里面的消息都是希望被立即处理的消息。</p><h2 id="整合SpringBoot"><a href="#整合SpringBoot" class="headerlink" title="整合SpringBoot"></a>整合SpringBoot</h2><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--RabbitMQ 依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--swagger--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--RabbitMQ 测试依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.amqp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-rabbit-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.rabbitmq.host</span>=<span class="string">127.0.0.1</span></span><br><span class="line"><span class="meta">spring.rabbitmq.port</span>=<span class="string">5672</span></span><br><span class="line"><span class="meta">spring.rabbitmq.username</span>=<span class="string">admin</span></span><br><span class="line"><span class="meta">spring.rabbitmq.password</span>=<span class="string">123</span></span><br></pre></td></tr></table></figure><h3 id="死信队列实现延迟MQ"><a href="#死信队列实现延迟MQ" class="headerlink" title="死信队列实现延迟MQ"></a>死信队列实现延迟MQ</h3><p>创建两个队列 QA 和 QB，两者队列 TTL 分别设置为 10S 和 40S，然后在创建一个交换机 X 和死信交换机 Y，它们的类型都是 direct，创建一个死信队列 QD，它们的绑定关系如下：</p><p><img src="/images/studyNote/rabbitMQ/20210911_04954.png"></p><h4 id="配置文件类代码"><a href="#配置文件类代码" class="headerlink" title="配置文件类代码"></a>配置文件类代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TtlQueueConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String X_EXCHANGE = <span class="string">&quot;X&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_A = <span class="string">&quot;QA&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_B = <span class="string">&quot;QB&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String Y_DEAD_LETTER_EXCHANGE = <span class="string">&quot;Y&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEAD_LETTER_QUEUE = <span class="string">&quot;QD&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  声明 xExchange</span></span><br><span class="line">    <span class="meta">@Bean(&quot;xExchange&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DirectExchange <span class="title">xExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(X_EXCHANGE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  声明 xExchange</span></span><br><span class="line">    <span class="meta">@Bean(&quot;yExchange&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DirectExchange <span class="title">yExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(Y_DEAD_LETTER_EXCHANGE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明队列 A ttl 为 10s 并绑定到对应的死信交换机</span></span><br><span class="line">    <span class="meta">@Bean(&quot;queueA&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queueA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; args = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 声明当前队列绑定的死信交换机</span></span><br><span class="line">        args.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, Y_DEAD_LETTER_EXCHANGE);</span><br><span class="line">        <span class="comment">// 声明当前队列的死信路由 key</span></span><br><span class="line">        args.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;YD&quot;</span>);</span><br><span class="line">        <span class="comment">// 声明队列的 TTL</span></span><br><span class="line">        args.put(<span class="string">&quot;x-message-ttl&quot;</span>, <span class="number">10000</span>);</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(QUEUE_A).withArguments(args).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  声明队列 A 绑定 X 交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">queueaBindingX</span><span class="params">(<span class="meta">@Qualifier(&quot;queueA&quot;)</span> Queue queueA,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="meta">@Qualifier(&quot;xExchange&quot;)</span> DirectExchange xExchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueA).to(xExchange).with(<span class="string">&quot;XA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明队列 B ttl 为 40s 并绑定到对应的死信交换机</span></span><br><span class="line">    <span class="meta">@Bean(&quot;queueB&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queueB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; args = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 声明当前队列绑定的死信交换机</span></span><br><span class="line">        args.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, Y_DEAD_LETTER_EXCHANGE);</span><br><span class="line">        <span class="comment">// 声明当前队列的死信路由 key</span></span><br><span class="line">        args.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;YD&quot;</span>);</span><br><span class="line">        <span class="comment">// 声明队列的 TTL</span></span><br><span class="line">        args.put(<span class="string">&quot;x-message-ttl&quot;</span>, <span class="number">40000</span>);</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(QUEUE_B).withArguments(args).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明队列 B 绑定 X 交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">queuebBindingX</span><span class="params">(<span class="meta">@Qualifier(&quot;queueB&quot;)</span> Queue queue1B,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="meta">@Qualifier(&quot;xExchange&quot;)</span> DirectExchange xExchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue1B).to(xExchange).with(<span class="string">&quot;XB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明死信队列 QD</span></span><br><span class="line">    <span class="meta">@Bean(&quot;queueD&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queueD</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(DEAD_LETTER_QUEUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明死信队列 QD 绑定关系</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">deadLetterBindingQAD</span><span class="params">(<span class="meta">@Qualifier(&quot;queueD&quot;)</span> Queue queueD,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="meta">@Qualifier(&quot;yExchange&quot;)</span> DirectExchange yExchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueD).to(yExchange).with(<span class="string">&quot;YD&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="生产者代码"><a href="#生产者代码" class="headerlink" title="生产者代码"></a>生产者代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;ttl&quot;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendMsgController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;sendMsg/&#123;message&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">(<span class="meta">@PathVariable</span> String message)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot; 当前时间：&#123;&#125;, 发送一条信息给两个 TTL  队列:&#123;&#125;&quot;</span>, <span class="keyword">new</span> Date(), message);</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;X&quot;</span>, <span class="string">&quot;XA&quot;</span>, <span class="string">&quot; 消息来自 ttl 为 为 10S  的队列: &quot;</span> + message);</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;X&quot;</span>, <span class="string">&quot;XB&quot;</span>, <span class="string">&quot; 消息来自 ttl 为 为 40S  的队列: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="消费者代码"><a href="#消费者代码" class="headerlink" title="消费者代码"></a>消费者代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLetterQueueConsumer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;QD&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveD</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String msg = <span class="keyword">new</span> String(message.getBody());</span><br><span class="line">        log.info(<span class="string">&quot; 当前时间：&#123;&#125;, 收到死信队列信息&#123;&#125;&quot;</span>, <span class="keyword">new</span> Date().toString(), msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一条消息在 10S 后变成了死信消息，然后被消费者消费掉，第二条消息在 40S 之后变成了死信消息，然后被消费掉，这样一个延时队列就打造完成了。<br>不过，如果这样使用的话，岂不是<strong>每增加一个新的时间需求，就要新增一个队列</strong>，这里只有 10S 和 40S两个时间选项，如果需要一个小时后处理，那么就需要增加 TTL 为一个小时的队列，如果是预定会议室然后提前通知这样的场景，岂不是要增加无数个队列才能满足需求？</p><h4 id="延时队列优化"><a href="#延时队列优化" class="headerlink" title="延时队列优化"></a>延时队列优化</h4><p>在这里新增了一个队列 QC,绑定关系如下,该队列不设置 TTL 时间</p><p><img src="/images/studyNote/rabbitMQ/20210911_10712.png"></p><p>看起来似乎没什么问题，但是在最开始的时候，就介绍过如果使用在消息属性上设置 TTL 的方式，消息可能并不会按时“死亡“，<strong>因为 RabbitMQ 只会检查第一个消息是否过期</strong>，如果过期则丢到死信队列，<font color=red >如果第一个消息的延时时长很长，而第二个消息的延时时长很短，第二个消息并不会优先得到执行。</font> </p><h3 id="Rabbitmq插件实现延迟队列"><a href="#Rabbitmq插件实现延迟队列" class="headerlink" title="Rabbitmq插件实现延迟队列"></a>Rabbitmq插件实现延迟队列</h3><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><ol><li><a href="https://www.jianshu.com/p/451958b1adca">SpringBoot+RabbitMQ用死信队列和插件形式实现延迟队列</a> </li><li><a href="https://www.cnblogs.com/geekdc/p/13549613.html">Docker安装Rabbitmq及其延时队列插件</a> </li></ol><h4 id="安装延时队列插件"><a href="#安装延时队列插件" class="headerlink" title="安装延时队列插件"></a>安装延时队列插件</h4><p><a href="https://www.rabbitmq.com/community-plugins.html">在官网</a> ，下载<a href="https://github.com/rabbitmq/rabbitmq-delayed-message-exchange/releases/tag/v3.8.0">rabbitmq_delayed_message_exchange</a>插件，然后解压放置到 RabbitMQ 的插件目录。进入 RabbitMQ 的安装目录下的 plgins 目录，执行下面命令让该插件生效，然后重启 RabbitMQ</p><ul><li>/usr/lib/rabbitmq/lib/rabbitmq_server-3.8.8/plugins</li><li>rabbitmq-plugins enable rabbitmq_delayed_message_exchange</li></ul><p><img src="/images/studyNote/rabbitMQ/20210911_11230.png"></p><h2 id="发布确认高级姿势"><a href="#发布确认高级姿势" class="headerlink" title="发布确认高级姿势"></a>发布确认高级姿势</h2><p>在生产环境中由于一些不明原因，导致 rabbitmq 重启，在 RabbitMQ 重启期间生产者消息投递失败，导致消息丢失，需要手动处理和恢复。于是，我们开始思考，如何才能进行 RabbitMQ 的消息可靠投递呢？特别是在这样比较极端的情况，RabbitMQ 集群不可用的时候，无法投递的消息该如何处理呢:</p><h3 id="发布确认-springboot-版本"><a href="#发布确认-springboot-版本" class="headerlink" title="发布确认 springboot 版本"></a>发布确认 springboot 版本</h3><h4 id="确认机制方案"><a href="#确认机制方案" class="headerlink" title="确认机制方案"></a>确认机制方案</h4><p><img src="/images/studyNote/rabbitMQ/20210911_11918.png"></p><h4 id="代码架构图-1"><a href="#代码架构图-1" class="headerlink" title="代码架构图"></a>代码架构图</h4><p><img src="/images/studyNote/rabbitMQ/20210911_11958.png"></p><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在配置文件当中需要添加</span></span><br><span class="line"><span class="meta">spring.rabbitmq.publisher-confirm-type</span>=<span class="string">correlated</span></span><br></pre></td></tr></table></figure><ul><li>NONE：禁用发布确认模式，是默认值</li><li>CORRELATED：发布消息成功到交换器后会触发回调方法</li><li>SIMPLE：经测试有两种效果，其一效果和 CORRELATED 值一样会触发回调方法，其二在发布消息成功后使用 rabbitTemplate 调用 waitForConfirms 或 waitForConfirmsOrDie 方法等待 broker 节点返回发送结果，根据返回结果来判定下一步的逻辑，要注意的点是 waitForConfirmsOrDie 方法如果返回 false 则会关闭 channel，则接下来无法发送消息到 broker，注：此配置同步确认消息，生产不建议使用</li></ul><h4 id="交换机发布确认代码"><a href="#交换机发布确认代码" class="headerlink" title="交换机发布确认代码"></a>交换机发布确认代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageConfirmCallBack</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">RabbitTemplate</span>.<span class="title">ConfirmCallback</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        rabbitTemplate.setConfirmCallback(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换机确认回调方法 (发布者发送消息是否到交换机触发回调)</span></span><br><span class="line"><span class="comment">     * 1. 发消息 交换机接收到消息，回调</span></span><br><span class="line"><span class="comment">     * 1.1 correlationData 保存毁掉消息的id及相关信息</span></span><br><span class="line"><span class="comment">     * 1.2 交换机接收到消息 true</span></span><br><span class="line"><span class="comment">     * 1.3 失败原因-null</span></span><br><span class="line"><span class="comment">     * 2. 发消息 交换机接收失败 回调</span></span><br><span class="line"><span class="comment">     * 2.1 correlationData 保存毁掉消息的id及相关信息</span></span><br><span class="line"><span class="comment">     * 2.2 false</span></span><br><span class="line"><span class="comment">     * 2.3 失败原因</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirm</span><span class="params">(CorrelationData correlationData, <span class="keyword">boolean</span> ack, String cause)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (ack) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;发布确认:交换机收到消息id：&#123;&#125;&quot;</span>, correlationData.getId());</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;发布确认:交换机未收到消息，id为：&#123;&#125;,原因：&#123;&#125;&quot;</span>, correlationData.getId(), cause);</span><br><span class="line">              <span class="comment">// TODO 保存数据库重新发送等逻辑保证消息重新发送给交换机</span></span><br><span class="line">          &#125; </span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="回退消息"><a href="#回退消息" class="headerlink" title="回退消息"></a>回退消息</h3><p><strong>在仅开启了生产者确认机制的情况下，交换机接收到消息后，会直接给消息生产者发送确认消息，如果发现该消息不可路由，那么消息会被直接丢弃，此时生产者是不知道消息被丢弃这个事件的。</strong>那么如何让无法被路由的消息帮我想办法处理一下？最起码通知我一声，我好自己处理啊。通过设置 mandatory 参数可以在当消息传递过程中不可达目的地时将消息<strong>返回给生产者。</strong></p><h4 id="添加配置"><a href="#添加配置" class="headerlink" title="添加配置"></a>添加配置</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 消息回退配置，如果消息无法路由，则回退给生产者</span></span><br><span class="line"><span class="meta">spring.rabbitmq.publisher-returns</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure><h4 id="回退代码演示"><a href="#回退代码演示" class="headerlink" title="回退代码演示"></a>回退代码演示</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageReturnCallBack</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">RabbitTemplate</span>.<span class="title">ReturnCallback</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        rabbitTemplate.setReturnCallback(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可以将消息传递过程中不可达到目的地(队列)的消息返回给生产者</span></span><br><span class="line"><span class="comment">     * 只有不可达 才会回退消息</span></span><br><span class="line"><span class="comment">     * 请注意!!!如果你使用了延迟队列插件，那么一定会调用该callback方法，因为数据并没有提交上去，</span></span><br><span class="line"><span class="comment">     * 而是提交在交换器中，过期时间到了才提交上去，并非是bug！你可以用if进行判断交换机名称来捕捉该报错</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnedMessage</span><span class="params">(Message message, <span class="keyword">int</span> replyCode, String replyText, String exchange, String routingKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(exchange.equals(delayedQueueProperties.getDelayedExchangeName()))&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;消息&#123;&#125;，被交换机&#123;&#125;退回，退回原因：&#123;&#125;，路由Key：&#123;&#125;&quot;</span>, <span class="keyword">new</span> String(message.getBody()), exchange, replyText, routingKey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="备份交换机"><a href="#备份交换机" class="headerlink" title="备份交换机"></a>备份交换机</h3><p>有了 mandatory 参数和回退消息，我们获得了对无法投递消息的感知能力，有机会在生产者的消息无法被投递时发现并处理。但有时候，我们并不知道该如何处理这些无法路由的消息，最多打个日志，然后触发报警，再来手动处理。而通过日志来处理这些无法路由的消息是很不优雅的做法，特别是当生产者所在的服务有多台机器的时候，手动复制日志会更加麻烦而且容易出错。而且设置 mandatory 参数会增加生产者的复杂性，需要添加处理这些被退回的消息的逻辑。如果既不想丢失消息，又不想增加生产者的复杂性，该怎么做呢？前面在设置死信队列的文章中，我们提到，可以为队列设置死信交换机来存储那些处理失败的消息，可是这些不可路由消息根本没有机会进入到队列，因此无法使用死信队列来保存消息。在 RabbitMQ 中，有一种备份交换机的机制存在，可以很好的应对这个问题。什么是备份交换机呢？备份交换机可以理解为 RabbitMQ 中交换机的“备胎”，当我们为某一个交换机声明一个对应的备份交换机时，就是为它创建一个备胎，当交换机接收到一条不可路由消息时，将会把这条消息转发到备份交换机中，由备份交换机来进行转发和处理，通常备份交换机的类型为 Fanout ，这样就能把所有消息都投递到与其绑定的队列中，然后我们在备份交换机下绑定一个队列，这样所有那些原交换机无法被路由的消息，就会都进入这个队列了。当然，我们还可以建立一个报警队列，用独立的消费者来进行监测和报警。</p><p><img src="/images/studyNote/rabbitMQ/20210912_01328.png"></p><h4 id="备份交换机代码声明"><a href="#备份交换机代码声明" class="headerlink" title="备份交换机代码声明"></a>备份交换机代码声明</h4><p>在原来的代码上面多声明一个交换机和两个队列，还有一个报警消费者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfirmConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONFIRM_EXCHANGE_NAME = <span class="string">&quot;confirm.exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONFIRM_QUEUE_NAME = <span class="string">&quot;confirm.queue&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BACKUP_EXCHANGE_NAME = <span class="string">&quot;backup.exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BACKUP_QUEUE_NAME = <span class="string">&quot;backup.queue&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String WARNING_QUEUE_NAME = <span class="string">&quot;warning.queue&quot;</span>;</span><br><span class="line">    <span class="comment">//  声明确认队列</span></span><br><span class="line">    <span class="meta">@Bean(&quot;confirmQueue&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">confirmQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(CONFIRM_QUEUE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 声明确认队列绑定关系</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">queueBinding</span><span class="params">(<span class="meta">@Qualifier(&quot;confirmQueue&quot;)</span> Queue queue,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="meta">@Qualifier(&quot;confirmExchange&quot;)</span> DirectExchange exchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="string">&quot;key1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 声明备份 Exchange</span></span><br><span class="line">    <span class="meta">@Bean(&quot;backupExchange&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FanoutExchange <span class="title">backupExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FanoutExchange(BACKUP_EXCHANGE_NAME);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 声明确认 Exchange 交换机的备份交换机</span></span><br><span class="line">    <span class="meta">@Bean(&quot;confirmExchange&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DirectExchange <span class="title">confirmExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ExchangeBuilder exchangeBuilder =</span><br><span class="line">                ExchangeBuilder.directExchange(CONFIRM_EXCHANGE_NAME)</span><br><span class="line">                        .durable(<span class="keyword">true</span>)</span><br><span class="line">                        <span class="comment">// 设置该交换机的备份交换机</span></span><br><span class="line">                        .withArgument(<span class="string">&quot;alternate-exchange&quot;</span>, BACKUP_EXCHANGE_NAME);</span><br><span class="line">        <span class="keyword">return</span> (DirectExchange) exchangeBuilder.build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  声明警告队列</span></span><br><span class="line">    <span class="meta">@Bean(&quot;warningQueue&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">warningQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(WARNING_QUEUE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  声明报警队列绑定关系</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">warningBinding</span><span class="params">(<span class="meta">@Qualifier(&quot;warningQueue&quot;)</span> Queue queue,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="meta">@Qualifier(&quot;backupExchange&quot;)</span> FanoutExchange</span></span></span><br><span class="line"><span class="params"><span class="function">                                          backupExchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(backupExchange);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  声明备份队列</span></span><br><span class="line">    <span class="meta">@Bean(&quot;backQueue&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">backQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(BACKUP_QUEUE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  声明备份队列绑定关系</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">backupBinding</span><span class="params">(<span class="meta">@Qualifier(&quot;backQueue&quot;)</span> Queue queue,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="meta">@Qualifier(&quot;backupExchange&quot;)</span> FanoutExchange backupExchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(backupExchange);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="报警消费者"><a href="#报警消费者" class="headerlink" title="报警消费者"></a>报警消费者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WarningConsumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String WARNING_QUEUE_NAME = <span class="string">&quot;warning.queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = WARNING_QUEUE_NAME)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveWarningMsg</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        String msg = <span class="keyword">new</span> String(message.getBody());</span><br><span class="line">        log.error(<span class="string">&quot; 报警发现不可路由消息：&#123;&#125;&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试注意事项</strong></p><p>重新启动项目的时候需要把原来的 confirm.exchange 删除因为我们修改了其绑定属性，不然报错。</p><h4 id="备份交换机和回退优先级"><a href="#备份交换机和回退优先级" class="headerlink" title="备份交换机和回退优先级"></a>备份交换机和回退优先级</h4><p>mandatory 参数与备份交换机可以一起使用的时候，如果两者同时开启，消息究竟何去何从？谁优先级高，经过上面结果显示答案是备份交换机优先级高。</p><h2 id="RabbitMQ其他知识点"><a href="#RabbitMQ其他知识点" class="headerlink" title="RabbitMQ其他知识点"></a>RabbitMQ其他知识点</h2><h3 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a>幂等性</h3><p>用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用。举个最简单的例子，那就是支付，用户购买商品后支付，支付扣款成功，但是返回结果的时候网络异常，此时钱已经扣了，用户再次点击按钮，此时会进行第二次扣款，返回结果成功，用户查询余额发现多扣钱了，流水记录也变成了两条。在以前的单应用系统中，我们只需要把数据操作放入事务中即可，发生错误立即回滚，但是再响应客户端的时候也有可能出现网络中断或者异常等等</p><h4 id="消息重复消费"><a href="#消息重复消费" class="headerlink" title="消息重复消费"></a>消息重复消费</h4><p>消费者在消费 MQ 中的消息时，MQ 已把消息发送给消费者，消费者在给 MQ 返回 ack 时网络中断，故 MQ 未收到确认信息，该条消息会重新发给其他的消费者，或者在网络重连后再次发送给该消费者，但实际上该消费者已成功消费了该条消息，造成消费者消费了重复的消息。</p><h4 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h4><p>MQ 消费者的幂等性的解决一般使用全局 ID 或者写个唯一标识比如时间戳 或者 UUID 或者订单消费者消费 MQ 中的消息也可利用 MQ 的该 id 来判断，或者可按自己的规则生成一个全局唯一 id，每次消费消息时用该 id 先判断该消息是否已消费过。</p><h4 id="消费端的幂等性保障"><a href="#消费端的幂等性保障" class="headerlink" title="消费端的幂等性保障"></a>消费端的幂等性保障</h4><p>在海量订单生成的业务高峰期，生产端有可能就会重复发生了消息，这时候消费端就要实现幂等性，这就意味着我们的消息永远不会被消费多次，即使我们收到了一样的消息。业界主流的幂等性有两种操作:a.唯一 ID+指纹码机制,利用数据库主键去重, b.利用 redis 的原子性去实现</p><h4 id="唯一ID-指纹码机制"><a href="#唯一ID-指纹码机制" class="headerlink" title="唯一ID+ 指纹码机制"></a>唯一ID+ 指纹码机制</h4><p>指纹码:我们的一些规则或者时间戳加别的服务给到的唯一信息码,它并不一定是我们系统生成的，基本都是由我们的业务规则拼接而来，但是一定要保证唯一性，然后就利用查询语句进行判断这个 id 是否存在数据库中,优势就是实现简单就一个拼接，然后查询判断是否重复；劣势就是在高并发时，如果是单个数据库就会有写入性能瓶颈当然也可以采用分库分表提升性能，但也不是我们最推荐的方式。</p><h4 id="Redis原子性"><a href="#Redis原子性" class="headerlink" title="Redis原子性"></a>Redis原子性</h4><p>利用 redis 执行 setnx 命令，天然具有幂等性。从而实现不重复消费，此方式为目前用的最多的方案。</p><h3 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h3><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>在我们系统中有一个订单催付的场景，我们的客户在天猫下的订单,淘宝会及时将订单推送给我们，如果在用户设定的时间内未付款那么就会给用户推送一条短信提醒，很简单的一个功能对吧，但是，tmall商家对我们来说，肯定是要分大客户和小客户的对吧，比如像苹果，小米这样大商家一年起码能给我们创造很大的利润，所以理应当然，他们的订单必须得到优先处理，而曾经我们的后端系统是使用 redis 来存放的定时轮询，大家都知道 redis 只能用 List 做一个简简单单的消息队列，并不能实现一个优先级的场景，所以订单量大了后采用 RabbitMQ 进行改造和优化,如果发现是大客户的订单给一个相对比较高的优先级，否则就是默认优先级。</p><h4 id="如何添加"><a href="#如何添加" class="headerlink" title="如何添加"></a>如何添加</h4><p>a.控制台页面添加</p><p><img src="/images/studyNote/rabbitMQ/20210912_02829.png"></p><p>b.队列中代码添加优先级</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; params = <span class="keyword">new</span> HashMap();</span><br><span class="line">params.put(<span class="string">&quot;x-max-priority&quot;</span>, <span class="number">10</span>);</span><br><span class="line">channel.queueDeclare(<span class="string">&quot;hello&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, params);</span><br></pre></td></tr></table></figure><p><img src="/images/studyNote/rabbitMQ/20210912_03043.png"></p><p>c.消息中代码添加优先级</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AMQP.BasicProperties  properties  =  <span class="keyword">new</span> AMQP.BasicProperties().builder().priority(<span class="number">5</span>).build();</span><br></pre></td></tr></table></figure><p>d.<font color=red >注意事项</font> </p><p>要让队列实现优先级需要做的事情有如下事情:<strong>队列需要设置为优先级队列，消息需要设置消息的优先级</strong>，消费者需要等待消息已经发送到队列中才去消费因为，这样才有机会对消息进行排序</p><h4 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h4><h5 id="生产者-1"><a href="#生产者-1" class="headerlink" title="生产者"></a>生产者</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (Channel channel = RabbitMqUtils.getChannel();) &#123;</span><br><span class="line">            <span class="comment">// 给消息赋予一个 priority 属性</span></span><br><span class="line">            AMQP.BasicProperties properties = <span class="keyword">new</span></span><br><span class="line">                    AMQP.BasicProperties().builder().priority(<span class="number">5</span>).build();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">                String message = <span class="string">&quot;info&quot;</span> + i;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">5</span>) &#123;</span><br><span class="line">                    channel.basicPublish(<span class="string">&quot;&quot;</span>, QUEUE_NAME, properties, message.getBytes());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    channel.basicPublish(<span class="string">&quot;&quot;</span>, QUEUE_NAME, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot; 发送消息完成:&quot;</span> + message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="消费者-2"><a href="#消费者-2" class="headerlink" title="消费者"></a>消费者</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line">        <span class="comment">// 设置队列的最大优先级 最大可以设置到 255  官网推荐 1-10 如果设置太高比较吃内存和 CPU</span></span><br><span class="line">        Map&lt;String, Object&gt; params = <span class="keyword">new</span> HashMap();</span><br><span class="line">        params.put(<span class="string">&quot;x-max-priority&quot;</span>, <span class="number">10</span>);</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, params);</span><br><span class="line">        System.out.println(<span class="string">&quot; 消费者启动等待消费......&quot;</span>);</span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            String receivedMessage = <span class="keyword">new</span> String(delivery.getBody());</span><br><span class="line">            System.out.println(<span class="string">&quot; 接收到消息:&quot;</span> + receivedMessage);</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, deliverCallback, (consumerTag) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot; 消费者无法消费 消息时调用，如队列被删除&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="惰性队列"><a href="#惰性队列" class="headerlink" title="惰性队列"></a>惰性队列</h3><p>RabbitMQ 从 3.6.0 版本开始引入了惰性队列的概念。惰性队列会尽可能的将消息存入磁盘中，而在消费者消费到相应的消息时才会被加载到内存中，它的一个重要的设计目标是能够支持更长的队列，即支持更多的消息存储。<strong>当消费者由于各种各样的原因(比如消费者下线、宕机亦或者是由于维护而关闭等)而致使长时间内不能消费消息造成堆积时，惰性队列就很有必要了。</strong><br>默认情况下，当生产者将消息发送到 RabbitMQ 的时候，队列中的消息会尽可能的存储在内存之中，这样可以更加快速的将消息发送给消费者。即使是持久化的消息，在被写入磁盘的同时也会在内存中驻留一份备份。当 RabbitMQ 需要释放内存的时候，会将内存中的消息换页至磁盘中，这个操作会耗费较长的时间，也会阻塞队列的操作，进而无法接收新的消息。虽然 RabbitMQ 的开发者们一直在升级相关的算法，但是效果始终不太理想，尤其是在消息量特别大的时候。</p><h4 id="两种模式"><a href="#两种模式" class="headerlink" title="两种模式"></a>两种模式</h4><p>队列具备两种模式：default 和 lazy。默认的为 default 模式，在 3.6.0 之前的版本无需做任何变更。lazy模式即为惰性队列的模式，可以通过调用 channel.queueDeclare 方法的时候在参数中设置，也可以通过Policy 的方式设置，如果一个队列同时使用这两种方式设置的话，那么 Policy 的方式具备更高的优先级。如果要通过声明的方式改变已有队列的模式的话，那么只能先删除队列，然后再重新声明一个新的。<br>在队列声明的时候可以通过“x-queue-mode”参数来设置队列的模式，取值为“default”和“lazy”。下面示<br>例中演示了一个惰性队列的声明细节：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; args = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">args.put(<span class="string">&quot;x-queue-mode&quot;</span>, <span class="string">&quot;lazy&quot;</span>);</span><br><span class="line">channel.queueDeclare(<span class="string">&quot;myqueue&quot;</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, args);</span><br></pre></td></tr></table></figure><h4 id="内存开销对比"><a href="#内存开销对比" class="headerlink" title="内存开销对比"></a>内存开销对比</h4><p><img src="/images/studyNote/rabbitMQ/20210912_04201.png"></p><p>在发送 1 百万条消息，每条消息大概占 1KB 的情况下，普通队列占用内存是 1.2GB，而惰性队列仅仅占用 1.5MB</p><h2 id="RabbitMQ-集群"><a href="#RabbitMQ-集群" class="headerlink" title="RabbitMQ 集群"></a>RabbitMQ 集群</h2><h3 id="clustering集群模式"><a href="#clustering集群模式" class="headerlink" title="clustering集群模式"></a>clustering集群模式</h3><h4 id="使用集群的原因"><a href="#使用集群的原因" class="headerlink" title="使用集群的原因"></a>使用集群的原因</h4><p>最开始我们介绍了如何安装及运行 RabbitMQ 服务，不过这些是单机版的，无法满足目前真实应用的要求。如果 RabbitMQ 服务器遇到内存崩溃、机器掉电或者主板故障等情况，该怎么办？单台 RabbitMQ服务器可以满足每秒 1000 条消息的吞吐量，那么如果应用需要 RabbitMQ 服务满足每秒 10 万条消息的吞吐量呢？购买昂贵的服务器来增强单机 RabbitMQ 务的性能显得捉襟见肘，搭建一个 RabbitMQ 集群才是解决实际问题的关键。</p><h4 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h4><p><strong>1.修改 3 台机器的主机名称</strong></p><p>vim /etc/hostname</p><p><strong>2.配置各个节点的 hosts 文件，让各个节点都能互相识别对方</strong></p><p>vim /etc/hosts<br>10.211.55.74 node1<br>10.211.55.75 node2<br>10.211.55.76 node3</p><p><img src="/images/studyNote/rabbitMQ/20210912_105900.png"></p><p><strong>3.以确保各个节点的 cookie 文件使用的是同一个值</strong></p><p>在 node1 上执行远程操作命令<br>scp /var/lib/rabbitmq/.erlang.cookie root@node2:/var/lib/rabbitmq/.erlang.cookie<br>scp /var/lib/rabbitmq/.erlang.cookie root@node3:/var/lib/rabbitmq/.erlang.cookie</p><p><strong>4.启动 RabbitMQ 服务,顺带启动 Erlang 虚拟机和 RbbitMQ 应用服务(在三台节点上分别执行以下命令)</strong></p><p><code>rabbitmq-server -detached</code></p><p><strong>5.在节点 2 执行</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl stop_app (rabbitmqctl stop 会将 Erlang 虚拟机关闭，rabbitmqctl stop_app 只关闭 RabbitMQ 服务)</span><br><span class="line">rabbitmqctl reset</span><br><span class="line">rabbitmqctl join_cluster rabbit@node1</span><br><span class="line">rabbitmqctl start_app(只启动应用服务)</span><br></pre></td></tr></table></figure><p><strong>6.在节点 3 执行</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl stop_app</span><br><span class="line">rabbitmqctl reset</span><br><span class="line">rabbitmqctl join_cluster rabbit@node2</span><br><span class="line">rabbitmqctl start_app</span><br></pre></td></tr></table></figure><p><strong>7.集群状态</strong></p><p><code>rabbitmqctl cluster_status</code></p><p><strong>8.需要重新设置用户</strong></p><p>创建账号<br><code>rabbitmqctl add_user admin 123</code><br>设置用户角色<br><code>rabbitmqctl set_user_tags admin administrator</code><br>设置用户权限<br><code>rabbitmqctl set_permissions -p &quot;/&quot; admin &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</code></p><p><strong>9.解除集群节点(node2 和 node3 机器分别执行)</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl stop_app</span><br><span class="line">rabbitmqctl reset</span><br><span class="line">rabbitmqctl start_app</span><br><span class="line">rabbitmqctl cluster_status</span><br><span class="line">rabbitmqctl forget_cluster_node rabbit@node2(node1 机器上执行)</span><br></pre></td></tr></table></figure><h3 id="镜像队列"><a href="#镜像队列" class="headerlink" title="镜像队列"></a>镜像队列</h3><h4 id="使用镜像的原因"><a href="#使用镜像的原因" class="headerlink" title="使用镜像的原因"></a>使用镜像的原因</h4><p>如果 RabbitMQ 集群中只有一个 Broker 节点，那么该节点的失效将导致整体服务的临时性不可用，并且也可能会导致消息的丢失。可以将所有消息都设置为持久化，并且对应队列的durable属性也设置为true，但是这样仍然无法避免由于缓存导致的问题：因为消息在发送之后和被写入磁盘井执行刷盘动作之间存在一个短暂却会产生问题的时间窗。通过 publisherconfirm 机制能够确保客户端知道哪些消息己经存入磁盘，尽管如此，一般不希望遇到因单点故障导致的服务不可用。<br>引入镜像队列(Mirror Queue)的机制，可以将队列镜像到集群中的其他 Broker 节点之上，如果集群中的一个节点失效了，队列能自动地切换到镜像中的另一个节点上以保证服务的可用性。</p><h4 id="搭建步骤-1"><a href="#搭建步骤-1" class="headerlink" title="搭建步骤"></a>搭建步骤</h4><p><strong>1.启动三台集群节点</strong></p><p><strong>2.随便找一个节点添加 policy</strong></p><p><img src="/images/studyNote/rabbitMQ/20210912_121053.png"></p><p><strong>3.在 node1 上创建一个队列发送一条消息，队列存在镜像队列</strong></p><p><img src="/images/studyNote/rabbitMQ/20210912_121220.png"></p><p><strong>4.停掉 node1 之后发现 node2 成为镜像队列</strong></p><p><img src="/images/studyNote/rabbitMQ/20210912_121348.png"></p><p><strong>5.就算整个集群只剩下一台机器了 依然能消费队列里面的消息</strong></p><p>说明队列里面的消息被镜像队列传递到相应机器里面了</p><h3 id="实现高可用负载均衡"><a href="#实现高可用负载均衡" class="headerlink" title="实现高可用负载均衡"></a>实现高可用负载均衡</h3><h4 id="整体架构图"><a href="#整体架构图" class="headerlink" title="整体架构图"></a>整体架构图</h4><p><img src="/images/studyNote/rabbitMQ/20210912_121820.png"></p><h4 id="Haproxy-实现负载均衡"><a href="#Haproxy-实现负载均衡" class="headerlink" title="Haproxy 实现负载均衡"></a>Haproxy 实现负载均衡</h4><p>HAProxy 提供高可用性、负载均衡及基于 TCPHTTP 应用的代理，支持虚拟主机，它是免费、快速并且可靠的一种解决方案，包括 Twitter,Reddit,StackOverflow,GitHub 在内的多家知名互联网公司在使用。HAProxy 实现了一种事件驱动、单一进程模型，此模型支持非常大的井发连接数。</p><p>扩展 nginx,lvs,haproxy 之间的区别: <a href="http://www.ha97.com/5646.html">http://www.ha97.com/5646.html</a></p><h4 id="Keepalived实现双机"><a href="#Keepalived实现双机" class="headerlink" title="Keepalived实现双机"></a>Keepalived实现双机</h4><p>试想如果前面配置的 HAProxy 主机突然宕机或者网卡失效，那么虽然 RbbitMQ 集群没有任何故障但是对于外界的客户端来说所有的连接都会被断开结果将是灾难性的为了确保负载均衡服务的可靠性同样显得十分重要，这里就要引入 Keepalived 它能够通过自身健康检查、资源接管功能做高可用(双机热备)，实现故障转移。</p><h3 id="Federation-Exchange"><a href="#Federation-Exchange" class="headerlink" title="Federation Exchange"></a>Federation Exchange</h3><p>​        (broker 北京)，(broker 深圳)彼此之间相距甚远，网络延迟是一个不得不面对的问题。有一个在北京的业务(Client 北京) 需要连接(broker 北京)，向其中的交换器 exchangeA 发送消息，此时的网络延迟很小，(Client 北京)可以迅速将消息发送至 exchangeA 中，就算在开启了 publisherconfirm 机制或者事务机制的情况下，也可以迅速收到确认信息。此时又有个在深圳的业务(Client 深圳)需要向 exchangeA 发送消息，那么(Client 深圳) (broker 北京)之间有很大的网络延迟，(Client 深圳) 将发送消息至 exchangeA 会经历一定的延迟，尤其是在开启了 publisherconfirm 机制或者事务机制的情况下，(Client 深圳) 会等待很长的延迟时间来接收(broker 北京)的确认信息，进而必然造成这条发送线程的性能降低，甚至造成一定程度上的阻塞。<br>​        将业务(Client 深圳)部署到北京的机房可以解决这个问题，但是如果(Client 深圳)调用的另些服务都部署在深圳，那么又会引发新的时延问题，总不见得将所有业务全部部署在一个机房，那么容灾又何以实现？这里使用 Federation 插件就可以很好地解决这个问题.</p><h4 id="搭建步骤-2"><a href="#搭建步骤-2" class="headerlink" title="搭建步骤"></a>搭建步骤</h4><p><strong>1.需要保证每台节点单独运行</strong></p><p><strong>2.在每台机器上开启 federation 相关插件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins enable rabbitmq_federation</span><br><span class="line">rabbitmq-plugins enable rabbitmq_federation_management</span><br></pre></td></tr></table></figure><p><strong>3.原理图(先运行 consumer 在 node2 创建 fed_exchange)</strong></p><p><img src="/images/studyNote/rabbitMQ/20210912_123834.png"></p><p><strong>4.在 downstream(node2)配置 upstream(node1)</strong></p><p><img src="/images/studyNote/rabbitMQ/20210912_123911.png"></p><p><strong>5.添加 policy</strong></p><p><img src="/images/studyNote/rabbitMQ/20210912_123958.png"></p><p><strong>6.成功的前提</strong></p><p><img src="/images/studyNote/rabbitMQ/20210912_124034.png"></p><h3 id="Federation-Queue"><a href="#Federation-Queue" class="headerlink" title="Federation Queue"></a>Federation Queue</h3><p>联邦队列可以在多个 Broker 节点(或者集群)之间为单个队列提供均衡负载的功能。一个联邦队列可以连接一个或者多个上游队列(upstream queue)，并从这些上游队列中获取消息以满足本地消费者消费消息的需求。</p><h4 id="搭建步骤-3"><a href="#搭建步骤-3" class="headerlink" title="搭建步骤"></a>搭建步骤</h4><p><strong>1.原理图</strong></p><p><img src="/images/studyNote/rabbitMQ/20210912_124323.png"></p><p><strong>2.添加 upstream(同上)</strong></p><p><strong>3.添加 policy</strong></p><p><img src="/images/studyNote/rabbitMQ/20210912_124407.png"></p><h3 id="Shovel"><a href="#Shovel" class="headerlink" title="Shovel"></a>Shovel</h3><p>Federation 具备的数据转发功能类似，Shovel 够可靠、持续地从一个 Broker 中的队列(作为源端，即source)拉取数据并转发至另一个 Broker 中的交换器(作为目的端，即 destination)。作为源端的队列和作为目的端的交换器可以同时位于同一个 Broker，也可以位于不同的 Broker 上。Shovel 可以翻译为”铲子”，是一种比较形象的比喻，这个”铲子”可以将消息从一方”铲子”另一方。Shovel 行为就像优秀的客户端应用程序能够负责连接源和目的地、负责消息的读写及负责连接失败问题的处理。</p><h4 id="搭建步骤-4"><a href="#搭建步骤-4" class="headerlink" title="搭建步骤"></a>搭建步骤</h4><p><strong>1.开启插件(需要的机器都开启)</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins enable rabbitmq_shovel</span><br><span class="line">rabbitmq-plugins enable rabbitmq_shovel_management</span><br></pre></td></tr></table></figure><h4 id="2-原理图"><a href="#2-原理图" class="headerlink" title="2.原理图"></a>2.原理图</h4><p>在源头发送的消息直接回进入到目的地队列</p><p><img src="/images/studyNote/rabbitMQ/20210912_124534.png"></p><p><strong>3.添加 shovel 源和目的地</strong></p><p><img src="/images/studyNote/rabbitMQ/20210912_124609.png"></p><h2 id="RabbitMQ工具类"><a href="#RabbitMQ工具类" class="headerlink" title="RabbitMQ工具类"></a>RabbitMQ工具类</h2><p>在企业开发过程中，直接使用SpringBoot提供的RabbitTemplate还是略显复杂，通常我们一个系统发送消息基本上也是只依赖于一个交换机和一个队列（延迟消息需单独依赖于延迟交换机），基于此，我们可以把交换机、队列以及路由key等声明直接放在配置文件中，然后封装发送普通消息的工具类，和发送延迟消息的工具类，发送的消息体内容我们可以增加交易码这个概念，消费者通过不同交易码，处理不同的业务。消息体通过泛型，在发消息时声明消息体类型，通过json序列化传输。</p><h3 id="工具类使用"><a href="#工具类使用" class="headerlink" title="工具类使用"></a>工具类使用</h3><h4 id="延迟消息发送"><a href="#延迟消息发送" class="headerlink" title="延迟消息发送"></a>延迟消息发送</h4><p>项目启动时，直接声明好延迟交换机，延迟队列以及路由key，发送延迟消息只需要一句代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendDelayMsg</span><span class="params">(<span class="meta">@PathVariable</span> String message, <span class="meta">@PathVariable</span> Integer delayTime)</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;当前时间：&#123;&#125;,发送一条时长&#123;&#125;毫秒TTL信息给队列QC:&#123;&#125;&quot;</span>, <span class="keyword">new</span> Date(), delayTime, message);</span><br><span class="line">    MsgData&lt;String&gt; msgData = <span class="keyword">new</span> MsgData&lt;&gt;(<span class="string">&quot;0001&quot;</span>, message, <span class="string">&quot;这是我的测试延迟消息！&quot;</span>);</span><br><span class="line">    EventDispatcherUtil.eventDispatch(msgData, delayTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="普通消息发送"><a href="#普通消息发送" class="headerlink" title="普通消息发送"></a>普通消息发送</h4><p>普通消息通过发布订阅模式实现，其他系统若要接收次消息，只需要声明一个队列然后添加监听，绑定到此交换机上即可，发送普通消息也只需要一句代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendFanoutMsg</span><span class="params">(<span class="meta">@PathVariable</span> String message)</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;当前时间：&#123;&#125;,发送一条信息给队列QC:&#123;&#125;&quot;</span>, <span class="keyword">new</span> Date(), message);</span><br><span class="line">    MsgData&lt;String&gt; msgData = <span class="keyword">new</span> MsgData&lt;&gt;(<span class="string">&quot;0001&quot;</span>, message, <span class="string">&quot;这是我的测订阅消息！&quot;</span>);</span><br><span class="line">    EventDispatcherUtil.eventDispatch(msgData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RabbitMQ相关面试题"><a href="#RabbitMQ相关面试题" class="headerlink" title="RabbitMQ相关面试题"></a>RabbitMQ相关面试题</h2><h3 id="如何保证消息不丢失？"><a href="#如何保证消息不丢失？" class="headerlink" title="如何保证消息不丢失？"></a>如何保证消息不丢失？</h3><ol><li>队列和消息持久化：保证MQ宕机了消息不丢失，必须保证在磁盘上才能（3.4.2、3.4.3）</li><li>消息发布确认：开启消息发布确认，MQ将消息发送到交换机并且保存在磁盘上之后返回一个确认，此时可以保证生产者发送的消息绝对不丢失。见：9.1</li><li>消息回退处理：当消息到达交换机无法路由到队列时，交换机把消息回退给生产者，也可以通过<strong>备份交换机</strong>实现。见：9.2</li><li>消息应答机制：设置为手动应答，保证消费者正确处理完消息，如果处理失败，消息重新入队</li><li>集群环境下，添加镜像队列。见：11.2</li></ol><h3 id="消息的类型"><a href="#消息的类型" class="headerlink" title="消息的类型"></a>消息的类型</h3><p>主要是交换机的类型，包括：</p><ol><li>直接(direct)：路由类型</li><li>主题(topic)</li><li>标题(headers) ：已经不用了</li><li>扇出(fanout)：发布订阅类型</li></ol>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中的各种O</title>
      <link href="/2021/10/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/0%E3%80%81Java%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8DO/"/>
      <url>/2021/10/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/0%E3%80%81Java%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8DO/</url>
      
        <content type="html"><![CDATA[<h1 id="0、Java中的各种O"><a href="#0、Java中的各种O" class="headerlink" title="0、Java中的各种O"></a>0、Java中的各种O</h1><h2 id="1、POJO"><a href="#1、POJO" class="headerlink" title="1、POJO"></a>1、POJO</h2><blockquote><p>Plain Ordinary Java Object 简单Java对象。</p></blockquote><p>简单的Java对象，实际上就是一个普通的JavaBeans。使用POJO是为了避免和EJB混淆起来，而且简称比较直接。其中有一些属性及其getter/setter方法的类，没有业务逻辑。有时候可以作为VO或者DTO来使用。</p><h2 id="2、PO"><a href="#2、PO" class="headerlink" title="2、PO"></a>2、PO</h2><blockquote><p>Presistant Object 持久化对象</p></blockquote><p>它们是一组属性和属性的setter/getter方法组成。基于O/R映射出现的概念。属性通常对应数据库/数据模型，并且本身也就可以有一些业务逻辑的处理，可以看做是<strong>数据库表映射的对象</strong>。</p><h2 id="3、BO"><a href="#3、BO" class="headerlink" title="3、BO"></a>3、BO</h2><blockquote><p>Business Object 业务对象</p></blockquote><p>业务对象就是将业务抽象逻辑封装成的对象。这个对象可以包含很多种其他对象，比如DAO作为数据库访问，或者DTO作为业务数据的传递，也可以持有很多的POJO对象。</p><h2 id="4、DO"><a href="#4、DO" class="headerlink" title="4、DO"></a>4、DO</h2><blockquote><p>Domain Object 领域对象</p></blockquote><p>就是从显示世界中抽象出来的有形或者无形的业务实体</p><h2 id="5、DAO"><a href="#5、DAO" class="headerlink" title="5、DAO"></a>5、DAO</h2><blockquote><p>Data Access Obejct 数据访问对象</p></blockquote><p>一般指数据库的访问对象。相当于一个数据的访问接口。加在业务层和数据层中间。通过调用DAO的方法，业务层可以获取一个或者多个PO数据。</p><h2 id="6、-DTO"><a href="#6、-DTO" class="headerlink" title="6、 DTO"></a>6、 DTO</h2><blockquote><p>Data Transfer Object 数据传输对象</p></blockquote><p>一般只用于客户端和服务端，展示层和服务层，应用间为传递数据而封装的对象。内部可以包含很多VO和POJO</p><h2 id="7、-VO"><a href="#7、-VO" class="headerlink" title="7、 VO"></a>7、 VO</h2><blockquote><p>Value Object 值对象</p></blockquote><p>通常用于业务层之间的数据传递和PO一样也仅仅包含数据而已。但应对抽象的业务对象，可以和表对应，也可以不，这个需要根据业务需求，用new 关键字创建，由GC回收。</p>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端技术 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
