<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>面试知识点总结 | 李苟蛋の家</title><meta name="keywords" content="面试"><meta name="author" content="李苟蛋"><meta name="copyright" content="李苟蛋"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="常见面试题，按照知识点分类整理，带答案">
<meta property="og:type" content="article">
<meta property="og:title" content="面试知识点总结">
<meta property="og:url" content="https://zhangyong3214.github.io/2022/01/27/%E9%9D%A2%E8%AF%95%E5%9F%BA%E5%9C%B0/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/index.html">
<meta property="og:site_name" content="李苟蛋の家">
<meta property="og:description" content="常见面试题，按照知识点分类整理，带答案">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zhangyong3214.github.io/images/cover/interview.jpg">
<meta property="article:published_time" content="2022-01-27T08:31:13.128Z">
<meta property="article:modified_time" content="2022-01-27T08:31:13.129Z">
<meta property="article:author" content="李苟蛋">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zhangyong3214.github.io/images/cover/interview.jpg"><link rel="shortcut icon" href="https://gitee.com/lizejiao/img-go/raw/master/images/favicon.jpg"><link rel="canonical" href="https://zhangyong3214.github.io/2022/01/27/%E9%9D%A2%E8%AF%95%E5%9F%BA%E5%9C%B0/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":800},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '面试知识点总结',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-01-27 16:31:13'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/%E5%85%B3%E4%BA%8E%E6%88%91/"><i class="fa-fw fas fa-user"></i><span> 关于我</span></a></div><div class="menus_item"><a class="site-page" href="/message/"><i class="fa-fw fas fa-comments"></i><span> 留言板</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/default_top_img.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">李苟蛋の家</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/%E5%85%B3%E4%BA%8E%E6%88%91/"><i class="fa-fw fas fa-user"></i><span> 关于我</span></a></div><div class="menus_item"><a class="site-page" href="/message/"><i class="fa-fw fas fa-comments"></i><span> 留言板</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">面试知识点总结</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-01-27T08:31:13.128Z" title="发表于 2022-01-27 16:31:13">2022-01-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-01-27T08:31:13.129Z" title="更新于 2022-01-27 16:31:13">2022-01-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">19.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>60分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="面试知识点总结"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="面向对象的特征"><a href="#面向对象的特征" class="headerlink" title="面向对象的特征?"></a>面向对象的特征?</h3><p>面向对象的特征:封装、继承、多态、抽象。 封装:就是把对象的属性和行为(数据)结合为一个独立的整体，并尽可能隐藏对象的内 部实现细节，就是把不想告诉或者不该告诉别人的东西隐藏起来，把可以告诉别人的公开，别人只能用我提供的功能实现需求，而不知道是如何实现的。增加安全性。 继承:子类继承父类的数据属性和行为，并能根据自己的需求扩展出新的行为，提高了代 码的复用性。 多态:指允许不同的对象对同一消息做出相应。即同一消息可以根据发送对象的不同而采 用多种不同的行为方式(发送消息就是函数调用)。封装和继承几乎都是为多态而准备 的，在执行期间判断引用对象的实际类型，根据其实际的类型调用其相应的方法。 抽象:表示对问题领域进行分析、设计中得出的抽象的概念，是对一系列看上去不同，但是本质上相同的具体概念的抽象。在 Java 中抽象用 abstract 关键字来修饰，用abstract修饰类时，此类就不能被实例化，从这里可以看出，抽象类(接口)就是为了继承而存在的。</p>
<h3 id="常见的RuntimeException"><a href="#常见的RuntimeException" class="headerlink" title="常见的RuntimeException"></a>常见的RuntimeException</h3><ol>
<li>java.lang.NullPointerException 空指针异常;出现原因:调用了未经初始化的对象或者是不存在 的对象。</li>
<li>java.lang.ClassNotFoundException 指定的类找不到;出现原因:类的名称和路径加载错误;通常 都是程序试图通过字符串来加载某个类时可能引发异常。</li>
<li>java.lang.NumberFormatException 字符串转换为数字异常;出现原因:字符型数据中包含非数 字型字符。</li>
<li>java.lang.IndexOutOfBoundsException 数组角标越界异常，常见于操作数组对象时发生。</li>
<li>java.lang.IllegalArgumentException 方法传递参数错误。</li>
<li>java.lang.ClassCastException 数据类型转换异常。 </li>
<li>java.lang.NoClassDefFoundException 未找到类定义错误。</li>
<li>SQLException SQL 异常，常见于操作数据库时的 SQL 语句错误。</li>
<li>java.lang.InstantiationException实例化异常。</li>
<li>java.lang.NoSuchMethodException方法不存在异常。</li>
</ol>
<h3 id="常见的引用类型"><a href="#常见的引用类型" class="headerlink" title="常见的引用类型"></a>常见的引用类型</h3><p>java的引用类型一般分为四种：<strong>强引用</strong>、<strong>软引用</strong>、弱引用、虚引用</p>
<ul>
<li><strong>强引用</strong>：普通的变量引用</li>
<li><strong>软引用</strong>：将对象用SoftReference软引用类型的对象包裹，正常情况不会被回收，但是GC做完后发现释放不出空间存放新的对象，则会把这些软引用的对象回收掉。<strong>软引用可用来实现内存敏感的高速缓存。</strong></li>
<li><strong>弱引用</strong>：将对象用WeakReference软引用类型的对象包裹，弱引用跟没引用差不多，<strong>GC会直接回收掉</strong>，很少用</li>
<li><strong>虚引用：</strong>虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系，几乎不用</li>
</ul>
<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="jvm内存模型"><a href="#jvm内存模型" class="headerlink" title="jvm内存模型"></a>jvm内存模型</h3><img src="https://raw.githubusercontent.com/lizejiao/img_bed/master/images/20210920235127.png"  />





<h3 id="对象创建过程"><a href="#对象创建过程" class="headerlink" title="对象创建过程"></a>对象创建过程</h3><img src="https://raw.githubusercontent.com/lizejiao/img_bed/master/images/jvm-object.png"/>

<ol>
<li><strong>类加载检查：</strong>虚拟机遇到一条new指令时，首先将去检查这个类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程：类加载过程中会通过jvm自带的三个类加载器按照双亲委派机制进行类加载过程，我们常见的ClassNotFoundException就是在这里发生的，我们代码中的静态代码块里面的内容也是在这个过程中执行的。</li>
<li><strong>分配内存：</strong>在类加载检查通过后，虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务等同于把 一块确定大小的内存从Java堆中划分出来。</li>
<li><strong>初始化零值：</strong>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</li>
<li><strong>设置对象头</strong>：初始化零值之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息(即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例)、对象的哈希码（HashCode）、对象的GC分代年龄、锁状态标志等信息。这些信息存放在对象的对象头Object Header之中。</li>
<li><strong>执行<init>方法</strong>：执行方法，即对象按照程序员的意愿进行初始化。对应到语言层面上讲，就是<strong>为属性赋值</strong>（注意，这与上面的赋零值不同，这是由程序员赋的值），和<strong>执行构造方法</strong>。</li>
</ol>
<h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><ol>
<li>引用计数法</li>
<li>可达性分析法</li>
</ol>
<p>对于可达性分析法，我们知道需要存在一个GC Root的对象作为起点，从这个节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连（就是从GC Roots到对象不可达）时，则证明此对象是不可用的。</p>
<h3 id="GC-Root有哪些？"><a href="#GC-Root有哪些？" class="headerlink" title="GC Root有哪些？"></a>GC Root有哪些？</h3><ul>
<li>虚拟机栈中的引用对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用对象</li>
<li>本地方法栈中JNI引用对象</li>
</ul>
<h3 id="垃圾回收器有哪些？"><a href="#垃圾回收器有哪些？" class="headerlink" title="垃圾回收器有哪些？"></a>垃圾回收器有哪些？</h3><ol>
<li><strong>Serial收集器</strong>(-XX:+UseSerialGC -XX:+UseSerialOldGC)：Serial（串行）收集器是一个单线程收集器，新生代采用复制算法，老年代采用标记-整理算法。</li>
<li><strong>Parallel Scavenge收集器</strong>(-XX:+UseParallelGC(年轻代),-XX:+UseParallelOldGC(老年代)) ：Parallel收集器其实就是Serial收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和Serial收集器类似。默认的收集线程数跟cpu核数相同</li>
<li><strong>ParNew收集器</strong>(-XX:+UseParNewGC)：只有它能与CMS收集器（真正意义上的并发收集器，后面会介绍到）配合工作</li>
<li><strong>CMS收集器</strong>(-XX:+UseConcMarkSweepGC(old))：收集器是一种以获取最短回收停顿时间为目标的收集器CMS收集器是一种 “标记-清除”算法实现的。CMS等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是CPU中用于运行用户代码的时间与CPU总消耗时间的比值。</li>
<li><strong>G1收集器</strong>(-XX:+UseG1GC)：G1 (Garbage-First)是一款面向服务器的垃圾收集器，主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征。G1将Java堆划分为多个大小相等的独立区域（Region），JVM最多可以有2048个Region。一般Region大小等于堆大小除以2048，比如堆大小为4096M，则Region大小为2M</li>
<li><strong>Shenandoah：</strong>可以看成是G1升级版</li>
<li><strong>ZGC收集器：</strong>ZGC是一款JDK 11中新加入的具有实验性质的低延迟垃圾收集器。1、支持TB量级的堆；2、最大GC停顿时间不超10ms；3、奠定未来GC特性的基础；4、最糟糕的情况下吞吐量会降低15%</li>
</ol>
<h3 id="CMS运行过程，缺点？"><a href="#CMS运行过程，缺点？" class="headerlink" title="CMS运行过程，缺点？"></a>CMS运行过程，缺点？</h3><p>整个过程分为四个步骤</p>
<ol>
<li><strong>初始标记(STW)：</strong> 暂停所有的其他线程(STW)，并记录下gc roots直接能引用的对象，速度很快</li>
<li><strong>并发标记：</strong> 并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对象图的过程， 这个过程耗时较长但是不需要停顿用户线程，因为用户程序继续运行，可能会有导致已经标记过的对象状态发生改变。</li>
<li><strong>重新标记(STW)：</strong> 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短。</li>
<li><strong>并发清理：</strong> 开启用户线程，同时GC线程开始对未标记的区域做清扫。</li>
<li><strong>并发重置：</strong>重置本次GC过程中的标记数据。</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>对CPU资源敏感（会和服务抢资源）</li>
<li>无法处理浮动垃圾(在并发标记和并发清理阶段又产生垃圾，这种浮动垃圾只能等到下一次gc再清理了)；</li>
<li>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生，当然通过参数-XX:+UseCMSCompactAtFullCollection可以让jvm在执行完标记清除后再做整理</li>
<li>并发模式失败(最大问题)，执行过程中的不确定性，会存在上一次垃圾回收还没执行完，然后垃圾回收又被触发的情况，特别是在并发标记和并发清理阶段会出现，一边回收，系统一边运行，也许没回收完就再次触发full gc，也就是”concurrent mode failure”，此时会进入stop the world，用serial old垃圾收集器来回收</li>
</ol>
<h3 id="G1运行过程"><a href="#G1运行过程" class="headerlink" title="G1运行过程"></a>G1运行过程</h3><p>G1收集器一次GC的运作过程大致分为以下几个步骤：</p>
<ol>
<li>初始标记（initial mark，STW）：暂停所有的其他线程，并记录下gc roots直接能引用的对象，速度很快 ；</li>
<li>并发标记（Concurrent Marking）：同CMS的并发标记</li>
<li>最终标记（Remark，STW）：同CMS的重新标记</li>
<li>筛选回收（Cleanup，STW）：G1采用复制算法回收几乎不会有太多内存碎片</li>
</ol>
<h3 id="G1适合什么场景"><a href="#G1适合什么场景" class="headerlink" title="G1适合什么场景"></a>G1适合什么场景</h3><ol>
<li>50%以上的堆被存活对象占用</li>
<li>对象分配和晋升的速度变化非常大</li>
<li>垃圾回收时间特别长，超过1秒</li>
<li>8GB以上的堆内存(建议值)</li>
<li>停顿时间是500ms以内</li>
</ol>
<h3 id="判断元空间是无用的类"><a href="#判断元空间是无用的类" class="headerlink" title="判断元空间是无用的类"></a>判断元空间是无用的类</h3><p>法区（元空间）主要回收的是无用的类，那么如何判断一个类是无用的类呢？类需要同时满足下面3个条件才能算是 <strong>“无用的类”</strong> ：</p>
<ul>
<li>该类所有的对象实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li>
<li>加载该类的 ClassLoader 已经被回收。（条件苛刻，自定义类加载器会被回收掉）</li>
<li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
<h3 id="安全点和安全区域"><a href="#安全点和安全区域" class="headerlink" title="安全点和安全区域"></a>安全点和安全区域</h3><p><strong>安全点：</strong>就是指代码中一些特定的位置,当线程运行到这些位置时它的状态是确定的,这样JVM就可以安全的进行一些操作,比如GC等，所以GC不是想什么时候做就立即触发的，是需要等待所有线程运行到安全点后才能触发。这些特定的安全点位置主要有以下几种:</p>
<ol>
<li>方法返回之前</li>
<li>调用某个方法之后</li>
<li>抛出异常的位置</li>
<li>循环的末尾</li>
</ol>
<p>安全区域：如果一个线程处于 Sleep 或中断状态，它就不能响应 JVM 的中断请求，引用关系不会发生变化。在这个区域内的任意地方开始 GC 都是安全的。</p>
<h3 id="类加载器？双亲委派，好处？"><a href="#类加载器？双亲委派，好处？" class="headerlink" title="类加载器？双亲委派，好处？"></a>类加载器？双亲委派，好处？</h3><p><strong>JDK自带有三个类加载器</strong>：bootstrapClassLoader(引导类加载器)、ExtClassLoader(扩展类加载器)、AppClassLoader(系统类加载器)，bootstrapClassLoader是ExtClassLoader的父类加载器(并不是集成关系，是属性关系)默认加载%JAVA_HOME%/lib下的jar包和class文件ExtClassLoader是AppClassLoader的父类加载器，默认加载%JAVA_HOME%/lib/ext文件夹下的jar包和class文件AppClassLoader是自定义类加载器，负责加载classpath下的类文件</p>
<p><strong>双亲委派：</strong>分为向上委派和向下查找，每一个类加载器都有各自的缓存，都会记录自己加载过的类，当一个类需要加载，AppClassLoader先查找自己的缓存有没有加载过这个类，没有加载过就会调用ExtClassLoader去查找，ExtClassLoader没有加载过，就会调用bootstrapClassLoader类去加载，如果bootstrapClassLoader没有加载过，就会去他的类加载路径查找，如果没有找到ExtClassLoader就会查找他的类加载路径，向上委派就是查找缓存，查找到bootstrapClassLoader位置，向下查找就是查找类加载路径，查找到发起的类加载器为止。</p>
<p><strong>好处：</strong>1、安全性，避免自己写的类替换掉java核心类；2、避免类重复加载，相同class文件不同的类加载器加载的也是两个类。</p>
<h3 id="YGC和FGC发生的场景"><a href="#YGC和FGC发生的场景" class="headerlink" title="YGC和FGC发生的场景"></a>YGC和FGC发生的场景</h3><p>YGC：对新生代堆进行gc。频率比较高，因为大部分对象的存活寿命较短，在新生代里被回收。性能耗费较小。edn空间不足,执行 </p>
<p>FGC：全堆范围的gc。默认堆空间使用到达80%(可调整)的时候会触发fgc。生产环境，一般比较少会触发fgc，有时10天或一周左右会有一次。</p>
<p>老年代空间不足，永久区空间不足，调用方法System.gc() ，ygc时的悲观策略, dump live的内存信息时(jmap –dump:live)，都会执行full gc</p>
<h3 id="jstack，jmap，Jstat作用"><a href="#jstack，jmap，Jstat作用" class="headerlink" title="jstack，jmap，Jstat作用"></a>jstack，jmap，Jstat作用</h3><p><strong>jmap：</strong>可以用来查看内存信息，实例个数以及占用内存大小</p>
<ul>
<li>jmap -heap 进程号：查看堆内存信息</li>
<li>jmap ‐dump:format=b,file=eureka.hprof 进程号： 堆内存的快照信息，添加jvm参数也可以设置内存溢出自动导出dump文件</li>
</ul>
<p><strong>jstack:</strong> 可以获得java线程的运行情况，可以查看死锁，阻塞，等待</p>
<ul>
<li>Jstack -l PID &gt;&gt; 123.txt 打印某个java进程的堆栈信息</li>
</ul>
<p><strong>Jstat：</strong>jstat命令可以查看堆内存各部分的使用量，以及加载类的数量</p>
<ul>
<li>jstat -gc pid 最常用，可以评估程序内存使用及GC压力整体情况</li>
</ul>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><ul>
<li><p>死锁：是指一组互相竞争资源的线程，因为互相等待，导致永久阻塞的现象。</p>
</li>
<li><p>原因：必须同时满足以下四个条件</p>
<ol>
<li>共享互斥条件：共享资源x和y只能被一个线程占用</li>
<li>占有且等待：线程t1已经占有共享资源x，在等待共享资源y的时候不释放共享资源x</li>
<li>不可抢占：其他线程不能强行抢占线程t1占有的资源</li>
<li>循环等待：线程t1等待线程t2占有的资源，线程t2等待线程t1占有的资源</li>
</ol>
</li>
<li><p>如何避免死锁：</p>
<ol>
<li>既然产生死锁必然满足四个条件，那我们只要打破四个条件中的一个就可以避免，第一个互斥条件是无法被破坏的，因为锁本身就是通过互斥来解决线程安全的</li>
<li>针对后三个条件，我们逐一分析，占有且等待这个条件我们可以一次性申请所有资源，不存在等待；</li>
<li>不可抢占这个条件：占有部分资源的线程进一步申请其他资源的时候如果申请不到，可以主动释放已占有的资源，这样不可抢占这条件就破坏了；</li>
<li>循环等待这个条件：可以按照顺序去申请资源进行预防，就是说资源是有线性顺序的，申请的时候可以先申请资源序号小的，再申请资源序号大的，线性化之后，就不存在循环等待了</li>
</ol>
</li>
</ul>
<h3 id="sleep和wait区别"><a href="#sleep和wait区别" class="headerlink" title="sleep和wait区别"></a>sleep和wait区别</h3><ol>
<li>sleep 是 Thread 类的静态本地方法，wait 则是 Object 类的本地方法</li>
<li>sleep方法不会释放锁，但是wait会释放，而且会加入到等待队列中</li>
<li>sleep方法不依赖于同步器synchronized，但是wait需要依赖synchronized关键字</li>
<li>sleep不需要被唤醒（休眠之后推出阻塞），但是wait需要（不指定时间需要被别人中断）</li>
<li>sleep 一般用于当前线程休眠，或者轮循暂停操作，wait 则多用于多线程之间的通信</li>
<li>sleep 会让出 CPU 执行时间且强制上下文切换，而 wait 则不一定，wait 后可能还是有机会重新竞争到锁继续执行的。</li>
</ol>
<p>sleep就是把cpu的执行资格和执行权释放出去，不再运行此线程，当定时时间结束再取回cpu资源，参与cpu的调度，获取到cpu资源后就可以继续运行了。而如果sleep时该线程有锁，那么sleep不会释放这个锁，而是把锁带着进入了冻结状态，也就是说其他需要这个锁的线程根本不可能获取到这个锁。也就是说无法执行程序。如果在睡眠期间其他线程调用了这个线程的interrupt方法，那么这个线程也会抛出interruptexception异常返回，这点和wait是一样的。</p>
<p>当我们调用wait（）方法后，线程会放到等待池当中，等待池的线程是不会去竞争同步锁。只有调用了notify（）或notifyAll()后等待池的线程才会开始去竞争锁，notify（）是随机从等待池选出一个线程放到锁池，而notifyAll()是将等待池的所有线程放到锁池当中</p>
<h3 id="Volitile作用"><a href="#Volitile作用" class="headerlink" title="Volitile作用"></a>Volitile作用</h3><ol>
<li>可见性：对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。内存屏障-&gt;汇编Lock关键字-&gt;缓存一致性协议</li>
<li>原子性：对任意单个volatile变量的读/写具有原子性，但类似于volatile++这种复合操作不具有原子性</li>
<li>有序性：对volatile修饰的变量的读写操作前后加上各种特定的内存屏障来禁止指令重排序来保障有序性</li>
</ol>
<h3 id="Volitile如何保证可见性"><a href="#Volitile如何保证可见性" class="headerlink" title="Volitile如何保证可见性"></a>Volitile如何保证可见性</h3><ol>
<li><strong>缓存一致性：</strong>在共享内存多处理器系统中，每个处理器都有一个单独的缓存内存，共享数据在主内存和各处理器私有缓存同时存在。当数据的一个副本发生更改，其他副本需要感知到最新修改数据。缓存一致性的手段主要有：</li>
<li>总线锁定：总线锁定就是使用处理器提供的一个 LOCK＃信号，当其中一个处理器在总线上输出此信号时，其它处理器的请求将被阻塞，那么该处理器可以独占共享内存。</li>
<li>总线窥探(Bus snooping)：是缓存中的一致性控制器窥探总线事务的一种方案（该方案由Ravishankar和Goodman于1983年提出）当数据被多个缓存共享时，一个处理器修改了共享数据的值，可以是刷新缓存块或使缓存块失效还可以通过缓存块状态的改变，来达到缓存一致性的目的，主要取决于窥探协议类型：<ol>
<li>写失效（Write-invalidate） ：当一个处理器写入共享缓存时，其他缓存中的所有共享副本都会通过总线窥探失效。确保处理器只能读写一个数据副本，其他缓存中的所有其他副本都无效。这是最常用的窥探协议。MSI、MESI、MOSI、MOESI和MESIF协议属于该类型。</li>
<li>写更新（Write-update）：当处理器写入一个共享缓存块时，其他缓存的所有共享副本都会通过总线窥探更新。这个方法将写数据广播到总线上的所有缓存中。它比写失效协议引起更大的总线流量，因此这种方法不常见。Dragon和firefly协议属于此类别。</li>
</ol>
</li>
</ol>
<h3 id="指令重排序"><a href="#指令重排序" class="headerlink" title="指令重排序"></a>指令重排序</h3><p>Java语言规范规定JVM线程内部维持顺序化语义，即只要程序的最终结果与它顺序化情况的结果相等，那么指令的执行顺序可以与代码顺序不一致，此过程叫指令的重排序。指令重排序的意义：：JVM能根据处理器特性（CPU多级缓存系统、多核处理器等）适当的对机器指令进行重排序，使机器指令能更符合CPU的执行特性，最大限度的发挥机器性能。</p>
<h3 id="Java线程的生命周期"><a href="#Java线程的生命周期" class="headerlink" title="Java线程的生命周期"></a>Java线程的生命周期</h3><ol>
<li>NEW（初始化状态）</li>
<li>RUNNABLE（可运行状态+运行状态）</li>
<li>BLOCKED（阻塞状态）</li>
<li>WAITING（无时限等待）</li>
<li>TIMED_WAITING（有时限等待）</li>
<li>TERMINATED（终止状态）</li>
</ol>
<p>在操作系统层面，有五种状态，Java 线程中的 BLOCKED、WAITING、TIMED_WAITING 是一种状态，即前面我们提到的休眠状态。也就是说只要 Java 线程处于这三种状态之一，那么这个线程就永远没有 CPU 的使用权。</p>
<h3 id="linux查看线程命令"><a href="#linux查看线程命令" class="headerlink" title="linux查看线程命令"></a>linux查看线程命令</h3><ul>
<li><p>ps  - fe 查看所有进程</p>
</li>
<li><p>ps  - fT  - p <PID> 查看某个进程（ PID ）的所有线程</p>
</li>
<li><p>kill 杀死进程</p>
</li>
<li><p>top 按大写  H  切换是否显示线程</p>
</li>
<li><p>top  - H  - p <PID> 查看某个进程（ PID ）的所有线程</p>
</li>
<li><p>jps 命令查看所有  Java  进程</p>
</li>
<li><p>jstack <PID> 查看某个  Java  进程（ PID ）的所有线程状态</p>
</li>
<li><p>jconsole 来查看某个  Java  进程中线程的运行情况（图形界面）</p>
</li>
</ul>
<h3 id="Java线程的实现方式"><a href="#Java线程的实现方式" class="headerlink" title="Java线程的实现方式"></a>Java线程的实现方式</h3><ol>
<li>方式1：使用 Thread类或继承Thread类</li>
<li>实现 Runnable 接口配合Thread</li>
<li>使用有返回值的 Callable，借助线程池使用</li>
<li>使用 lambda</li>
</ol>
<p>本质上Java中实现线程只有一种方式，都是通过new Thread()创建线程，调用Thread#start启动线程最终都会调用Thread#run方法</p>
<h3 id="Thread常用方法"><a href="#Thread常用方法" class="headerlink" title="Thread常用方法"></a>Thread常用方法</h3><p><strong>sleep方法</strong></p>
<ul>
<li>调用 sleep 会让当前线程从 Running 进入TIMED_WAITING状态，不会释放对象锁</li>
<li>其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出InterruptedException，并且会清除中断标志</li>
<li>睡眠结束后的线程未必会立刻得到执行</li>
<li>sleep当传入参数为0时，和yield相同</li>
</ul>
<p><strong>yield方法</strong></p>
<ul>
<li>yield会释放CPU资源，让当前线程从 Running 进入 Runnable状态，让优先级更高（至少是相同）的线程获得执行机会，不会释放对象锁；</li>
<li>假设当前进程只有main线程，当调用yield之后，main线程会继续运行，因为没有比它优先级更高的线程；</li>
<li>具体的实现依赖于操作系统的任务调度器</li>
</ul>
<h3 id="ThreadLocal的实现原理"><a href="#ThreadLocal的实现原理" class="headerlink" title="ThreadLocal的实现原理"></a>ThreadLocal的实现原理</h3><p>ThreadLocal的实现原理，每一个Thread维护一个ThreadLocalMap，key为使用弱引用的ThreadLocal<br>实例，value为线程变量的副本</p>
<h3 id="ThreadLocal应用场景"><a href="#ThreadLocal应用场景" class="headerlink" title="ThreadLocal应用场景"></a>ThreadLocal应用场景</h3><ol>
<li>在进行对象跨层传递的时候，使用ThreadLocal可以避免多次传递，打破层次间的约束。</li>
<li>线程间数据隔离</li>
<li>进行事务操作，用于存储线程事务信息。</li>
<li>数据库连接，Session会话管理。<ul>
<li>Spring框架在事务开始时会给当前线程绑定一个Jdbc Connection,在整个事务过程都是使用该线程绑定的connection来执行数据库操作，实现了事务的隔离性。Spring框架里面就是用的ThreadLocal来实现这种隔离</li>
</ul>
</li>
</ol>
<h3 id="ThreadLocal内存泄露原因，如何避免"><a href="#ThreadLocal内存泄露原因，如何避免" class="headerlink" title="ThreadLocal内存泄露原因，如何避免"></a>ThreadLocal内存泄露原因，如何避免</h3><ol>
<li>强引用：使用最普遍的引用(new)，一个对象具有强引用，不会被垃圾回收器回收。当内存空间不足，<br>Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不回收这种对象。</li>
<li>弱引用：JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。在java中，用<br>java.lang.ref.WeakReference类来表示。可以在缓存中使用弱引用。</li>
<li>ThreadLocal正确的使用方法<ul>
<li>每次使用完ThreadLocal都调用它的remove()方法清除数据</li>
<li>将ThreadLocal变量定义成private static，这样就一直存在ThreadLocal的强引用，也就能保证任<br>何时候都能通过ThreadLocal的弱引用访问到Entry的value值，进而清除掉 。</li>
</ul>
</li>
</ol>
<h3 id="synchronized和ReentranLock区别？"><a href="#synchronized和ReentranLock区别？" class="headerlink" title="synchronized和ReentranLock区别？"></a>synchronized和ReentranLock区别？</h3><p>synchronized是jvm层面的关键字，底层是通过monitor对象来完成，monitor对象底层依赖于操作系统的Mutex互斥量，底层调用的是操作系统的Pthread库，是由操作系统来维护的，而操作系统分为用户空间和内核空间的，JVM运行在用户空间，调用底层操作系统cpu会进行一轮状态切换，这个状态切换是比较重型操作，wait/notify等方法也依赖monitor对象只有在同步块或方法中才能调wait/notify等方法。</p>
<p>Lock是具体类（java.util.concurrent.Locks.Lock)是api层面的锁，是从jdk1.5开始引入的，那个时候synchronized性能还比较差，ReentranLock的出现是为了解决当时性能差的问题</p>
<ul>
<li><p>使用方法：synchronized不需要手动释放锁，ReentranLock则需要用户手动释放锁(需要lock()和unlock()配合try/finally使用)</p>
</li>
<li><p>等待是否可中断：synchronized不可中断，除非抛出异常或者执行完成，ReentranLock可中断</p>
</li>
</ul>
<ol>
<li>设置超时方法tryLock(long timeout, timeUnit unit)</li>
<li>lockInterruptibly()放代码块忠，调用interrupt()方法可中断</li>
</ol>
<ul>
<li><p>加锁是否公平：synchronized非公平锁；ReentranLock 两者都可以，默认非公平锁，构造方法传入true为公平锁，false为非公平锁</p>
</li>
<li><p>锁绑定多个条件Condition：synchronized 没有；ReentranLock  用来实现分组唤醒需要唤醒的线程，可以精确唤醒，不像synchronized要么随机唤醒一个线程，要么全部唤醒</p>
</li>
</ul>
<h3 id="线程池参数有，核心线程配置，原因？"><a href="#线程池参数有，核心线程配置，原因？" class="headerlink" title="线程池参数有，核心线程配置，原因？"></a>线程池参数有，核心线程配置，原因？</h3><ol>
<li>corePoolSize：线程池中的核心线程数</li>
<li>maximumPoolSize：线程池中允许的最大线程数。如果当前阻塞队列满了，且继续提交任务，则创建新的线程执行任务</li>
<li>keepAliveTime：核心线程外的线程存活超时时间</li>
<li>unit：时间单位</li>
<li>workQueue：用来保存等待被执行的任务的阻塞队列，且任务必须实现Runable接口</li>
<li>threadFactory：用来创建新线程</li>
<li>线程池的饱和策略：( AbortPolicy：直接抛出异常，默认策略；CallerRunsPolicy：用调用者所在的线程来执行任务；DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；DiscardPolicy：直接丢弃任务)</li>
</ol>
<p><strong>CPU密集型（CPU-bound）</strong></p>
<p>CPU密集型也叫计算密集型，在多重程序系统中，大部份时间用来做计算、逻辑判断等CPU动作的程序称之CPU bound。例如一个计算圆周率至小数点一千位以下的程序，在执行的过程当中绝大部份时间用在三角函数和开根号的计算，便是属于CPU bound的程序。</p>
<p><font color=red face="黑体">线程数 = CPU核数+1 (现代CPU支持超线程)</font> </p>
<p><strong>IO密集型（I/O bound）</strong></p>
<p>IO密集型指的是系统的CPU性能相对硬盘、内存要好很多，此时，系统运作，大部分的状况是CPU在等I/O (硬盘/内存) 的读/写操作</p>
<p> <font color=red face="黑体">线程数 = （（线程等待时间+线程CPU时间）/线程CPU时间 ）* CPU数目</font> </p>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="Set-List-Map有什么区别"><a href="#Set-List-Map有什么区别" class="headerlink" title="Set,List,Map有什么区别"></a>Set,List,Map有什么区别</h3><p><img src="https://raw.githubusercontent.com/lizejiao/img_bed/master/images/20211012160343.png"></p>
<ul>
<li>结构特点<ol>
<li>List 和 Set 是存储单列数据的集合， Map 是存储键和值这样的双列数据的集合;</li>
<li>List中存储的数据是有顺序，并且允许重复; Map 中存储的数据是没有顺序的，其键是不能重复的，它的值是可以有重复的， Set 中存储的数据是无序的，且不允许有重复，但元素在集合中的位置由元素的hashcode决定，位置是固定的(Set集合根据 hashcode 来进行数据的存储，所以位置是固定的，但是位置不是用户可以控制的，所以对于用户来说 set 中的元素还是无序的);</li>
</ol>
</li>
</ul>
<h3 id="HashMap和HashTable有什么区别？"><a href="#HashMap和HashTable有什么区别？" class="headerlink" title="HashMap和HashTable有什么区别？"></a>HashMap和HashTable有什么区别？</h3><p>区别：</p>
<ol>
<li>HashMap方法没有synchronized修饰，线程非安全，HashTable线程安全；</li>
<li>HashMap允许key和value为null，而HashTable不允许</li>
</ol>
<h3 id="HashMap底层实现"><a href="#HashMap底层实现" class="headerlink" title="HashMap底层实现"></a>HashMap底层实现</h3><ol>
<li>jdk1.7底层采用的是数组+链表实现；jdk1.8底层采用数组+链表+红黑树实现，相对于1.7提升了查询的性能</li>
<li>链表过度到红黑树的阈值为8，红黑树退化为链表的阈值是6，原因在源码中332行给了明确解释(Poisson distribution)泊松分布，这是数学里面类似于正态分布的一个问题，这是统计学里面的一些东西</li>
<li>HashMap初始化的数组长度为16(算法导论中的除法散列法讲到 K取模m得到一个对应的位置，根据具体位置插入一个数据值，假如长度是16，长度范围就是0<del>15，取模之后我的余数为0</del>15之间，而算法导论中指出，一个不太接近2的整数幂的素数（质数：只能被1和它本身整出的数），常常是m的最好选择。但是hashMap中未采用素数，而是采用2的n次方(合数)作为数组长度)，原因为：1、更便于位置计算；2、方便做数据迁移。</li>
<li>为了保证存入的数据均匀的散列分布在数组中，需要设计良好的hash散列算法(hashMap中采用扰动函数来做的：移位和异或相关操作ConcurrentHashMap源码中684行spread方法，即：让int的高16位异或它本身)，尽可能的避免hash冲突(概率问题)，具体落到数组哪个节点并非是通过取模运算得出，而是通过与上数组长度-1即可(只需要int类型数32位的后四位参与运算)，即可得到0~15之间的数，因为取模运算效率远低于位运算，所以这也是hashMap要求底层数组长度必须为2的n次方的原因之一（ConcurrentHashMap源码中514行规定）。</li>
</ol>
<h3 id="HashMap-put流程"><a href="#HashMap-put流程" class="headerlink" title="HashMap put流程"></a>HashMap put流程</h3><ol>
<li>HashMap/ConcurrentHashMap 并不是通过构造函数创建默认空间的，而是通过put数据的时候获取到对应的数据空间的，如果数组长度是0，则通过CAS操作后初始化数组，如果有线程正在做初始化数组操作，其他线程则让出时间片</li>
<li></li>
</ol>
<h3 id="HashMap扩容流程"><a href="#HashMap扩容流程" class="headerlink" title="HashMap扩容流程"></a>HashMap扩容流程</h3><ol>
<li>hashMap规定了当我的数组快放满的时候就要开始扩容了，什么时候算是快放满？HashMap是通过扩容因子来规定的</li>
<li>HashMap规定扩容因子是0.75，如果默认长度是16，也就是说当HashMap底层数组的容量达到12的时候进行扩容操作。0.75则是根据统计学得来的。<code>private static final float LOAD_FACTOR = 0.75f;</code></li>
<li>扩容首先要创建新的数组（原来大小左移1位）ConcurrentHaspMap源码2367行开始扩容操作</li>
<li>转移旧数据到新的数组中去（怎么计算扩容后数据下标位置？）原来：h&amp;(n-1)计算下标位置，扩容后 h$(31)，原来占用4个二进制位，扩容后占用5个二进制位，所以只需要看第五位即可，如果第五位是0，扩容后的的下标跟原位置一样，如果是1，新下标位置在原数组的位置的基础上加上原来数组长度即可，这也是数组长度采用2的N次方扩容的第二个原因</li>
<li>假设原来长度是128，扩容后是256，整体扩容方式是通过多线程方式运行的，但是要保证数据不能乱，将原来数组分段，规定每个线程最少负责16个桶的迁移工作，8个线程可以并行执行，如果小于16个桶，直接单线程执行</li>
</ol>
<h3 id="为什么选择用红黑树"><a href="#为什么选择用红黑树" class="headerlink" title="为什么选择用红黑树"></a>为什么选择用红黑树</h3><p>二叉树在极端情况下会退化为链表，查询时间复杂度跟链表相似，而AVL树，SB树，红黑树，都属于平衡二叉树，尽量保持左子树和右子树的高度差不要相差太大，而这三种树的差别就在于左树和右树的高度规则不同。</p>
<ul>
<li>AVL树：严格意义平衡树，的要求左子树和右子树的高度差不能超过1，损失了部分插入性能，带来了高效的查询</li>
<li>SB树：</li>
<li>红黑树：要求最长子树不能超过最短子树的2倍即可，损失了部分查询性能，使得查询效率高于链表的同时，相比于其他树提升了插入性能，尽量做到了插入和查询的一个平衡点，而HashMap则是查多，插入少(这里的插入指的是产生Hash冲突下的插入)，所以红黑树更适合HashMap来做底层的存储结构。</li>
</ul>
<h3 id="ConcurrentHaspMap"><a href="#ConcurrentHaspMap" class="headerlink" title="ConcurrentHaspMap"></a>ConcurrentHaspMap</h3><ol>
<li>ConcurrentHaspMap是线程安全的HashMap，它底层采用大量的CAS操作</li>
</ol>
<h2 id="spring"><a href="#spring" class="headerlink" title="spring"></a>spring</h2><p>spring是一个框架，更像是一个生态环境，在我们的开发流程中，所有的框架基本上都依赖于spring，spring起到了一个IOC容器的作用，用来承载我们整体的bean对象，它帮我们处理了bean对象从创建到销毁的整个生命周期的管理，我们在使用spring的时候，可以使用配置文件，也可以使用注解的方式进行相关开发。spring框架的工作主要流程是，当我们程序开始启动之后，spring把注解或者配置文件定义好的bean对象转化成为BeanDefinitionran，然后通BeanFactoryPostProcessor完成整个的BeanDefinitionran的解析和加载过程，然后根据BeanDefinitionran通过反射的方式创建bean对象，然后进行对象初始化，包括：aware接口相关操作，BeanPostProcessor操作，Init-methord操作完成整个bean的创建过程，之后我们就可以使用了。</p>
<h3 id="Bean的初始化过程"><a href="#Bean的初始化过程" class="headerlink" title="Bean的初始化过程"></a>Bean的初始化过程</h3><img src="https://raw.githubusercontent.com/lizejiao/img_bed/master/images/20210920235247.png"  />



<h3 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h3><p><img src="https://raw.githubusercontent.com/lizejiao/img_bed/master/images/20210921185234.png"></p>
<h3 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h3><h3 id="AOP的顺序"><a href="#AOP的顺序" class="headerlink" title="AOP的顺序"></a>AOP的顺序</h3><p>  spring4和spring5是不一样的</p>
<h3 id="springMVC处理请求流程"><a href="#springMVC处理请求流程" class="headerlink" title="springMVC处理请求流程"></a>springMVC处理请求流程</h3><p><img src="https://raw.githubusercontent.com/lizejiao/img_bed/master/images/20211012154755.png"></p>
<h3 id="spring事务的传播机制"><a href="#spring事务的传播机制" class="headerlink" title="spring事务的传播机制"></a>spring事务的传播机制</h3><ol>
<li>TransactionDefinition.PROPAGATION_<strong>REQUIRED</strong>：支持当前事务，如果没有事务会创建一个新的事务</li>
<li>TransactionDefinition.PROPAGATION_<strong>SUPPORTS</strong>：支持当前事务，如果没有事务的话以非事务方式执行</li>
<li>TransactionDefinition.PROPAGATION_<strong>MANDATORY</strong>：支持当前事务，如果没有事务抛出异常</li>
<li>TransactionDefinition.PROPAGATION_<strong>REQUIRES_NEW</strong>：创建一个新的事务并挂起当前事务</li>
<li>TransactionDefinition.PROPAGATION_<strong>NOT_SUPPORTED</strong>：以非事务方式执行，如果当前存在事务则将当前事务挂起</li>
<li>TransactionDefinition.PROPAGATION_<strong>NEVER</strong>：以非事务方式进行，如果存在事务则抛出异常</li>
<li>TransactionDefinition.PROPAGATION_<strong>NESTED</strong>：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则进行与PROPAGATION_REQUIRED类似的操作。</li>
</ol>
<h2 id="RPC框架"><a href="#RPC框架" class="headerlink" title="RPC框架"></a>RPC框架</h2><h3 id="你知道的json序列化方式？"><a href="#你知道的json序列化方式？" class="headerlink" title="你知道的json序列化方式？"></a>你知道的json序列化方式？</h3><ol>
<li>谷歌的Gson</li>
<li>json-smart：号称是速度最快的JSON解析器</li>
<li>Common Lang3(3.1)的SerializationUtils</li>
<li>阿里巴巴的 FastJson、以及 Jackson</li>
</ol>
<h3 id="两个系统之间怎么交互的？"><a href="#两个系统之间怎么交互的？" class="headerlink" title="两个系统之间怎么交互的？"></a>两个系统之间怎么交互的？</h3><ol>
<li> 套接字（socket）：这是一种更为一般得进程间通信机制，它可用于网络中不同机器之间的进程间通信，应用非常广泛。</li>
<li> 可以通过RPC框架（dubbo、feign等）进行远程调用</li>
<li> 也可以引入消息队列等消息中间件作为系统之间信息交互的桥梁</li>
<li> 共享内存（shared memory）：可以说这是最有用的进程间通信方式。它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更</li>
</ol>
<h3 id="dubbo的序列化？"><a href="#dubbo的序列化？" class="headerlink" title="dubbo的序列化？"></a>dubbo的序列化？</h3><p>dubbo 支持 hession、Java 二进制序列化、json、SOAP 文本序列化多种序列化协议。 hessian 是其默认的序列化协议</p>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="网络七层模型"><a href="#网络七层模型" class="headerlink" title="网络七层模型"></a>网络七层模型</h3><ul>
<li>第一层：物理层</li>
<li>第二层：数据链路层 802.2、802.3ATM、HDLC、FRAME RELAY </li>
<li>第三层：网络层 IP、IPX、ARP、APPLETALK、ICMP </li>
<li>第四层：传输层 TCP、UDP、SPX </li>
<li>第五层：会话层 <strong>RPC</strong>、SQL、NFS 、X WINDOWS、ASP</li>
<li>第六层：表示层 ASCLL、PICT、TIFF、JPEG、 MIDI、MPEG </li>
<li>第七层：应用层 HTTP,FTP,SNMP等</li>
</ul>
<img src="https://raw.githubusercontent.com/lizejiao/img_bed/master/images/net7.png" style="zoom: 90%;" />

<ol>
<li>物理层：物理层负责最后将信息编码成电流脉冲或其它信号用于网上传输；</li>
<li>数据链路层：数据链路层通过物理网络链路􏰁供数据传输。不同的数据链路层定义了不同的网络和协 议特征,其中包括物理编址、网络拓扑结构、错误校验、数据帧序列以及流控。可以简单的理解为：规定了0和1的分包形式，确定了网络数据包的形式；</li>
<li>网络层：网络层负责在源和终点之间建立连接。可以理解为，此处需要确定计算机的位置，怎么确定？IPv4，IPv6！</li>
<li>传输层：传输层向高层提供可靠的端到端的网络数据流服务。可以理解为：每一个应用程序都会在网卡注册一个端口号，该层就是端口与端口的通信！常用的（TCP／IP）协议；</li>
<li>会话层：会话层建立、管理和终止表示层与实体之间的通信会话；建立一个连接（自动的手机信息、自动的网络寻址）;</li>
<li>表示层：表示层提供多种功能用于应用层数据编码和转化,以确保以一个系统应用层发送的信息 可以被另一个系统应用层识别;可以理解为：解决不同系统之间的通信，eg：Linux下的QQ和Windows下的QQ可以通信；</li>
<li>应用层：OSI 的应用层协议包括文件的传输、访问及管理协议(FTAM) ,以及文件虚拟终端协议(VIP)和公用管理系统信息(CMIP)等;</li>
</ol>
<h3 id="http1-0和http1-1区别"><a href="#http1-0和http1-1区别" class="headerlink" title="http1.0和http1.1区别"></a>http1.0和http1.1区别</h3><p>HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。 主要区别主要体现在：</p>
<ol>
<li><strong>缓存处理</strong>，在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</li>
<li><strong>带宽优化及网络连接的使用</strong>，HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li>
<li><strong>错误通知的管理</strong>，在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</li>
<li><strong>Host头处理</strong>，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。</li>
<li><strong>长连接</strong>，HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。</li>
</ol>
<h3 id="HTTPS与HTTP的一些区别"><a href="#HTTPS与HTTP的一些区别" class="headerlink" title="HTTPS与HTTP的一些区别"></a>HTTPS与HTTP的一些区别</h3><ul>
<li>HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。</li>
<li>HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。</li>
<li>HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li>
<li>HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。</li>
</ul>
<h3 id="http三次握手四次挥手"><a href="#http三次握手四次挥手" class="headerlink" title="http三次握手四次挥手"></a>http三次握手四次挥手</h3><p>其实这么说是不太准确的，应该说是tcp协议建立连接要3次握手，断开连接要4次挥手，而http是基于tcp协议的，所以通常我们也这么说，tcp可以提供全双工的数据流传输服务</p>
<h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><ol>
<li>TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了LISTEN（监听）状态；</li>
<li>TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这是报文首部中的同部位SYN=1，同时选择一个初始序列号 seq=x ，此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。</li>
<li>TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号是ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时，TCP服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号。</li>
<li>TCP客户进程收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，自己的序列号seq=x+1，此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。</li>
<li>当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。</li>
</ol>
<h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><h3 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h3><ul>
<li>提供者(Provider)启动时，会向注册中心写入自己的元数据信息(调用方式)。</li>
<li>消费者(Consumer)启动时，也会在注册中心写入自己的元数据信息，并且订阅服务提供者，路由和配置元数据的信息。</li>
<li>服务治理中心(duubo-admin)启动时，会同时订阅所有消费者，提供者，路由和配置元数据的信息。</li>
<li>当提供者离开或者新提供者加入时，注册中心发现变化会通知消费者和服务治理中心。</li>
</ul>
<h2 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h2><h3 id="NIO三大核心组件"><a href="#NIO三大核心组件" class="headerlink" title="NIO三大核心组件"></a>NIO三大核心组件</h3><p> <strong>Channel(通道)， Buffer(缓冲区)，Selector(多路复用器)</strong></p>
<ol>
<li>channel 类似于流，每个 channel 对应一个 buffer缓冲区，buffer 底层就是个数组</li>
<li>channel 会注册到 selector 上，由 selector 根据 channel 读写事件的发生将其交由某个空闲的线程处理</li>
<li>NIO 的 Buffer 和 channel 都是既可以读也可以写</li>
</ol>
<h3 id="Netty线程模型"><a href="#Netty线程模型" class="headerlink" title="Netty线程模型"></a>Netty线程模型</h3><p>Netty通过Reactor模型基于多路复用器接收并处理用户请求，内部实现boss和work两个线程池，其中boss的线程负责处理请求的accept事件，当接收到accept事件的请求时，把对应的socket封装到一个NioSocketChannel中，并交给work线程池，其中work线程池负责请求的read和write事件，交由对应的Handler处理。</p>
<img src="https://raw.githubusercontent.com/lizejiao/img_bed/master/images/Netty.png" style="zoom: 60%;" />

<img src="https://raw.githubusercontent.com/lizejiao/img_bed/master/images/Netty2.png" style="zoom: 80%;"/> 

<ol>
<li>Netty 抽象出两组线程池BossGroup和WorkerGroup，BossGroup专门负责接收客户端的连接, WorkerGroup专门负责网络的读写</li>
<li>BossGroup和WorkerGroup类型都是NioEventLoopGroup</li>
<li>NioEventLoopGroup 相当于一个事件循环<strong>线程组</strong>, 这个组中含有多个事件循环线程 ， 每一个事件循环线程是NioEventLoop</li>
<li>每个NioEventLoop都有一个selector , 用于监听注册在其上的socketChannel的网络通讯</li>
<li> 每个BossNioEventLoop线程内部循环执行的步骤有 3 步</li>
<li>处理accept事件 , 与client 建立连接 , 生成 NioSocketChannel </li>
<li>将NioSocketChannel注册到某个worker  NIOEventLoop上的selector</li>
<li>处理任务队列的任务 ， 即runAllTasks</li>
<li>每个workerNIOEventLoop线程循环执行的步骤<ol>
<li>轮询注册到自己selector上的所有NioSocketChannel 的read, write事件</li>
<li>处理 I/O 事件， 即read , write 事件， 在对应NioSocketChannel 处理业务</li>
<li>runAllTasks处理任务队列TaskQueue的任务 ，一些耗时的业务处理一般可以放入TaskQueue中慢慢处理，这样不影响数据在 pipeline 中的流动处理</li>
</ol>
</li>
</ol>
<h3 id="Netty模块组件"><a href="#Netty模块组件" class="headerlink" title="Netty模块组件"></a>Netty模块组件</h3><ul>
<li><p><strong>Bootstrap、ServerBootstrap</strong>：Bootstrap 意思是引导，一个 Netty 应用通常由一个 Bootstrap 开始，主要作用是配置整个 Netty 程序，串联各个组件，Netty 中 Bootstrap 类是客户端程序的启动引导类，ServerBootstrap 是服务端启动引导类。</p>
</li>
<li><p><strong>Future、ChannelFuture</strong>：正如前面介绍，在 Netty 中所有的 IO 操作都是异步的，不能立刻得知消息是否被正确处理。但是可以过一会等它执行完成或者直接注册一个监听，具体的实现就是通过 Future 和 ChannelFutures，他们可以注册一个监听，当操作执行成功或失败时监听会自动触发注册的监听事件。</p>
</li>
<li><p><strong>Channel</strong>：Netty 网络通信的组件，能够用于执行网络 I/O 操作。Channel 为用户提供：</p>
<ol>
<li><p>当前网络连接的通道的状态（例如是否打开？是否已连接？）</p>
</li>
<li><p>网络连接的配置参数 （例如接收缓冲区大小）</p>
</li>
<li><p>提供异步的网络 I/O 操作(如建立连接，读写，绑定端口)，异步调用意味着任何 I/O 调用都将立即返回，并且不保证在调用结束时所请求的 I/O 操作已完成。</p>
</li>
<li><p>调用立即返回一个 ChannelFuture 实例，通过注册监听器到 ChannelFuture 上，可以 I/O 操作成功、失败或取消时回调通知调用方。</p>
</li>
<li><p>支持关联 I/O 操作与对应的处理程序。</p>
</li>
<li><p>不同协议、不同的阻塞类型的连接都有不同的 Channel 类型与之对应。</p>
</li>
<li><pre><code>NioSocketChannel，异步的客户端 TCP Socket 连接。
NioServerSocketChannel，异步的服务器端 TCP Socket 连接。
NioDatagramChannel，异步的 UDP 连接。
NioSctpChannel，异步的客户端 Sctp 连接。
NioSctpServerChannel，异步的 Sctp 服务器端连接。
这些通道涵盖了 UDP 和 TCP 网络 IO 以及文件 IO。
</code></pre>
</li>
</ol>
</li>
<li><p><strong>Selector</strong>：Netty 基于 Selector 对象实现 I/O 多路复用，通过 Selector 一个线程可以监听多个连接的 Channel 事件。当向一个 Selector 中注册 Channel 后，Selector 内部的机制就可以自动不断地查询(Select) 这些注册的 Channel 是否有已就绪的 I/O 事件（例如可读，可写，网络连接完成等），这样程序就可以很简单地使用一个线程高效地管理多个 Channel 。</p>
</li>
<li><p><strong>NioEventLoop</strong>：NioEventLoop 中维护了一个线程和任务队列，支持异步提交执行任务，线程启动时会调用 NioEventLoop 的 run 方法，执行 I/O 任务和非 I/O 任务：I/O 任务，即 selectionKey 中 ready 的事件，如 accept、connect、read、write 等，由 processSelectedKeys 方法触发。非 IO 任务，添加到 taskQueue 中的任务，如 register0、bind0 等任务，由 runAllTasks 方法触发。</p>
</li>
<li><p><strong>NioEventLoopGroup</strong>：NioEventLoopGroup，主要管理 eventLoop 的生命周期，可以理解为一个线程池，内部维护了一组线程，每个线程(NioEventLoop)负责处理多个 Channel 上的事件，而一个 Channel 只对应于一个线程。</p>
</li>
<li><p><strong>ChannelHandler</strong>：ChannelHandler 是一个接口，处理 I/O 事件或拦截 I/O 操作，并将其转发到其 ChannelPipeline(业务处理链)中的下一个处理程序。</p>
</li>
<li><p><strong>ChannelHandlerContext</strong>：保存 Channel 相关的所有上下文信息，同时关联一个 ChannelHandler 对象。</p>
</li>
<li><p><strong>ChannelPipline</strong>：保存 ChannelHandler 的 List，用于处理或拦截 Channel 的入站事件和出站操作。ChannelPipeline 实现了一种高级形式的拦截过滤器模式，使用户可以完全控制事件的处理方式，以及 Channel 中各个的 ChannelHandler 如何相互交互。在 Netty 中每个 Channel 都有且仅有一个 ChannelPipeline 与之对应，它们的组成关系如下：</p>
</li>
</ul>
<img src="https://raw.githubusercontent.com/lizejiao/img_bed/master/images/ChannelPipline.png" style="zoom: 60%;"/> 

<p>一个 Channel 包含了一个 ChannelPipeline，而 ChannelPipeline 中又维护了一个由 ChannelHandlerContext 组成的双向链表，并且每个 ChannelHandlerContext 中又关联着一个 ChannelHandler。read事件(入站事件)和write事件(出站事件)在一个双向链表中，入站事件会从链表 head 往后传递到最后一个入站的 handler，出站事件会从链表 tail 往前传递到最前一个出站的 handler，两种类型的 handler 互不干扰。</p>
<h3 id="Netty粘包拆包"><a href="#Netty粘包拆包" class="headerlink" title="Netty粘包拆包"></a>Netty粘包拆包</h3><p>TCP是一个流协议，就是没有界限的一长串二进制数据。TCP作为传输层协议并不不了解上层业务数据的具体含义，它会根据TCP缓冲区的实际情况进行数据包的划分，所以在业务上认为是一个完整的包，可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这就是所谓的TCP粘包和拆包问题。面向流的通信是无消息保护边界的。</p>
<p><strong>解决方案</strong></p>
<ol>
<li><p>消息定长度，传输的数据大小固定长度，例如每段的长度固定为100字节，如果不够空位补空格</p>
</li>
<li><p>在数据包尾部添加特殊分隔符，比如下划线，中划线等，这种方法简单易行，但选择分隔符的时候一定要注意每条数据的内部一定不能出现分隔符。</p>
</li>
<li><p>发送长度：发送每条数据的时候，将数据的长度一并发送，比如可以选择每条数据的前4位是数据的长度，应用层处理时可以根据长度来判断每条数据的开始和结束。</p>
<p>Netty提供了多个解码器，可以进行分包的操作，如下：</p>
<ol>
<li>LineBasedFrameDecoder （回车换行分包）</li>
<li>DelimiterBasedFrameDecoder（特殊分隔符分包）</li>
<li>FixedLengthFrameDecoder（固定长度报文来分包）</li>
</ol>
</li>
</ol>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="ACID理论"><a href="#ACID理论" class="headerlink" title="ACID理论"></a>ACID理论</h3><p>​        事务处理几乎是每一个信息系统中都会涉及到的问题，它存在的意义就是保证系统中的数据是正确的，不同数据间不会产生矛盾，也就是保证数据状态的一致性（Consistency），理论上，要达成这个目标需要三方面的共同努力：</p>
<ol>
<li>原子性（Atomic）：在同一项业务处理过程中，事务保证了多个对数据的修改，要么同时成功，要么一起被撤销。原子性是由undolog日志来保证的，它记录了需要回滚的日志信息，事务回滚时，撤销已经执行成功的sql。</li>
<li>隔离性（Isolation）：在不同的业务处理过程中，事务保证了各自业务正在读、写的数据互相独立，不会彼此影响。隔离性是由MVCC来保证的。</li>
<li>持久性（Durability）：事务应当保证所有被成功提交的数据修改都能够正确地被持久化，不丢失数据。持久性由redolog来保证的，mysql修改数据的时候会在redolog中记录一份日志数据，就算数据没有保存成功，只要日志保存成功了，数据仍然不会丢失。</li>
</ol>
<p>以上就是事务的“ACID”的概念提法。我自己对这种已经形成习惯的“ACID”的提法是不太认同的，因为这四种特性并不正交，<strong>A、I、D 是手段，C 是目的</strong>，完全是为了拼凑个单词缩写才弄到一块去，误导的弊端已经超过了易于传播的好处。</p>
<h3 id="Mysql索引结构"><a href="#Mysql索引结构" class="headerlink" title="Mysql索引结构"></a>Mysql索引结构</h3><p>mysql的索引结构有：二叉树、红黑树、hash表、BTree、B+Tree</p>
<ul>
<li>二叉树</li>
</ul>
<img src="https://raw.githubusercontent.com/lizejiao/img_bed/master/images/clipboard.png" style="zoom: 33%;" /> 

<ul>
<li>Hash表</li>
<li>B+Tree</li>
</ul>
<h3 id="InnoDB和MyISAM区别"><a href="#InnoDB和MyISAM区别" class="headerlink" title="InnoDB和MyISAM区别"></a>InnoDB和MyISAM区别</h3><table>
<thead>
<tr>
<th>区别</th>
<th>InnoDB</th>
<th>MyISAM</th>
</tr>
</thead>
<tbody><tr>
<td>事务</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>外键</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>索引</td>
<td>聚簇索引和非聚簇索引</td>
<td>非聚簇索引</td>
</tr>
<tr>
<td>行锁</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>表锁</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>存储文件</td>
<td>frm(表结构)，ibd(数据和索引)</td>
<td>frm，myi(索引文件)，myd(数据文件)</td>
</tr>
<tr>
<td>具体行数</td>
<td>全表扫描统计行数</td>
<td>通过变量保存行数</td>
</tr>
</tbody></table>
<ul>
<li>MyISAM不支持事务，在执行查询语句SELECT前，会自动给涉及的所有表加读锁,在执行update、insert、delete操作会自动给涉及的表加写锁。</li>
<li>InnoDB在执行查询语句SELECT时(非串行隔离级别)，(因为有mvcc机制)不会加锁。但是update、insert、delete操作会加行锁。简而言之，就是<strong>读锁会阻塞写，但是不会阻塞读。而写锁则会把读和写都阻塞</strong>。</li>
</ul>
<h3 id="B树和B-数的区别"><a href="#B树和B-数的区别" class="headerlink" title="B树和B+数的区别"></a>B树和B+数的区别</h3><p><strong>B-Tree</strong></p>
<img src="https://raw.githubusercontent.com/lizejiao/img_bed/master/images/BTree.png" style="zoom: 50%;" />

<p><strong>B+Tree(B-Tree变种)</strong></p>
<img src="https://raw.githubusercontent.com/lizejiao/img_bed/master/images/B%2BTree.png" style="zoom:50%;" />

<ol>
<li>B+Tree非叶子节点不存储data，只存储冗余索引，叶子节点包含所有索引字段  。优点：可以放更多的索引，BTree非叶子节点会存储索引和数据</li>
<li>B+Tree叶子节点用指针连接。优点：提高区间访问的性能（范围查找），BTree叶子节点指针为空</li>
</ol>
<h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><table>
<thead>
<tr>
<th align="left">事务隔离级别</th>
<th align="left">脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="left">读未提交（read-uncomm</td>
<td align="left"></td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">读已提交（read-committed）</td>
<td align="left">否</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td align="left">可重复读（repeatable-read）  <font color=red face="黑体">mysql默认</font></td>
<td align="left">否</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td align="left">串行化（serializable）</td>
<td align="left">否</td>
<td>否</td>
<td>否</td>
</tr>
</tbody></table>
<ul>
<li>Mysql在可重复度隔离级别下通过MVCC保证事务隔离性</li>
<li>幻读是指当一个事务A读取某一个范围的数据时，另一个事务B在这个范围插入行，A事务再次读取这个范围数据时，会产生幻读</li>
</ul>
<h3 id="Mysql幻读是怎么解决的"><a href="#Mysql幻读是怎么解决的" class="headerlink" title="Mysql幻读是怎么解决的"></a>Mysql幻读是怎么解决的</h3><p>首先要确认一下幻读是怎么产生的，先弄清两个概念，那就是当前读和快照读</p>
<ul>
<li>当前读</li>
</ul>
<p>像select lock in share mode(共享锁)，select for update，update，insert，delete（排他锁）这些操作都是一种当前读，为什么叫当前读？就是他读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取记录进行加锁</p>
<ul>
<li>快照读</li>
</ul>
<p>​    像不加锁的select操作就是快照读，也就是不加锁的非阻塞读；快照读的前提是隔离级别不是串行化，串行级别的快照读会退化成当前读，快照读的实现是基于多版本并发控制，也就是MVCC，可以认为MVCC是行锁的一个变种，但是很多情况下避免加锁操作，快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本</p>
<p><font color=red face="黑体">如果只有快照读是不会产生幻读问题，只有快照读和当前读一起使用的时候才会产生幻读。</font></p>
<p>Mysql在可重复度隔离级别下可以通过MVCC和临键锁（记录锁+间隙锁）解决幻读问题。</p>
<h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><p>对于mvcc的理解，可以从数据库三种并发场景来说</p>
<ol>
<li>第一种是读和读的并发：就是两个线程A和B同时进行读操作，这种情况下呢，不会产生任何的并发问题</li>
<li>第二种是读写并发：就是说两个线程A和B在同一时刻分别进行读写操作，这种情况下可能会对数据库的数据造成一些问题，第一、事务隔离性问题；第二、会造成脏读，幻读，不可重复读的问题</li>
<li>第三种是写和写的并发：就是两个线程A和B同时进行写操作，这种情况下可能会存在数据更新的丢失问题</li>
<li>MVCC就是为了解决事务操作中并发安全问题的，无锁并发控制技术，全称就是：多版本并发控制，他是通过数据库记录中的隐式字段Undo日志和ReadView来实现的，MVCC主要解决三个问题：第一、通过MVCC可以解决读写并发阻塞问题，从而提高数据库的并发处理能力；第二、MVCC采用的是乐观锁的方式实现，降低了死锁的概率；第三、解决了一致性读的问题，也就是事务启动的时候，根据某个条件去读取到的数据，知道事务结束的时候再去执行相同条件，还是读到同一份数据，不会发生变化变化，而我们在使用MVCC的时候，一般是根据业务场景来选择组合搭配，乐观锁或者悲观锁，MVCC用来解决读写冲突，而乐观锁悲观锁用来解决写和写的冲突，从而最大程度去提高数据库的并发性能。</li>
</ol>
<h3 id="什么场景会引发幻读"><a href="#什么场景会引发幻读" class="headerlink" title="什么场景会引发幻读"></a>什么场景会引发幻读</h3><p>幻读是指在同一个事务中，存在前后两次查询同一个范围的数据，但是第二次查询却看到了第一次查询没看到的行，一般情况下特指事务执行中新增的其他行。</p>
<h3 id="sql在mysql的执行过程"><a href="#sql在mysql的执行过程" class="headerlink" title="sql在mysql的执行过程"></a>sql在mysql的执行过程</h3><img src="https://raw.githubusercontent.com/lizejiao/img_bed/master/images/20211116173949.png"/> 

<h3 id="事务怎么保证一致性"><a href="#事务怎么保证一致性" class="headerlink" title="事务怎么保证一致性"></a>事务怎么保证一致性</h3><p>redo log是InnoDB存储引擎层的日志，又称重做日志文件，用于记录事务操作的变化，记录的是数据修改之后的值，不管事务是否提交都会记录下来。如数据库掉电，InnoDB存储引擎会使用redo log恢复到掉电前的时刻，以此来保证数据的完整性。在一条更新语句进行执行的时候，InnoDB引擎会把更新记录写到redo log日志中，然后更新内存，此时算是语句执行完了，然后在空闲的时候或者是按照设定的更新策略将redo log中的内容更新到磁盘中，这里涉及到<code>WAL</code>即<code>Write Ahead logging</code>技术，他的关键点是先写日志，再写磁盘。</p>
<h3 id="binlog-、undo-、redo"><a href="#binlog-、undo-、redo" class="headerlink" title="binlog 、undo 、redo"></a>binlog 、undo 、redo</h3><ol>
<li>redo log通常是物理日志，记录的是数据页的物理修改，而不是某一行或某几行修改成怎样怎样，它用来恢复提交后的物理数据页(恢复数据页，且只能恢复到最后一次提交的位置)。</li>
<li>undo用来回滚行记录到某个版本。undo log一般是逻辑日志，根据每行记录进行记录。</li>
<li>二进制日志（binlog）</li>
</ol>
<h3 id="聚簇和非聚簇索引"><a href="#聚簇和非聚簇索引" class="headerlink" title="聚簇和非聚簇索引"></a>聚簇和非聚簇索引</h3><ul>
<li><p>聚簇索引也好、非聚簇索引也好，都是索引的一个基本分类，他们最本质的点在于存储引擎，如果我们用InnoDB存储引擎，他的存储文件是.frm和.ibd文件，这意味着InnoDB里面存放数据文件和索引文件是在同一个文件.ibd文件里，所以他的数据和索引是放在一起存储的，这种存储方式称之为聚簇索引。InnerDB在进行数据插入的时候，必须要绑定一个索引列上，默认是主键，如果没有主键，会选择唯一键，如果没有唯一键，会生成6字节的rowid，跟数据绑定在一起</p>
</li>
<li><p>像MyISAM存储引擎，他存储文件是.frm，.myi(索引文件)，.myd(数据文件)文件，他是把索引文件和数据文件分开存储的，这种存储方式称为非聚簇索引，InnoDB既有聚簇索引也有非聚簇索引，MyISAM只有非聚簇索引</p>
</li>
</ul>
<h3 id="数据库慢sql优化"><a href="#数据库慢sql优化" class="headerlink" title="数据库慢sql优化"></a>数据库慢sql优化</h3><ul>
<li><p>尽量创建联合索引,</p>
</li>
<li><p>多表关联查询：所有的join查询，都是通过嵌套循环连接完成的，嵌套循环join有三个变种：</p>
<ol>
<li>Simple Nested-Loop Join ：从表中取出匹配所有列，匹配后合并，开销大。select * from t1,t2(笛卡尔积)</li>
<li>Index Nested-Loop Join ： 索引嵌套连接，由于非驱动表有索引，通过索引减少比较，加速查询，我们再做关联查询的时候必须要求<strong>关联字段有索引</strong>；查询过程：1、根据关联字段索引进行查找，在索引上找到符合的值后再回表查询，只有匹配到索引后才会回表，至于驱动表选择，Mysql优化器一般会选择记录少的作为驱动表，但是当SQL特别复杂的时候不排除会选择错。2、如果非驱动表关联主键，性能会非常高，如果不是主键，关联后返回行数特别多的话，效率也会很低，要多次回表操作。</li>
<li>Block Nested-Loop Join：当连接条件没有索引的时候会用这种方式关联，比Simple Nested-Loop Join 多了一个中间处理过程，有些情况下，可能join的列就是没有索引，那么MySQL会选择Block Nested-Loop Join算法，其实就是使用Join buffer将驱动表的查询Join相关列都缓存到Join buffer中，然后批量与非驱动表进行比较，降低了非驱动表的访问频次。查看join buffer:<code>show variables like &#39;join_buffer_size;&#39;</code> </li>
</ol>
</li>
</ul>
<h3 id="索引失效的情况"><a href="#索引失效的情况" class="headerlink" title="索引失效的情况"></a>索引失效的情况</h3><p>谈到索引主要从两方面来分析：IO 和数据结构：不管索引数据还是行数据，都是存在磁盘里面的，我们尽可能少的取出数据</p>
<ul>
<li>IO—–&gt;读取次数少、量少——&gt;分块读取——&gt;局部性原理、磁盘预读</li>
<li>数据结构——&gt;B+树——&gt;二叉树、AVL树、红黑树、B树</li>
</ul>
<ol>
<li>组合索引不遵循最左匹配原则</li>
<li>组合索引前面索引列使用范围查询(&lt;,&gt;,like),会导致后续索引失效；</li>
<li>不要在索引上做任何操作（计算，函数，类型转换）</li>
<li>is null和is not null 无法使用索引</li>
<li>尽量少使用or操作符，否则连接时索引会失效</li>
<li>字符串不添加引号会导致索引失效（隐式类型转换）</li>
<li>两表关联使用的条件字段中字段的长度，编码不一致会导致索引失效</li>
<li>like语句中，以%开头的模糊查询会导致索引失效</li>
<li>如果mysql中使用全表扫描比索引快，也会导致索引失效 （force index:强制使用索引）</li>
</ol>
<h3 id="如何做分库分表"><a href="#如何做分库分表" class="headerlink" title="如何做分库分表"></a>如何做分库分表</h3><p>​    使用mycat或者shardingsphere中间件做分库分表，选择合适的中间件，水平分库，水平分表，垂直分库，垂直分表，在进行分库分表的时候尽量遵循以下原则</p>
<ol>
<li>能不切分尽量不要切分</li>
<li>如果要切分一定要选择合适的切分规则，提前规划好</li>
<li>如果切分尽量通过数据冗余或表分组来降低跨库Join的可能</li>
<li>由于数据库中间件对数据Join实现的优劣难以把握，而且实现高性能难度极大，业务尽量少使用多表Join</li>
</ol>
<h3 id="Mysql主从复制"><a href="#Mysql主从复制" class="headerlink" title="Mysql主从复制"></a>Mysql主从复制</h3><ol>
<li>从库通过手工执行change master to 语句连接主库，提供连接用户信息（userName、passWord、port、ip）二进制日志的起点位置（file名 position号）；start slave</li>
<li>从库的IO线程和主库的dump线程建立连接</li>
<li>从库根据change master to 语句提供的file名和position号，IO线程向主库发起binlog请求</li>
<li>主库dump线程根据从库请求，将本地binlog以events的方式发给从库IO线程</li>
<li>从库IO线程接受binlog events，并放到本地relay-log中(顺序IO)，传送过来的信息会记录到master.info中</li>
<li>从库SQL线程应用relay-log,并且把应用过的记录到relay-log.info中，默认情况下，已经应用过的relay会自动被清理purge</li>
</ol>
<img src="https://raw.githubusercontent.com/lizejiao/img_bed/master/images/mysql001.png" style="zoom: 80%;" />



<h2 id="缓存-Redis-ES"><a href="#缓存-Redis-ES" class="headerlink" title="缓存:Redis/ES"></a>缓存:Redis/ES</h2><h3 id="Redis数据类型"><a href="#Redis数据类型" class="headerlink" title="Redis数据类型"></a>Redis数据类型</h3><img src="https://raw.githubusercontent.com/lizejiao/img_bed/master/images/redisdata.jpg" style="zoom: 67%;" />

<ol>
<li><p><strong>String</strong></p>
</li>
<li><p><strong>Hash</strong></p>
</li>
<li><p><strong>List</strong>：类似于数组</p>
</li>
<li><p><strong>Set</strong>：无序集合 用户列表，求集合的交集，并集等操作</p>
</li>
<li><p><strong>ZSet</strong>：有序集合</p>
<ul>
<li><p>1）点击新闻：ZINCRBY  hotNews:20190819  1  守护香港</p>
</li>
<li><p>2）展示当日排行前十：ZREVRANGE  hotNews:20190819  0  9  WITHSCORES </p>
</li>
<li><p>3）七日搜索榜单计算：ZUNIONSTORE  hotNews:20190813-20190819  7  hotNews:20190813  hotNews:20190814… hotNews:20190819</p>
</li>
<li><p>4）展示七日排行前十：ZREVRANGE hotNews:20190813-20190819  0  9  WITHSCORES</p>
</li>
</ul>
</li>
</ol>
<img src="https://raw.githubusercontent.com/lizejiao/img_bed/master/images/redis-set.png" style="zoom: 80%;" />

<h3 id="Redis单线程模型"><a href="#Redis单线程模型" class="headerlink" title="Redis单线程模型"></a>Redis单线程模型</h3><p>Redis基于Reactor模式开发的网络事件处理器，这个文件事件处理器是单线程的，采用IO多路复用机制监听多个Socker，根据Socker上的事件类型选择对应的事件处理器处理这个事件，可以实现高性能的网络通信。文件事件处理器包含4个部分，多个Socker，IO多路复用程序，文件事件分派器和事件处理器(命令请求处理器，命令回复处理器，链接应答处理器)，多个Socket可能并发产生不同操作，每个操作对应不同的文件事件，但是IO多路复用会监听多个Socket，会将Socket放入一个队列，每次从队列中取出一个Socket给时间分派器，时间分派器把Socket给对应的事件处理器。</p>
<p>单线程快的原因：1.纯内存操作；2.核心是基于非阻塞的IO多路复用机制；3.单线程反而避免多线程的频繁上下文切换</p>
<h3 id="分布式锁怎么实现的？"><a href="#分布式锁怎么实现的？" class="headerlink" title="分布式锁怎么实现的？"></a>分布式锁怎么实现的？</h3><ol>
<li>基于数据库实现分布式锁：唯一索引，状态机唯一联合索引</li>
<li>基于缓存（Redis等）实现分布式锁：SET key value NX PX 30000</li>
<li>基于Zookeeper实现分布式锁；</li>
</ol>
<h3 id="setnx用到的参数"><a href="#setnx用到的参数" class="headerlink" title="setnx用到的参数"></a>setnx用到的参数</h3><p><code>SET key value NX PX 30000</code></p>
<p>第三个参数：把key、value set到redis中的策略</p>
<ul>
<li>  nx ： not exists, 只有key 不存在时才把key value set 到redis</li>
<li>  xx ： is exists ，只有 key 存在是，才把key value set 到redis</li>
</ul>
<p>第四个参数：过期时间单位</p>
<ul>
<li>  ex ：seconds 秒</li>
<li>  px : milliseconds 毫秒</li>
</ul>
<p>使用其他值，抛出 异常 ： redis.clients.jedis.exceptions.JedisDataException : ERR syntax error </p>
<p>第五个参数：有两种可选的值，</p>
<p>int 和long 的time，都是过期时间 ，expx 参数是px的时候，使用long类型的参数，可以表示更多时间</p>
<h3 id="缓存穿透，击穿，雪崩"><a href="#缓存穿透，击穿，雪崩" class="headerlink" title="缓存穿透，击穿，雪崩"></a>缓存穿透，击穿，雪崩</h3><ul>
<li><font color='red'>缓存雪崩</font>：缓存同一时间大面积失效，后面请求都落到数据库上，造成大量请求直接打到数据库。<ol>
<li>过期时间随机，防止同一时间大量数据过期</li>
<li>缓存预热：项目启动加载缓存到redis</li>
<li>互斥锁：修改的时候只允许一个线程修改数据库，其他读写线程等待</li>
<li>加相应缓存标记，记录缓存是否失效，如果失效，更新缓存(内存消耗大，一般不用)</li>
</ol>
</li>
<li><font color='red'>缓存穿透</font>：指数据库没有数据，导致请求落到数据库上<ol>
<li>接口层增加校验，对id进行规则拦截</li>
<li>缓存取不到数据，设置null值到缓存，设置短时间超时，防止网络攻击</li>
<li>布隆过滤器，所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据就会被这个bitmap拦截</li>
</ol>
</li>
<li><font color='red'>缓存击穿</font>：缓存没有，数据库中有数据（一般是缓存时间到期），并发用户特别多，同时大量请求落到数据库，缓存击穿指并发查询同一条数据，缓存雪崩是不同数据都过期<ol>
<li>key不过期</li>
<li>加互斥锁</li>
</ol>
</li>
</ul>
<h3 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h3><ol>
<li>RDB快照(snapshot)<ol>
<li>Redis 将内存数据快照保存在名字为 dump.rdb 的二进制文件中。可以对 Redis 进行设置， 让它在“ N 秒内数据集至少有 M 个改动”这一条件被满足时， 自动保存一次数据；**# save 60 1000    //** (60秒改1000次进行一次RDB持久化)关闭RDB只需要将所有的save保存策略注释掉即可。</li>
<li>问题：会阻塞客户端命令。</li>
<li>还可以手动执行命令生成RDB快照，进入redis客户端执行命令<strong>save</strong>或<strong>bgsave</strong>可以生成dump.rdb文件，每次命令执行都会将所有redis内存快照到一个新的rdb文件里，并覆盖原有rdb快照文件。</li>
<li><strong>bgsave的写时复制(COW)机制</strong>：Redis 借助操作系统提供的写时复制技术（Copy-On-Write, COW），在生成快照的同时，依然可以正常处理写命令。bgsave 子进程是由主线程 fork 生成的，可以共享主线程的所有内存数据。bgsave 子进程运行后，开始读取主线程的内存数据，并把它们写入 RDB 文件。此时，如果主线程对这些数据也都是读操作，那么，主线程和 bgsave 子进程相互不影响。但是，如果主线程要修改一块数据，那么，这块数据就会被复制一份，生成该数据的副本。然后，bgsave 子进程会把这个副本数据写入 RDB 文件，在这个过程中，主线程仍然可以修改原来的数据。</li>
</ol>
</li>
<li>AOF(append-only file)<ol>
<li>如果 Redis 因为某些原因而造成故障停机， 那么服务器将丢失最近写入、且仍未保存到快照中的那些数据。从 1.1 版本开始， Redis 增加了一种完全耐久的持久化方式： AOF 持久化，将<strong>修改的</strong>每一条指令记录进文件appendonly.aof中(先写入os cache，每隔一段时间fsync到磁盘)</li>
</ol>
</li>
</ol>
<h3 id="缓存与数据库数据一致性"><a href="#缓存与数据库数据一致性" class="headerlink" title="缓存与数据库数据一致性"></a>缓存与数据库数据一致性</h3><img src="https://raw.githubusercontent.com/lizejiao/img_bed/master/images/redis-db.png" style="zoom:67%;" />

<p>解决方案：</p>
<ol>
<li>对于并发几率很小的数据(如个人维度的订单数据、用户数据等)，这种几乎不用考虑这个问题，很少会发生缓存不一致，可以给缓存数据加上过期时间，每隔一段时间触发读的主动更新即可。</li>
<li>就算并发很高，如果业务上能容忍短时间的缓存数据不一致(如商品名称，商品分类菜单等)，缓存加上过期时间依然可以解决大部分业务对于缓存的要求。</li>
<li>如果不能容忍缓存数据不一致，可以通过加<strong>读写锁</strong>保证并发读写或写写的时候按顺序排好队，<strong>读读的时候相当于无锁</strong>。</li>
<li>也可以用阿里开源的canal通过监听数据库的binlog日志及时的去修改缓存，但是引入了新的中间件，增加了系统的复杂度。</li>
</ol>
<h3 id="ES简介"><a href="#ES简介" class="headerlink" title="ES简介"></a>ES简介</h3><p>ES他是建立在全文搜索引擎库ApacheLucene基础上的一个开源搜索和分析引擎，ES本身具有一个分布式存储，检索速度快的特性，所以我们经常用它去实现全文检索这一类的场景，比如像网站搜索，公司内部用ELK做日志聚集和检索，来去快速查找服务器的日志记录，去定位问题，基本上涉及到TB级别的数据场景，用ES是一个比较好的选择</p>
<h4 id="ES查询快的原因"><a href="#ES查询快的原因" class="headerlink" title="ES查询快的原因"></a>ES查询快的原因</h4><ol>
<li>第一、Lucene是擅长管理大量的索引数据的，另一方面他会对数据进行分词以后在保存索引，这样能搞提升数据的检索效率</li>
<li>第二、ES采用倒排索引，所谓倒排索引，就是通过属性值来确定数据记录的位置的索引，来避免全表扫描这样一个问题，</li>
<li>第三、ES采用分片存储机制</li>
<li>第四、ES扩展性好，我们可以水平扩展增加服务器，提升ES处理性能，可以达到百台服务器节点扩展</li>
<li>第五、ES内部提供了数据汇总和索引生命周期管理的一些功能，可以方便我们更加高效的存储和搜索数据</li>
</ol>
<h4 id="使用ES注意事项"><a href="#使用ES注意事项" class="headerlink" title="使用ES注意事项"></a>使用ES注意事项</h4><ol>
<li>ES里面不建议使用复杂的关联查询，会对性能影响很大</li>
<li>避免深度分页查询，因为ES分页是支持front和size参数，在查询的时候，每个分片必须构造一个长度为front加size的优先队列，然后回传到网关节点，网关节点再对这些队列进行排序再找到正确的size文档。而当front足够大的时候容易造成OOM以及网络传输性能差的一些问题</li>
</ol>
<h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p><img src="https://raw.githubusercontent.com/lizejiao/img_bed/master/images/MQ.png"></p>
<h4 id="Rabbitmq生产高可用怎么实现的"><a href="#Rabbitmq生产高可用怎么实现的" class="headerlink" title="Rabbitmq生产高可用怎么实现的"></a>Rabbitmq生产高可用怎么实现的</h4><ol>
<li>生产部署为集群模式：避免单机模式下MQ服务器挂了导致服务不可用，还可以承载更高的并发量，但是集群模式有个问题，就是在哪个节点上创建队列，该队列只会存在该节点上，其他集群节点不会备份该队列，一旦该节点宕机，该队列中的消息就会丢失(亲测设置持久化也丢失)</li>
<li>使用镜像队列：可以解决集群模式下，每个机器上只有一个队列的问题，让消息在其他节点再备份一份。开启方式：任何节点添加policy策略即可，该集群就具有镜像队列能力，可设置备份的份数和备份队列规则，即使其中一个节点宕机，也会保证整个集群中保存2份</li>
<li>高可用负载均衡：haproxy+keepalive，nginx，lvs等实现高可用负载均衡</li>
<li>其他：Federation Exchange联邦交换机插件解决两地接受消息确认消息延迟问题，也可以用Shovel来做数据同步，需要安装插件</li>
</ol>
<h3 id="zookeeper"><a href="#zookeeper" class="headerlink" title="zookeeper"></a>zookeeper</h3><h4 id="zookeeper的理解"><a href="#zookeeper的理解" class="headerlink" title="zookeeper的理解"></a>zookeeper的理解</h4><ol>
<li>集群管理：提供了CP模型来保证集群中每个节点的数据一致性</li>
<li>分布式锁</li>
<li>集群选举</li>
</ol>
<h4 id="zookeeper选举机制"><a href="#zookeeper选举机制" class="headerlink" title="zookeeper选举机制"></a>zookeeper选举机制</h4><ul>
<li>LeaderElection  </li>
<li>AuthFastLeaderElection</li>
<li>FastLeaderElection （最新默认）</li>
</ul>
<p>目前有5台服务器，每台服务器均没有数据，它们的编号分别是1,2,3,4,5,按编号依次启动，它们的选择举过程如下：</p>
<ul>
<li>服务器1启动，给自己投票，然后发投票信息，由于其它机器还没有启动所以它收不到反馈信息，服务器1的状态一直属于Looking(选举状态)。</li>
<li>服务器2启动，给自己投票，同时与之前启动的服务器1交换结果，由于服务器2的编号大所以服务器2胜出，但此时投票数没有大于半数，所以两个服务器的状态依然是LOOKING。</li>
<li>服务器3启动，给自己投票，同时与之前启动的服务器1,2交换信息，由于服务器3的编号最大所以服务器3胜出，此时投票数正好大于半数，所以服务器3成为领导者，服务器1,2成为小弟。</li>
<li>服务器4启动，给自己投票，同时与之前启动的服务器1,2,3交换信息，尽管服务器4的编号大，但之前服务器3已经胜出，所以服务器4只能成为小弟。</li>
<li>服务器5启动，后面的逻辑同服务器4成为小弟。</li>
</ul>
<h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><h3 id="全局序号生成规则？"><a href="#全局序号生成规则？" class="headerlink" title="全局序号生成规则？"></a>全局序号生成规则？</h3><ol>
<li>UUID：没顺序，长度过长，作为主键索引效率低</li>
<li>数据库自增id：实现简单，保证唯一递增，扩展性差，有单点故障风险</li>
<li>redis生成id</li>
<li>雪花算法</li>
<li>通过一个序列表记录当前序列号，机器每次从序列表中获取一定步长的序列数然后缓存再本地，等用完后再重新从步长表获取</li>
</ol>
<h2 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h2><h3 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h3><p>​        CAP 理论又叫 Brewer 理论，这是加州大学伯克利分校的埃里克 · 布鲁尔（Eric Brewer）教授，在 2000 年 7 月“ACM 分布式计算原理研讨会（PODC）”上提出的一个猜想。<a href="chrome-extension://ikhdkkncnoglghljlkmcimlnlhkeamad/pdf-viewer/web/viewer.html?file=https%3A%2F%2Fpeople.eecs.berkeley.edu%2F~brewer%2Fcs262b-2004%2FPODC-keynote.pdf">CAP理论原稿</a>（那时候还只是猜想）然后到了 2002 年，麻省理工学院的赛斯 · 吉尔伯特（Seth Gilbert）和南希 · 林奇（Nancy Lynch）就以严谨的数学推理证明了这个 CAP 猜想。在这之后，CAP 理论就正式成为了分布式计算领域公认的著名定理。这个定理里，描述了一个分布式的系统中，当涉及到共享数据问题时，以下三个特性最多只能满足其中两个：</p>
<ol>
<li>一致性（Consistency）：代表在任何时刻、任何分布式节点中，我们所看到的数据都是没有矛盾的。这与 ACID 中的 C 是相同的单词，但它们又有不同的定义（分别指 Replication 的一致性和数据库状态的一致性）。在分布式事务中，ACID 的 C 要以满足 CAP 中的 C 为前提。</li>
<li>可用性（Availability）：代表系统不间断地提供服务的能力。</li>
<li>分区容忍性（Partition Tolerance）：代表分布式环境中，当部分节点因网络原因而彼此失联（即与其他节点形成“网络分区”）时，系统仍能正确地提供服务的能力。</li>
</ol>
<h3 id="DDD"><a href="#DDD" class="headerlink" title="DDD"></a>DDD</h3><p>ddd不是一种架构风格，而是一种方法论，什么是方法论，每个人按照自己的想法来设计就是一套方法论；ddd是一种业务比较认可，对于微服务拆分的一种方法论。</p>
<h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><ol>
<li>最近做的比较熟悉的项目是哪个？画一下项目技术架构图</li>
<li>写两个类，能够实现堆内存溢出和栈内存溢出</li>
<li>写一个线程安全的单例。</li>
<li>两个可变有序链表放到新数组中，有序</li>
</ol>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">李苟蛋</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zhangyong3214.github.io/2022/01/27/%E9%9D%A2%E8%AF%95%E5%9F%BA%E5%9C%B0/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/">https://zhangyong3214.github.io/2022/01/27/面试基地/常见面试题/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://lizejiao.github.io" target="_blank">老李家の苟蛋子</a> 许可协议。转载请注明来自 <a href="https://zhangyong3214.github.io" target="_blank">李苟蛋の家</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a></div><div class="post_share"><div class="social-share" data-image="/images/cover/interview.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat_pay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat_pay.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/01/27/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/%E5%85%8D%E8%B4%B9%E5%AF%86%E7%A0%81%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7KeePass%E6%B0%B8%E8%BF%9C%E7%9A%84%E7%A5%9E/"><img class="prev-cover" src="/images/cover/KeePass.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">军事级别安全强度，免费密码管理工具KeePass，永远滴神</div></div></a></div><div class="next-post pull-right"><a href="/2022/01/27/%E5%BC%80%E5%8F%91%E5%B7%A5%E4%BD%9C/%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83%E5%92%8C%E6%8A%80%E5%B7%A7/"><img class="next-cover" src="/images/cover/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">企业开发规范和技巧</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">李苟蛋</div><div class="author-info__description">欢迎来到李苟蛋的博客....</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/lizejiao"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/lizejiao" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:xxxxxx@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">欢迎来到李苟蛋的个人微博，对本站的文章和技术问题有疑问和建议请联系作者：QQ：8356132</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">1.</span> <span class="toc-text">基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-number">1.1.</span> <span class="toc-text">面向对象的特征?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84RuntimeException"><span class="toc-number">1.2.</span> <span class="toc-text">常见的RuntimeException</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.</span> <span class="toc-text">常见的引用类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM"><span class="toc-number">2.</span> <span class="toc-text">JVM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#jvm%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.1.</span> <span class="toc-text">jvm内存模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="toc-number">2.2.</span> <span class="toc-text">对象创建过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="toc-number">2.3.</span> <span class="toc-text">垃圾回收算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GC-Root%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">2.4.</span> <span class="toc-text">GC Root有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">2.5.</span> <span class="toc-text">垃圾回收器有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CMS%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%8C%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-number">2.6.</span> <span class="toc-text">CMS运行过程，缺点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#G1%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">2.7.</span> <span class="toc-text">G1运行过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#G1%E9%80%82%E5%90%88%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF"><span class="toc-number">2.8.</span> <span class="toc-text">G1适合什么场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%85%83%E7%A9%BA%E9%97%B4%E6%98%AF%E6%97%A0%E7%94%A8%E7%9A%84%E7%B1%BB"><span class="toc-number">2.9.</span> <span class="toc-text">判断元空间是无用的类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E7%82%B9%E5%92%8C%E5%AE%89%E5%85%A8%E5%8C%BA%E5%9F%9F"><span class="toc-number">2.10.</span> <span class="toc-text">安全点和安全区域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%9F%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%EF%BC%8C%E5%A5%BD%E5%A4%84%EF%BC%9F"><span class="toc-number">2.11.</span> <span class="toc-text">类加载器？双亲委派，好处？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#YGC%E5%92%8CFGC%E5%8F%91%E7%94%9F%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="toc-number">2.12.</span> <span class="toc-text">YGC和FGC发生的场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jstack%EF%BC%8Cjmap%EF%BC%8CJstat%E4%BD%9C%E7%94%A8"><span class="toc-number">2.13.</span> <span class="toc-text">jstack，jmap，Jstat作用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">3.1.</span> <span class="toc-text">死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sleep%E5%92%8Cwait%E5%8C%BA%E5%88%AB"><span class="toc-number">3.2.</span> <span class="toc-text">sleep和wait区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Volitile%E4%BD%9C%E7%94%A8"><span class="toc-number">3.3.</span> <span class="toc-text">Volitile作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Volitile%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">3.4.</span> <span class="toc-text">Volitile如何保证可见性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F"><span class="toc-number">3.5.</span> <span class="toc-text">指令重排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">3.6.</span> <span class="toc-text">Java线程的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#linux%E6%9F%A5%E7%9C%8B%E7%BA%BF%E7%A8%8B%E5%91%BD%E4%BB%A4"><span class="toc-number">3.7.</span> <span class="toc-text">linux查看线程命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">3.8.</span> <span class="toc-text">Java线程的实现方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Thread%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">3.9.</span> <span class="toc-text">Thread常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadLocal%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">3.10.</span> <span class="toc-text">ThreadLocal的实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadLocal%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">3.11.</span> <span class="toc-text">ThreadLocal应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadLocal%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E5%8E%9F%E5%9B%A0%EF%BC%8C%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D"><span class="toc-number">3.12.</span> <span class="toc-text">ThreadLocal内存泄露原因，如何避免</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized%E5%92%8CReentranLock%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.13.</span> <span class="toc-text">synchronized和ReentranLock区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8F%82%E6%95%B0%E6%9C%89%EF%BC%8C%E6%A0%B8%E5%BF%83%E7%BA%BF%E7%A8%8B%E9%85%8D%E7%BD%AE%EF%BC%8C%E5%8E%9F%E5%9B%A0%EF%BC%9F"><span class="toc-number">3.14.</span> <span class="toc-text">线程池参数有，核心线程配置，原因？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88"><span class="toc-number">4.</span> <span class="toc-text">集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Set-List-Map%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">4.1.</span> <span class="toc-text">Set,List,Map有什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap%E5%92%8CHashTable%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">4.2.</span> <span class="toc-text">HashMap和HashTable有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.3.</span> <span class="toc-text">HashMap底层实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap-put%E6%B5%81%E7%A8%8B"><span class="toc-number">4.4.</span> <span class="toc-text">HashMap put流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap%E6%89%A9%E5%AE%B9%E6%B5%81%E7%A8%8B"><span class="toc-number">4.5.</span> <span class="toc-text">HashMap扩容流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-number">4.6.</span> <span class="toc-text">为什么选择用红黑树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ConcurrentHaspMap"><span class="toc-number">4.7.</span> <span class="toc-text">ConcurrentHaspMap</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#spring"><span class="toc-number">5.</span> <span class="toc-text">spring</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Bean%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B"><span class="toc-number">5.1.</span> <span class="toc-text">Bean的初始化过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">5.2.</span> <span class="toc-text">Bean的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96"><span class="toc-number">5.3.</span> <span class="toc-text">循环依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOP%E7%9A%84%E9%A1%BA%E5%BA%8F"><span class="toc-number">5.4.</span> <span class="toc-text">AOP的顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#springMVC%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B"><span class="toc-number">5.5.</span> <span class="toc-text">springMVC处理请求流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#spring%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B6"><span class="toc-number">5.6.</span> <span class="toc-text">spring事务的传播机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RPC%E6%A1%86%E6%9E%B6"><span class="toc-number">6.</span> <span class="toc-text">RPC框架</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E7%9F%A5%E9%81%93%E7%9A%84json%E5%BA%8F%E5%88%97%E5%8C%96%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">6.1.</span> <span class="toc-text">你知道的json序列化方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E7%B3%BB%E7%BB%9F%E4%B9%8B%E9%97%B4%E6%80%8E%E4%B9%88%E4%BA%A4%E4%BA%92%E7%9A%84%EF%BC%9F"><span class="toc-number">6.2.</span> <span class="toc-text">两个系统之间怎么交互的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dubbo%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%9F"><span class="toc-number">6.3.</span> <span class="toc-text">dubbo的序列化？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C"><span class="toc-number">7.</span> <span class="toc-text">网络</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="toc-number">7.1.</span> <span class="toc-text">网络七层模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http1-0%E5%92%8Chttp1-1%E5%8C%BA%E5%88%AB"><span class="toc-number">7.2.</span> <span class="toc-text">http1.0和http1.1区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTPS%E4%B8%8EHTTP%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8C%BA%E5%88%AB"><span class="toc-number">7.3.</span> <span class="toc-text">HTTPS与HTTP的一些区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">7.4.</span> <span class="toc-text">http三次握手四次挥手</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">7.4.1.</span> <span class="toc-text">三次握手</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">7.4.2.</span> <span class="toc-text">四次挥手</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dubbo"><span class="toc-number">7.5.</span> <span class="toc-text">Dubbo</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Netty"><span class="toc-number">8.</span> <span class="toc-text">Netty</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#NIO%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6"><span class="toc-number">8.1.</span> <span class="toc-text">NIO三大核心组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Netty%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">8.2.</span> <span class="toc-text">Netty线程模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Netty%E6%A8%A1%E5%9D%97%E7%BB%84%E4%BB%B6"><span class="toc-number">8.3.</span> <span class="toc-text">Netty模块组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Netty%E7%B2%98%E5%8C%85%E6%8B%86%E5%8C%85"><span class="toc-number">8.4.</span> <span class="toc-text">Netty粘包拆包</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">9.</span> <span class="toc-text">数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ACID%E7%90%86%E8%AE%BA"><span class="toc-number">9.1.</span> <span class="toc-text">ACID理论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mysql%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84"><span class="toc-number">9.2.</span> <span class="toc-text">Mysql索引结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB%E5%92%8CMyISAM%E5%8C%BA%E5%88%AB"><span class="toc-number">9.3.</span> <span class="toc-text">InnoDB和MyISAM区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B%E6%A0%91%E5%92%8CB-%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">9.4.</span> <span class="toc-text">B树和B+数的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">9.5.</span> <span class="toc-text">事务隔离级别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mysql%E5%B9%BB%E8%AF%BB%E6%98%AF%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E7%9A%84"><span class="toc-number">9.6.</span> <span class="toc-text">Mysql幻读是怎么解决的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MVCC"><span class="toc-number">9.7.</span> <span class="toc-text">MVCC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF%E4%BC%9A%E5%BC%95%E5%8F%91%E5%B9%BB%E8%AF%BB"><span class="toc-number">9.8.</span> <span class="toc-text">什么场景会引发幻读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sql%E5%9C%A8mysql%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">9.9.</span> <span class="toc-text">sql在mysql的执行过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">9.10.</span> <span class="toc-text">事务怎么保证一致性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#binlog-%E3%80%81undo-%E3%80%81redo"><span class="toc-number">9.11.</span> <span class="toc-text">binlog 、undo 、redo</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%9A%E7%B0%87%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95"><span class="toc-number">9.12.</span> <span class="toc-text">聚簇和非聚簇索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%85%A2sql%E4%BC%98%E5%8C%96"><span class="toc-number">9.13.</span> <span class="toc-text">数据库慢sql优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">9.14.</span> <span class="toc-text">索引失效的情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8"><span class="toc-number">9.15.</span> <span class="toc-text">如何做分库分表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">9.16.</span> <span class="toc-text">Mysql主从复制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98-Redis-ES"><span class="toc-number">10.</span> <span class="toc-text">缓存:Redis&#x2F;ES</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">10.1.</span> <span class="toc-text">Redis数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">10.2.</span> <span class="toc-text">Redis单线程模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-number">10.3.</span> <span class="toc-text">分布式锁怎么实现的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setnx%E7%94%A8%E5%88%B0%E7%9A%84%E5%8F%82%E6%95%B0"><span class="toc-number">10.4.</span> <span class="toc-text">setnx用到的参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%EF%BC%8C%E5%87%BB%E7%A9%BF%EF%BC%8C%E9%9B%AA%E5%B4%A9"><span class="toc-number">10.5.</span> <span class="toc-text">缓存穿透，击穿，雪崩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">10.6.</span> <span class="toc-text">Redis持久化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">10.7.</span> <span class="toc-text">缓存与数据库数据一致性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ES%E7%AE%80%E4%BB%8B"><span class="toc-number">10.8.</span> <span class="toc-text">ES简介</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ES%E6%9F%A5%E8%AF%A2%E5%BF%AB%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">10.8.1.</span> <span class="toc-text">ES查询快的原因</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8ES%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">10.8.2.</span> <span class="toc-text">使用ES注意事项</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-number">11.</span> <span class="toc-text">中间件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">11.1.</span> <span class="toc-text">消息队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Rabbitmq%E7%94%9F%E4%BA%A7%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-number">11.1.1.</span> <span class="toc-text">Rabbitmq生产高可用怎么实现的</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#zookeeper"><span class="toc-number">11.2.</span> <span class="toc-text">zookeeper</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#zookeeper%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">11.2.1.</span> <span class="toc-text">zookeeper的理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#zookeeper%E9%80%89%E4%B8%BE%E6%9C%BA%E5%88%B6"><span class="toc-number">11.2.2.</span> <span class="toc-text">zookeeper选举机制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1"><span class="toc-number">12.</span> <span class="toc-text">微服务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%BA%8F%E5%8F%B7%E7%94%9F%E6%88%90%E8%A7%84%E5%88%99%EF%BC%9F"><span class="toc-number">12.1.</span> <span class="toc-text">全局序号生成规则？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%90%86%E8%AE%BA"><span class="toc-number">13.</span> <span class="toc-text">理论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CAP%E7%90%86%E8%AE%BA"><span class="toc-number">13.1.</span> <span class="toc-text">CAP理论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DDD"><span class="toc-number">13.2.</span> <span class="toc-text">DDD</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE"><span class="toc-number">14.</span> <span class="toc-text">项目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95"><span class="toc-number">15.</span> <span class="toc-text">算法</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/01/27/%E9%9D%A2%E8%AF%95%E5%9F%BA%E5%9C%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/" title="数据结构和算法"><img src="/images/cover/20210914232913.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据结构和算法"/></a><div class="content"><a class="title" href="/2022/01/27/%E9%9D%A2%E8%AF%95%E5%9F%BA%E5%9C%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/" title="数据结构和算法">数据结构和算法</a><time datetime="2022-01-27T08:31:13.129Z" title="发表于 2022-01-27 16:31:13">2022-01-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/27/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/Docker%E6%93%8D%E4%BD%9C%E7%AC%94%E8%AE%B0-%E4%BB%8E%E5%B0%8F%E7%99%BD%E5%88%B0%E5%85%A5%E9%97%A8/" title="Docker操作笔记-从小白到入门"><img src="/images/cover/docker.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Docker操作笔记-从小白到入门"/></a><div class="content"><a class="title" href="/2022/01/27/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/Docker%E6%93%8D%E4%BD%9C%E7%AC%94%E8%AE%B0-%E4%BB%8E%E5%B0%8F%E7%99%BD%E5%88%B0%E5%85%A5%E9%97%A8/" title="Docker操作笔记-从小白到入门">Docker操作笔记-从小白到入门</a><time datetime="2022-01-27T08:31:13.128Z" title="发表于 2022-01-27 16:31:13">2022-01-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/27/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/IDEA%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/" title="IDEA常用快捷键(Mac版)"><img src="/images/cover/idea.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="IDEA常用快捷键(Mac版)"/></a><div class="content"><a class="title" href="/2022/01/27/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/IDEA%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/" title="IDEA常用快捷键(Mac版)">IDEA常用快捷键(Mac版)</a><time datetime="2022-01-27T08:31:13.128Z" title="发表于 2022-01-27 16:31:13">2022-01-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/27/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/git%E7%AC%94%E8%AE%B0/" title="Git笔记-常用命令以及日常操作技巧汇总"><img src="/images/cover/git.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Git笔记-常用命令以及日常操作技巧汇总"/></a><div class="content"><a class="title" href="/2022/01/27/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/git%E7%AC%94%E8%AE%B0/" title="Git笔记-常用命令以及日常操作技巧汇总">Git笔记-常用命令以及日常操作技巧汇总</a><time datetime="2022-01-27T08:31:13.128Z" title="发表于 2022-01-27 16:31:13">2022-01-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/27/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/%E4%B8%BAMacOS%E6%89%93%E9%80%A0%E8%87%AA%E5%B7%B1%E7%82%AB%E9%85%B7%E7%BB%88%E7%AB%AF-/" title="为MacOS打造自己炫酷终端-Iterm2+oh-my-zsh"><img src="/images/cover/iterm2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="为MacOS打造自己炫酷终端-Iterm2+oh-my-zsh"/></a><div class="content"><a class="title" href="/2022/01/27/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/%E4%B8%BAMacOS%E6%89%93%E9%80%A0%E8%87%AA%E5%B7%B1%E7%82%AB%E9%85%B7%E7%BB%88%E7%AB%AF-/" title="为MacOS打造自己炫酷终端-Iterm2+oh-my-zsh">为MacOS打造自己炫酷终端-Iterm2+oh-my-zsh</a><time datetime="2022-01-27T08:31:13.128Z" title="发表于 2022-01-27 16:31:13">2022-01-27</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/default_top_img.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By 李苟蛋</div><div class="footer_custom_text">_φ(❐_❐✧ 人丑就要多读书😂，睡觉没前途(￣o￣) . z Z　🤣</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/chocolate.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="false" data-text="渴望,生锈,十七,黎明,火炉,苟蛋,善良,回家,货车,士兵" data-fontsize="15px" data-random="true" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>